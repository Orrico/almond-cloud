(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Almond
//
// Copyright 2016 The Board of Trustees of the Leland Stanford Junior University
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
//
// See COPYING for details
"use strict";

const adt = require('adt');

const ThingTalk = require('thingtalk');
const Ast = ThingTalk.Ast;

const ValueCategory = adt.data({
    YesNo: null,
    MultipleChoice: null,

    Number: null,
    Measure: { unit: adt.only(String) },
    RawString: null,
    Password: null,
    Date: null,
    Time: null,
    Unknown: null,
    Picture: null,
    Location: null,
    PhoneNumber: null,
    EmailAddress: null,
    Contact: null,
    Predicate: null,
    PermissionResponse: null,
    Command: null
});

ValueCategory.fromValue = function fromValue(value) {
    if (value.isVarRef)
        return ValueCategory.Unknown;

    var type = value.getType();

    if (type.isEntity && type.type === 'tt:picture')
        return ValueCategory.Picture;
    else if (type.isEntity && type.type === 'tt:phone_number')
        return ValueCategory.PhoneNumber;
    else if (type.isEntity && type.type === 'tt:email_address')
        return ValueCategory.EmailAddress;
    else if (type.isEntity && type.type === 'tt:contact')
        return ValueCategory.Contact;
    else if (type.isEntity)
        return ValueCategory.RawString;
    else if (type.isBoolean)
        return ValueCategory.YesNo;
    else if (type.isString)
        return ValueCategory.RawString;
    else if (type.isNumber)
        return ValueCategory.Number;
    else if (type.isMeasure)
        return ValueCategory.Measure(type.unit);
    else if (type.isEnum)
        return ValueCategory.RawString;
    else if (type.isTime)
        return ValueCategory.Time;
    else if (type.isDate)
        return ValueCategory.Date;
    else if (type.isLocation)
        return ValueCategory.Location;
    else
        return ValueCategory.Unknown;
};

ValueCategory.toAskSpecial = function toAskSpecial(expected) {
    let what;
    if (expected === ValueCategory.YesNo)
        what = 'yesno';
    else if (expected === ValueCategory.Location)
        what = 'location';
    else if (expected === ValueCategory.Picture)
        what = 'picture';
    else if (expected === ValueCategory.PhoneNumber)
        what = 'phone_number';
    else if (expected === ValueCategory.EmailAddress)
        what = 'email_address';
    else if (expected === ValueCategory.Contact)
        what = 'contact';
    else if (expected === ValueCategory.Number)
        what = 'number';
    else if (expected === ValueCategory.Date)
        what = 'date';
    else if (expected === ValueCategory.Time)
        what = 'time';
    else if (expected === ValueCategory.RawString)
        what = 'raw_string';
    else if (expected === ValueCategory.Password)
        what = 'password';
    else if (expected === ValueCategory.MultipleChoice)
        what = 'choice';
    else if (expected === ValueCategory.Command)
        what = 'command';
    else if (expected !== null)
        what = 'generic';
    else
        what = null;
    return what;
};

const Intent = adt.data({
    // internally generated intents
    Failed: { command: adt.only(Object, null) },
    Train: { command: adt.only(Object, null), fallbacks: adt.only(Array, null) },
    Back: null,
    More: null,
    Empty: null,
    Debug: null,
    Maybe: null,
    Unsupported: null,
    Example: { utterance: adt.only(String), targetCode: adt.only(String) },
    CommandList: { device: adt.only(String, null), category: adt.only(String) },

    // special entries in the grammar
    NeverMind: null, // cancel the current task
    Help: null, // ask for contextual help, or start a new task
    Make: null, // reset and start a new task
    WakeUp: null, // do nothing and wake up the screen

    // easter eggs
    Hello: null,
    Cool: null,
    ThankYou: null,
    Sorry: null,

    Answer: { category: adt.only(ValueCategory), value: adt.only(Ast.Value, Number) },

    // thingtalk
    Program: {
        program: adt.only(Ast.Program)
    },
    Predicate: {
        predicate: adt.only(Ast.BooleanExpression)
    },
    Setup: {
        program: adt.only(Ast.Program)
    },
    PermissionRule: {
        rule: adt.only(Ast.PermissionRule)
    }
});

const SPECIAL_INTENT_MAP = {
    makerule: Intent.Make,
    empty: Intent.Empty,
    back: Intent.Back,
    more: Intent.More,
    nevermind: Intent.NeverMind,
    debug: Intent.Debug,
    help: Intent.Help,
    maybe: Intent.Maybe,
    hello: Intent.Hello,
    cool: Intent.Cool,
    thankyou: Intent.ThankYou,
    thank_you: Intent.ThankYou,
    sorry: Intent.Sorry,
    wakeup: Intent.WakeUp,
};

function parseSpecial(special, command, previousCommand, previousCandidates) {
    let intent;
    special = special.substring('special:'.length);
    switch (special) {
    case 'yes':
        intent = new Intent.Answer(ValueCategory.YesNo, Ast.Value.Boolean(true));
        intent.isYes = true;
        intent.isNo = false;
        break;
    case 'no':
        intent = new Intent.Answer(ValueCategory.YesNo, Ast.Value.Boolean(false));
        intent.isYes = false;
        intent.isNo = true;
        break;
    case 'failed':
        intent = new Intent.Failed(command);
        break;
    case 'train':
        intent = new Intent.Train(previousCommand, previousCandidates);
        break;
    default:
        if (!SPECIAL_INTENT_MAP[special])
            throw new Error('Unrecognized special ' + special);
        intent = SPECIAL_INTENT_MAP[special];
    }
    return intent;
}

function parseBookeeping(code, schemaRetriever, entities, command, previousCommand, previousCandidates) {
    switch (code[1]) {
    case 'special':
        return parseSpecial(code[2], command, previousCommand, previousCandidates);

    case 'answer': {
        const value = ThingTalk.NNSyntax.fromNN(code.slice(1), entities);
        return new Intent.Answer(ValueCategory.fromValue(value), value);
    }
    case 'filter': {
        const predicate = ThingTalk.NNSyntax.fromNN(code.slice(1), entities);
        return new Intent.Predicate(predicate);
    }
    case 'category':
        return new Intent.CommandList(null, code[2]);
    case 'commands':
        return new Intent.CommandList(code[3].substring('device:'.length), code[2]);

    case 'choice':
        return new Intent.Answer(ValueCategory.MultipleChoice, parseInt(code[2]));

    default:
        throw new Error('Unrecognized bookkeeping command ' + code[1]);
    }
}

Intent.parse = function parse(json, schemaRetriever, command, previousCommand, previousCandidates) {
    if ('program' in json)
        return this.parseProgram(json.program, schemaRetriever);

    let { code, entities } = json;
    for (let name in entities) {
        if (name.startsWith('SLOT_')) {
            let slotname = json.slots[parseInt(name.substring('SLOT_'.length))];
            let slotType = ThingTalk.Type.fromString(json.slotTypes[slotname]);
            let value = ThingTalk.Ast.Value.fromJSON(slotType, entities[name]);
            entities[name] = value;
        }
    }

    if (code[0] === 'bookkeeping')
        return Promise.resolve(parseBookeeping(code, schemaRetriever, entities, command, previousCommand, previousCandidates));

    return Promise.resolve().then(() => {
        let program = ThingTalk.NNSyntax.fromNN(code, entities);
        return program.typecheck(schemaRetriever, true);
    }).then((program) => {
        if (program.isProgram) {
            if (program.principal !== null)
                return new Intent.Setup(program);
            else
                return new Intent.Program(program);
        } else {
            return new Intent.PermissionRule(program);
        }
    });
};

Intent.parseProgram = function parseProgram(thingtalk, schemaRetriever) {
    return ThingTalk.Grammar.parseAndTypecheck(thingtalk, schemaRetriever, true).then((prog) => {
        if (prog.isProgram) {
            if (prog.principal !== null)
                return new Intent.Setup(prog);
            else
                return new Intent.Program(prog);
        } else {
            return new Intent.PermissionRule(prog);
        }
    });
};

module.exports.Intent = Intent;
module.exports.ValueCategory = ValueCategory;
},{"adt":7,"thingtalk":43}],2:[function(require,module,exports){
// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Almond
//
// Copyright 2016 The Board of Trustees of the Leland Stanford Junior University
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
//
// See COPYING for details
"use strict";

const URL = 'https://almond-nl.stanford.edu';

module.exports = class ParserClient {
    constructor(baseUrl, locale) {
        this._locale = locale || 'en_US';
        this._baseUrl = (baseUrl || URL) + '/' + this._locale;

        console.log('Using Almond-NNParser at ' + this._baseUrl);
    }

    onlineLearn(utterance, code, store = 'automatic') {
        if (Array.isArray(code))
            code = code.join(' ');
        if (typeof code !== 'string')
            throw new TypeError('Invalid code parameter to onlineLearn');
        return Promise.resolve($.ajax(this._baseUrl + '/learn', {
            method: 'POST',
            data: { q: utterance, target: code, store }
        })).catch((e) => {
            // errors are useless because the browser blocks the response on error (due to
            // missing Access-Control-Allow-Origin)
            throw new Error('Failed to store the new sentence. You might need to wait until the natural language is fully trained.');
        });
    }

    tokenize(utterance) {
        let url = this._baseUrl + '/tokenize';
        return Promise.resolve($.ajax(url, { data: { q: utterance } })).then((parsed) => {
            if (parsed.error)
                throw new Error('Error received from Almond-NNParser server: ' + parsed.error);

            return parsed;
        });
    }

    sendUtterance(utterance, limit = -1) {
        let url = this._baseUrl + '/query';
        return Promise.resolve($.ajax(url, { data: { q: utterance, limit: limit, store:'yes' } })).then((parsed) => {
            if (parsed.error)
                throw new Error('Error received from Almond-NNParser server: ' + parsed.error);

            return parsed;
        });
    }
};

},{}],3:[function(require,module,exports){
// Polyfills from MDN and various places on the Internet

// The following is from the gjs project.
// Copyright 2014 Jasper St. Pierre, Florian Mullner, Dan Winship, et al.
//
// Licensed under the BSD license
"use strict";

function vprintf(str, args) {
    var i = 0;
    var usePos = false;
    return str.replace(/%(?:([1-9][0-9]*)\$)?([0-9]+)?(?:\.([0-9]+))?(.)/g, (str, posGroup, widthGroup, precisionGroup, genericGroup) => {
        if (precisionGroup && genericGroup !== 'f')
            throw new Error("Precision can only be specified for 'f'");

        var pos = parseInt(posGroup, 10) || 0;
        if (usePos === false && i === 0)
            usePos = pos > 0;
        if (usePos && pos === 0 || !usePos && pos > 0)
            throw new Error("Numbered and unnumbered conversion specifications cannot be mixed");

        var fillChar = (widthGroup && widthGroup[0] === '0') ? '0' : ' ';
        var width = parseInt(widthGroup, 10) || 0;

        function fillWidth(s, c, w) {
            var fill = '';
            for (var i = 0; i < w; i++)
                fill += c;
            return fill.substr(s.length) + s;
        }

        function getArg() {
            return usePos ? args[pos - 1] : args[i++];
        }

        var s = '';
        switch (genericGroup) {
        case '%':
            return '%';
        case 's':
            s = String(getArg());
            break;
        case 'd':
            var intV = parseInt(getArg());
            s = intV.toString();
            break;
        case 'x':
            s = parseInt(getArg()).toString(16);
            break;
        case 'f':
            if (precisionGroup === '' || precisionGroup === undefined)
                s = parseFloat(getArg()).toString();
            else
                s = parseFloat(getArg()).toFixed(parseInt(precisionGroup));
            break;
        default:
            throw new Error('Unsupported conversion character %' + genericGroup);
        }
        return fillWidth(s, fillChar, width);
    });
}

/*
 * This function is intended to extend the String object and provide
 * an String.format API for string formatting.
 * It has to be set up using String.prototype.format = Format.format;
 * Usage:
 * "somestring %s %d".format('hello', 5);
 * It supports %s, %d, %x and %f, for %f it also support precisions like
 * "%.2f".format(1.526). All specifiers can be prefixed with a minimum
 * field width, e.g. "%5s".format("foo"). Unless the width is prefixed
 * with '0', the formatted string will be padded with spaces.
 */
String.prototype.format = function format() {
    return vprintf(this, arguments);
};
},{}],4:[function(require,module,exports){
// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Almond
//
// Copyright 2016-2018 The Board of Trustees of the Leland Stanford Junior University
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
//
// See COPYING for details
"use strict";

const { Intent } = require('./intent');
const ThingTalk = require('thingtalk');
const Describe = ThingTalk.Describe;

const fakeGettext = {
    dgettext(domain, sentence) {
        return sentence;
    },

    dngettext(domain, sentence, plural, num) {
        if (num === 1)
            return sentence;
        else
            return plural;
    }
};

module.exports = function reconstructCanonical(schemaRetriever, code, entities) {
    return Intent.parse({ code, entities }, schemaRetriever, null, null, []).then((intent) => {
        if (intent.isFailed || intent.isFallback || intent.isTrain ||
            intent.isBack || intent.isEmpty || intent.isFilter || intent.isDebug || intent.isMore)
            throw new Error('Invalid internal intent ' + intent);

        if (intent.isNeverMind)
            return "never mind";
        if (intent.isHelp)
            return "help";
        if (intent.isMake)
            return "make a command";
        if (intent.isHello)
            return "hello";
        if (intent.isCool)
            return "this is cool";
        if (intent.isThankYou)
            return "thank you";
        if (intent.isSorry)
            return "i'm sorry";
        if (intent.isWakeUp)
            return "almond, wake up!";
        if (intent.isAnswer)
            return Describe.describeArg(fakeGettext, intent.value);

        if (intent.isPermissionRule)
            return Describe.describePermissionRule(fakeGettext, intent.rule);
        else
            return Describe.describeProgram(fakeGettext, intent.program);
    });
};

},{"./intent":1,"thingtalk":43}],5:[function(require,module,exports){
// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingEngine
//
// Copyright 2016 The Board of Trustees of the Leland Stanford Junior University
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
//
// See COPYING for details
"use strict";

const THINGPEDIA_URL = 'https://thingpedia.stanford.edu/thingpedia';

function httpRequest(url) {
    return Promise.resolve($.ajax(url));
}

module.exports = class ThingpediaClientBrowser {
    constructor(developerKey, locale) {
        this.developerKey = developerKey;
        this.locale = locale || 'en_US';
    }

    _simpleRequest(to, noAppend) {
        if (!noAppend) {
            to += '?locale=' + this.locale;
            if (this.developerKey)
                to += '&developer_key=' + this.developerKey;
        }

        return httpRequest(to);
    }

    getDeviceCode(id) {
        var to = THINGPEDIA_URL + '/api/code/devices/' + id;
        return this._simpleRequest(to);
    }

    getSchemas(kinds) {
        var to = THINGPEDIA_URL + '/api/schema/' + kinds.join(',');
        to += '?version=2&locale=' + this.locale;
        if (this.developerKey)
            to += '&developer_key=' + this.developerKey;
        return this._simpleRequest(to, true);
    }

    getMetas(kinds) {
        var to = THINGPEDIA_URL + '/api/schema-metadata/' + kinds.join(',');
        return this._simpleRequest(to);
    }

    getDeviceFactories(klass) {
        var to = THINGPEDIA_URL + '/api/devices';
        if (klass) {
            to += '?class=' + klass;
            if (this.developerKey)
                to += '&developer_key=' + this.developerKey;
            return this._simpleRequest(to, true);
        } else {
            return this._simpleRequest(to);
        }
    }

    getDeviceSetup(kinds) {
        var to = THINGPEDIA_URL + '/api/devices/setup/' + kinds.join(',');
        return this._simpleRequest(to);
    }

    getExamplesByKey(key, isBase) {
        var to = THINGPEDIA_URL + '/api/examples?locale=' + this.locale + '&key=' + encodeURIComponent(key)
            + '&base=' + (isBase ? '1' : '0');
        if (this.developerKey)
            to += '&developer_key=' + this.developerKey;
        return this._simpleRequest(to, true);
    }

    getExamplesByKinds(kinds, isBase) {
        var to = THINGPEDIA_URL + '/api/examples/by-kinds/' + kinds.join(',') + '?locale=' + this.locale
            + '&base=' + (isBase ? '1' : '0');
        if (this.developerKey)
            to += '&developer_key=' + this.developerKey;
        return this._simpleRequest(to, true);
    }
};

},{}],6:[function(require,module,exports){
// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingEngine
//
// Copyright 2016 The Board of Trustees of the Leland Stanford Junior University
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
//
// See COPYING for details
"use strict";

// This file is meant to be used as an entry point to a browserify
// bundle
// we can use commonjs but no nodejs deps

require('./polyfill');

const ThingTalk = require('thingtalk');
const SchemaRetriever = ThingTalk.SchemaRetriever;

const ParserClient = require('./parserclient');
const ThingpediaClient = require('./thingpediaclient');
const reconstructCanonical = require('./reconstruct_canonical');

class ThingTalkTrainer {
    constructor() {
        this.parser = new ParserClient('http://crowdie.stanford.edu:8400', 'en-US');

        this._locale = $('body[data-locale]').attr('data-locale');
        this._developerKey = $('body[data-developer-key]').attr('data-developer-key') || null;

        this.thingpedia = new ThingpediaClient(this._developerKey, this._locale);
        this._schemaRetriever = new SchemaRetriever(this.thingpedia);

        this._raw = null;
        this._entities = null;

        $('#counter').text(localStorage.getItem('counter') || 0);
        $('#sentence-to-code-form').submit(this._formSubmit.bind(this));
        $('#sentence-to-code-done').click(this._codeDone.bind(this));
    }

    _counter() {
        let v = localStorage.getItem('counter') || 0;
        v++;
        localStorage.setItem('counter', v);
        return v;
    }

    _accept(event) {
        event.preventDefault();

        const a = $(event.currentTarget);
        let code = a.attr('data-target');
        console.log('code', code);
        code = code.split(' ');

        var editThingTalk = $('#edit-thingtalk')[0].checked;
        if (editThingTalk) {
            this._toThingTalk(code).then((tt) => {
                $('#thingtalk-editor').removeClass('hidden');
                $('#thingtalk-group').removeClass('has-error');
                $('#thingtalk-error').text('');
                $('#thingtalk').val(tt);
            }).catch((e) => {
                alert(e.message+'\n'+e.stack);
            });
        } else {
            $('#thingtalk-editor').addClass('hidden');
            this._learnNN(code).then((data) => {
                $('#results-container').hide();
                if (data.error)
                    console.log('Error in learning', data.error);
                else
                    $('#counter').text(String(this._counter()));
            });
        }
    }

    // we can't train on a fully negative example, so we just do nothing
    // the sentence has been stored in the log anyway
    _rejectAll(event) {
        event.preventDefault();

        var editThingTalk = $('#edit-thingtalk')[0].checked;
        if (editThingTalk) {
            $('#thingtalk-editor').removeClass('hidden');
            $('#thingtalk-group').removeClass('has-error');
            $('#thingtalk-error').text('');
            $('#thingtalk').val('');
        } else {
            $('#results-container').hide();
            $('#counter').text(String(this._counter()));
        }
    }

    _writeCode(event) {
        event.preventDefault();

        $('#thingtalk-editor').removeClass('hidden');
        $('#thingtalk-group').removeClass('has-error');
        $('#thingtalk-error').text('');
        $('#thingtalk').val('');
    }

    _formSubmit(event) {
        event.preventDefault();

        this._handle($('#utterance').val()).then((candidates) => {
            $('#results-container').show();
            let results = $('#results');
            results.empty();

            let previous = null;
            let prediction = null;
            for (let candidate of candidates) {
                if (candidate === null)
                    continue;
                if (prediction === null)
                    prediction = candidate;
                if (candidate.canonical === previous)
                    continue;
                previous = candidate.canonical;
                let link = $('<a href="#">')
                    .text(candidate.canonical)
                    .addClass('result')
                    .attr('title', candidate.code.join(' '))
                    .attr('data-target', candidate.code.join(' '))
                    .click(this._accept.bind(this));
                results.append($('<li>').append(link));
            }
            if (prediction === null) {
                $('#prediction').text("Almond is confused and does not know what to do.");
            } else {
                $('#prediction').text(prediction.canonical);

                let link = $('<a href="#">')
                    .text('None of the above')
                    .addClass('result')
                    .click(this._rejectAll.bind(this));
                results.append($('<li>').append(link));
            }

            let link = $('<a href="#">')
                .text('Let me write the ThingTalk code')
                .addClass('result')
                .click(this._writeCode.bind(this));
            results.append($('<li>').append(link));
        });
    }

    _formatError(e) {
        var err;
        if (typeof e === 'string') {
            err = e;
        } else if (e.name === 'SyntaxError') {
            if (e.location)
                err = "Syntax error at line " + e.location.start.line + " column " + e.location.start.column + ": " + e.message;
            else
                err = "Syntax error at " + e.fileName + " line " + e.lineNumber + ": " + e.message;
        } else if (e.message) {
            err = e.message;
        } else {
            err = String(e);
        }
        return err;
    }

    _codeDone(event) {
        event.preventDefault();

        var tt = $('#thingtalk').val();
        this._learnThingTalk(tt).then((data) => {
            $('#results-container').hide();
            $('#thingtalk-editor').addClass('hidden');
            $('#thingtalk-group').removeClass('has-error');
            $('#thingtalk-error').text('');
            if (data.error)
                console.log('Error in learning', data.error);
            else
                $('#counter').text(String(this._counter()));
        }).catch((e) => {
            $('#thingtalk-group').addClass('has-error');
            $('#thingtalk-error').text(this._formatError(e));
        });
    }

    _toProgram(code) {
        let program = ThingTalk.NNSyntax.fromNN(code, this._entities);
        return program.typecheck(this._schemaRetriever, true);
    }

    _toThingTalk(code) {
        return this._toProgram(code).then((program) => program.prettyprint(true));
    }

    _toNN(program) {
        let clone = {};
        Object.assign(clone, this._entities);
        return ThingTalk.NNSyntax.toNN(program, this._tokens, clone);
    }

    _learnNN(targetCode) {
        return this.parser.onlineLearn(this._raw, targetCode, 'online');
    }

    _learnThingTalk(text) {
        const raw = this._raw;
        return ThingTalk.Grammar.parseAndTypecheck(text, this._schemaRetriever).then((program) => {
            const code = this._toNN(program);
            return this.parser.onlineLearn(raw, code, 'online');
        });
    }

    _handle(text) {
        return this.parser.sendUtterance(text).then((parsed) => {
            this._raw = text;
            this._tokens = parsed.tokens;
            this._entities = parsed.entities;
            return Promise.all(parsed.candidates.map((candidate) => {
                return reconstructCanonical(this._schemaRetriever, candidate.code, this._entities).then((canonical) => {
                    candidate.canonical = canonical;
                    return candidate;
                }).catch((e) => {
                    console.log('Failed to reconstruct canonical for ' + candidate.code + ': ' + e.message);
                    return null;
                });
            }));
        });
    }
}

$(() => {
    new ThingTalkTrainer();
});

},{"./parserclient":2,"./polyfill":3,"./reconstruct_canonical":4,"./thingpediaclient":5,"thingtalk":43}],7:[function(require,module,exports){
// adt.js 
// ------
// Algebraic data types and immutable structures in Javascript
//
// version : 0.7.2
// author  : Nathan Faubion <nathan@n-son.com>
// license : MIT

;(function (adt) {
  'use strict';

  // Base class from which all adt.js classes inherit.
  adt.__Base__ = function () {};

  // ADT Class Generation
  // --------------------

  adt.data = function () {
    var targ0 = typeof arguments[0];

    // adt.data(...names: String)
    if (targ0 === 'string') {
      var names = arguments;
      return adt.data(function (type) {
        var i = 0, len = names.length;
        for (; i < len; i++) type(names[i]);
      });
    }

    // adt.data(types: Object)
    if (targ0 === 'object') {
      var types = arguments[0];
      return adt.data(function (type) {
        for (var name in types) {
          if (types.hasOwnProperty(name)) type(name, types[name]);
        }
      });
    }

    // adt.data(configure: Function)
    var callback = arguments[0] || noop;
    var names = [];

    // Create a new parent class.
    // This class should never be created using `new`. You obviously can,
    // but it won't be of much use. You can however override the apply method
    // to create default instances.
    var D = inherit(adt.__Base__, function () {
      if (!(this instanceof D) && D.apply !== Function.prototype.apply) {
        return D.apply(this, arguments);
      }
      throw new Error('Bad invocation');
    });

    // Adds a new type to the ADT.
    D.type = function (name, tmpl) {
      if (typeof name !== 'string') {
        tmpl = name;
        name = uniqueId('Anonymous');
      }
      
      // Create a new template if not provided with one
      var isSingle = checkTypes([String, Boolean, Number, Date, null, void 0], tmpl);
      if (isSingle) tmpl = adt.single(tmpl);
      else if (typeof tmpl !== 'function') {
        tmpl = checkType(Array, tmpl)
          ? adt.record.apply(null, tmpl)
          : adt.record(tmpl);
      }

      // Add typechecking attributes for this type. Everything starts out as
      // false by default. Each individual class should overrides its own.
      D.prototype['is' + name] = false;

      // Call the template to build our type.
      var d = tmpl(D, name);

      // Bind the constructor context to avoid conflicts with calling as a method.
      d = (typeof d === 'function') ? extend(d.bind(), d) : d;

      // Export it on the parent type.
      D[name] = d;
      names.push(name);

      return d;
    };

    // Call the callback with the constructor as the context.
    var types = callback.call(D, D.type, D);

    // If an object was returned in the callback, assume it's a mapping of
    // more types to add.
    if (typeof types === 'object' && !(types instanceof adt.__Base__)) {
      for (var name in types) {
        if (types.hasOwnProperty(name)) D.type(name, types[name]);
      }
    }

    // Keep the type function around because it allows for nice type
    // declarations, but give the option to seal it. This will call `seal`
    // on any sub types to.
    D.seal = function () { 
      var i = 0, n, name;
      for (; n = names[i]; i++) if (this[n].seal) this[n].seal();
      delete D.type;
      delete D.seal;
      return D;
    };

    // Export names as a meta object
    D.__names__ = names;
    D.prototype.__adtClass__ = D;
    return D;
  };

  // Singleton Class Generation
  // --------------------------

  // Create a single empty class instance. You can pass in a value that the
  // class will use during JSON serialization.
  adt.single = function (val) {
    var ctr = function () {};
    ctr.__value__ = val === void 0 ? null : val;

    return function (parent, name) {
      inherit(parent, ctr);
      extend(ctr.prototype, adt.single.__methods__);

      ctr.className = name;
      ctr.prototype['is' + name] = true;

      return new ctr();
    };
  }

  // Singleton Methods
  // -----------------

  adt.single.__methods__ = {
    toString: function () {
      return this.constructor.className;
    },

    toJSON: function () {
      return this.constructor.__value__;
    },

    clone: function () {
      return this;
    },

    equals: function (that) {
      return this === that;
    },

    hasInstance: function(that) {
      return this === that;
    }
  };

  // Record Class Generation
  // -----------------------

  adt.record = function () {
    var targ0 = typeof arguments[0];

    // adt.record(...names: String)
    if (targ0 === 'string') {
      var names = arguments;
      return adt.record(function (field) {
        var i = 0, len = names.length;
        for (; i < len; i++) field(names[i], adt.any);
      });
    }

    // adt.record(fields: Object)
    else if (targ0 === 'object') {
      var fields = arguments[0];
      return adt.record(function (field) {
        for (var name in fields) {
          if (fields.hasOwnProperty(name)) field(name, fields[name]);
        }
      });
    }

    // adt.record(template: Function)
    var callback = arguments[0] || noop;
    var names = [];
    var constraints = {};

    // A record's constructor can be called without `new` and will also throw
    // an error if called with the wrong number of arguments. Its arguments can
    // be curried as long as it isn't called with the `new` keyword.
    var ctr = function () {
      var args = arguments;
      var len = names.length;
      if (this instanceof ctr) {
        if (args.length !== len) {
          throw new Error(
            'Unexpected number of arguments for ' + ctr.className + ': ' +
            'got ' + args.length + ', but need ' + len + '.'
          );
        }
        var i = 0, n;
        for (; n = names[i]; i++) {
          this[n] = constraints[n](args[i], n, ctr);
        }
      } else {
        return args.length < len
          ? partial(ctr, toArray(args))
          : ctrApply(ctr, args);
      }
    };

    return function (parent, name) {
      inherit(parent, ctr);
      extend(ctr, adt.record.__classMethods__);
      extend(ctr.prototype, adt.record.__methods__);

      ctr.className = name;
      ctr.prototype['is' + name] = true;

      // Declares a field as part of the type.
      ctr.field = function (name, constraint) {
        if (!constraint) constraint = adt.any;
        if (typeof constraint !== 'function') {
          throw new TypeError('Constraints must be functions')
        }
        names.push(name);
        constraints[name] = constraint;
        return ctr;
      };

      // Call the callback with the contructor as the context.
      var fields = callback.call(ctr, ctr.field, ctr);

      // If an object was returned in the callback, assume it's a mapping of
      // more fields to add.
      if (typeof fields === 'object' && fields !== ctr) {
        for (var name in fields) {
          if (fields.hasOwnProperty(name)) ctr.field(name, fields[name]);
        }
      }

      // Export names and constraints as meta attributes.
      ctr.__names__ = names;
      ctr.__constraints__ = constraints;
      return ctr;
    };
  };

  // Record Methods
  // --------------
  
  adt.record.__methods__ = {
    toString: function () {
      var ctr = this.constructor;
      var vals = ctr.unapply(this);
      return ctr.className + (vals.length ? '(' + vals.join(', ') + ')' : '');
    },

    toJSON: function () {
      return this.constructor.unapplyObject(this, toJSONValue);
    },

    // Clones any value that is an adt.js type, delegating other JS values
    // to `adt.nativeClone`.
    clone: function () {
      var ctr = this.constructor;
      var names = ctr.__names__;
      var args = [], i = 0, n, val;
      for (; n = names[i]; i++) {
        val = this[n];
        args[i] = val instanceof adt.__Base__ 
          ? val.clone()
          : adt.nativeClone(val);
      }
      return ctr.apply(null, args);
    },

    // Recursively compares all adt.js types, delegating other JS values
    // to `adt.nativeEquals`.
    equals: function (that) {
      var ctr = this.constructor;
      if (this === that) return true;
      if (!(that instanceof ctr)) return false;
      var names = ctr.__names__;
      var i = 0, len = names.length;
      var vala, valb, n;
      for (; i < len; i++) {
        n = names[i], vala = this[n], valb = that[n];
        if (vala instanceof adt.__Base__) {
          if (!vala.equals(valb)) return false;
        } else if (!adt.nativeEquals(vala, valb)) return false;
      }
      return true;
    },

    // Overloaded to take either strings or numbers. Throws an error if the
    // key can't be found.
    get: function (field) {
      var ctr = this.constructor;
      var names = ctr.__names__;
      var constraints = ctr.__constraints__;
      if (typeof field === 'number') {
        if (field < 0 || field > names.length - 1) {
          throw new Error('Field index out of range: ' + field);
        }
        field = names[field];
      } else {
        if (!constraints.hasOwnProperty(field)) {
          throw new Error('Field name does not exist: ' + field);
        }
      }
      return this[field];
    },

    set: function (vals) {
      var ctr = this.constructor;
      var names = ctr.__names__;
      var args = [], i = 0, n;
      for (; n = names[i]; i++) args[i] = n in vals ? vals[n] : this[n];
      return ctr.apply(null, args);
    }
  };

  adt.record.__classMethods__ = {
    create: function (vals) {
      var args = [];
      var names = this.__names__;
      var i = 0, len = names.length, n;
      for (; n = names[i]; i++) {
        if (!(n in vals)) {
          throw new Error('Missing `' + n + '` in arguments to ' + this.className);
        }
        args[i] = vals[n];
      }
      return this.apply(null, args);
    },

    hasInstance: function (inst) {
      return inst instanceof this;
    },

    unapply: function (inst, fn) {
      if (this.hasInstance(inst)) {
        var names = this.__names__;
        var vals = [], i = 0, n;
        for (; n = names[i]; i++) vals[i] = fn ? fn(inst[n], n) : inst[n];
        return vals;
      }
    },

    unapplyObject: function (inst, fn) {
      if (this.hasInstance(inst)) {
        var names = this.__names__;
        var vals = {}, i = 0, n;
        for (; n = names[i]; i++) vals[n] = fn ? fn(inst[n], n) : inst[n];
        return vals;
      }
    },

    seal: function () {
      delete this.field;
      delete this.seal;
      return this;
    }
  };

  // Enum Class Generation
  // ---------------------

  adt.enumeration = function () {
    var E = adt.data.apply(null, arguments);
    var order = 0;

    // Helper to add the order meta attribute to a type.
    function addOrder (that) {
      if (that.constructor) that = that.constructor;
      that.__order__ = order++;
      return that;
    }

    // Iterate through the created types, applying the order meta attribute.
    for (var i = 0, n; n = E.__names__[i]; i++) addOrder(E[n]);

    // Patch the type function to add an order to any types created later.
    var __type = E.type;
    E.type = function () {
      return addOrder(__type.apply(E, arguments));
    };

    extend(E.prototype, adt.enumeration.__methods__);
    return E;
  };

  adt['enum'] = adt.enumeration;

  // Enum Methods
  // ------------

  function assertADT (a, b) {
    if (b instanceof a.__adtClass__) return true;
    throw new TypeError('Unexpected type');
  }

  function orderOf (that) {
    return that.constructor.__order__;
  }

  adt.enumeration.__methods__ = {
    lt: function (that) {
      return assertADT(this, that) && orderOf(this) < orderOf(that);
    },

    lte: function (that) {
      return assertADT(this, that) && orderOf(this) <= orderOf(that);
    },

    gt: function (that) {
      return assertADT(this, that) && orderOf(this) > orderOf(that);
    },

    gte: function (that) {
      return assertADT(this, that) && orderOf(this) >= orderOf(that);
    },

    eq: function (that) {
      return assertADT(this, that) && orderOf(this) === orderOf(that);
    },

    neq: function (that) {
      return assertADT(this, that) && orderOf(this) !== orderOf(that);
    },
  };

  // Public Helpers
  // --------------

  // Cloning for native JS types just returns a reference.
  adt.nativeClone = function (x) { return x; };

  // Equality for native JS types is just strict comparison.
  adt.nativeEquals = function (a, b) { return a === b; };

  // Shortcut for creating an ADT with only one type.
  adt.newtype = function () {
    var args = toArray(arguments);
    var data = adt.data();
    return data.type.apply(data, args);
  };

  // A contraint function that will accept any value.
  adt.any = function (x) { return x; };

  // A constraint generator that will perform instanceof checks on the value
  // to make sure it is of the correct type.
  adt.only = function () {
    var args = arguments;
    return function (x, field, ctr) {
      if (checkTypes(args, x)) return x;
      var err = 'Unexpected type';
      if (field && ctr) err += ' for `' + field + '` of ' + ctr.className;
      throw new TypeError(err);
    };
  };

  // Utility Functions
  // -----------------

  function toArray (a, start) {
    var dest = [], i = start || 0, len = a.length;
    for (; i < len; i++) dest.push(a[i]);
    return dest;
  }

  function ctrApply (ctr, args) {
    var C = function () {};
    C.prototype = ctr.prototype;
    var inst = new C();
    var ret = ctr.apply(inst, args);
    return inst;
  }

  function inherit (sup, sub) {
    var C = function () {};
    C.prototype = sup.prototype;
    sub.prototype = new C();
    sub.prototype.constructor = sub;
    return sub;
  }

  function partial (func, args) {
    return function () {
      return func.apply(this, args.concat(toArray(arguments)));
    };
  }

  function extend (dest /*, ...sources*/) {
    var args = toArray(arguments, 1);
    var i = 0, len = args.length, k;
    for (; i < len; i++) {
      for (k in args[i]) {
        if (args[i].hasOwnProperty(k)) dest[k] = args[i][k];
      }
    }
    return dest;
  };

  function checkType (type, x) {
    if (type instanceof Function) {
      if (x instanceof type
      || type === Number  && typeof x === 'number'
      || type === String  && typeof x === 'string'
      || type === Boolean && typeof x === 'boolean') return true;
    } else {
      if (type instanceof adt.__Base__ && type.equals(x)
      || type === x) return true;
    }
    return false;
  }

  function checkTypes(types, x) {
    var i = 0, len = types.length;
    for (; i < len; i++) if (checkType(types[i], x)) return true;
    return false;
  }

  function toJSONValue (x) {
    return x && typeof x === 'object' && x.toJSON ? x.toJSON() : x;
  }

  var id = 0;
  function uniqueId (pre) {
    return (pre || '') + id++;
  }

  function noop () {}

})(typeof exports !== 'undefined' ? exports : (this.adt = {}));

},{}],8:[function(require,module,exports){
(function (global){
'use strict';

// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }
  return !!(b != null && b._isBuffer);
}

// based on node assert, original notice:

// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = require('util/');
var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;
var functionsHaveNames = (function () {
  return function foo() {}.name === 'foo';
}());
function pToString (obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }
  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }
  if (functionsHaveNames) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' +  name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' +
         self.operator + ' ' +
         truncate(inspect(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') &&
             (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected;

  // If both values are instances of typed arrays, wrap their underlying
  // ArrayBuffers in a Buffer each to increase performance
  // This optimization requires the arrays to have the same type as checked by
  // Object.prototype.toString (aka pToString). Never perform binary
  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
  // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) &&
             pToString(actual) === pToString(expected) &&
             !(actual instanceof Float32Array ||
               actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer),
                   new Uint8Array(expected.buffer)) === 0;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {actual: [], expected: []};

    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined)
    return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}


// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if ((isUnwantedException &&
      userProvidedMessage &&
      expectedException(actual, expected)) ||
      isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
};

assert.ifError = function(err) { if (err) throw err; };

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"util/":73}],9:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],10:[function(require,module,exports){

},{}],11:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],12:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  get: function () {
    if (!(this instanceof Buffer)) {
      return undefined
    }
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  get: function () {
    if (!(this instanceof Buffer)) {
      return undefined
    }
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('Invalid typed array length')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (isArrayBuffer(value) || (value && isArrayBuffer(value.buffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  return fromObject(value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj) {
    if (ArrayBuffer.isView(obj) || 'length' in obj) {
      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
        return createBuffer(0)
      }
      return fromArrayLike(obj)
    }

    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data)
    }
  }

  throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object.')
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (ArrayBuffer.isView(buf)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isArrayBuffer(string)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : new Buffer(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffers from another context (i.e. an iframe) do not pass the `instanceof` check
// but they should be treated as valid. See: https://github.com/feross/buffer/issues/166
function isArrayBuffer (obj) {
  return obj instanceof ArrayBuffer ||
    (obj != null && obj.constructor != null && obj.constructor.name === 'ArrayBuffer' &&
      typeof obj.byteLength === 'number')
}

function numberIsNaN (obj) {
  return obj !== obj // eslint-disable-line no-self-compare
}

},{"base64-js":9,"ieee754":17}],13:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var objectCreate = Object.create || objectCreatePolyfill
var objectKeys = Object.keys || objectKeysPolyfill
var bind = Function.prototype.bind || functionBindPolyfill

function EventEmitter() {
  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {
    this._events = objectCreate(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

var hasDefineProperty;
try {
  var o = {};
  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });
  hasDefineProperty = o.x === 0;
} catch (err) { hasDefineProperty = false }
if (hasDefineProperty) {
  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      // check whether the input is a positive number (whose value is zero or
      // greater and not a NaN).
      if (typeof arg !== 'number' || arg < 0 || arg !== arg)
        throw new TypeError('"defaultMaxListeners" must be a positive number');
      defaultMaxListeners = arg;
    }
  });
} else {
  EventEmitter.defaultMaxListeners = defaultMaxListeners;
}

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    if (arguments.length > 1)
      er = arguments[1];
    if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Unhandled "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
      // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
      // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = objectCreate(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
          listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
          prepend ? [listener, existing] : [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
            existing.length + ' "' + String(type) + '" listeners ' +
            'added. Use emitter.setMaxListeners() to ' +
            'increase limit.');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        if (typeof console === 'object' && console.warn) {
          console.warn('%s: %s', w.name, w.message);
        }
      }
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    switch (arguments.length) {
      case 0:
        return this.listener.call(this.target);
      case 1:
        return this.listener.call(this.target, arguments[0]);
      case 2:
        return this.listener.call(this.target, arguments[0], arguments[1]);
      case 3:
        return this.listener.call(this.target, arguments[0], arguments[1],
            arguments[2]);
      default:
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; ++i)
          args[i] = arguments[i];
        this.listener.apply(this.target, args);
    }
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = bind.call(onceWrapper, state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = objectCreate(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else
          spliceOne(list, position);

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = objectCreate(null);
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = objectCreate(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = objectKeys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = objectCreate(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (!events)
    return [];

  var evlistener = events[type];
  if (!evlistener)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function objectCreatePolyfill(proto) {
  var F = function() {};
  F.prototype = proto;
  return new F;
}
function objectKeysPolyfill(obj) {
  var keys = [];
  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {
    keys.push(k);
  }
  return k;
}
function functionBindPolyfill(context) {
  var fn = this;
  return function () {
    return fn.apply(context, arguments);
  };
}

},{}],14:[function(require,module,exports){
(function (Buffer){
// Copyright (C) 2011-2015 John Hewson
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.

var stream = require('stream'),
    util = require('util'),
    timers = require('timers');

// convinience API
module.exports = function(readStream, options) {
  return module.exports.createStream(readStream, options);
};

// basic API
module.exports.createStream = function(readStream, options) {
  if (readStream) {
    return createLineStream(readStream, options);
  } else {
    return new LineStream(options);
  }
};

// deprecated API
module.exports.createLineStream = function(readStream) {
  console.log('WARNING: byline#createLineStream is deprecated and will be removed soon');
  return createLineStream(readStream);
};

function createLineStream(readStream, options) {
  if (!readStream) {
    throw new Error('expected readStream');
  }
  if (!readStream.readable) {
    throw new Error('readStream must be readable');
  }
  var ls = new LineStream(options);
  readStream.pipe(ls);
  return ls;
}

//
// using the new node v0.10 "streams2" API
//

module.exports.LineStream = LineStream;

function LineStream(options) {
  stream.Transform.call(this, options);
  options = options || {};

  // use objectMode to stop the output from being buffered
  // which re-concatanates the lines, just without newlines.
  this._readableState.objectMode = true;
  this._lineBuffer = [];
  this._keepEmptyLines = options.keepEmptyLines || false;
  this._lastChunkEndedWithCR = false;

  // take the source's encoding if we don't have one
  var self = this;
  this.on('pipe', function(src) {
    if (!self.encoding) {
      // but we can't do this for old-style streams
      if (src instanceof stream.Readable) {
        self.encoding = src._readableState.encoding;
      }
    }
  });
}
util.inherits(LineStream, stream.Transform);

LineStream.prototype._transform = function(chunk, encoding, done) {
  // decode binary chunks as UTF-8
  encoding = encoding || 'utf8';
  
  if (Buffer.isBuffer(chunk)) {
    if (encoding == 'buffer') {
      chunk = chunk.toString(); // utf8
      encoding = 'utf8';
    }
    else {
     chunk = chunk.toString(encoding);
    }
  }
  this._chunkEncoding = encoding;
  
  // see: http://www.unicode.org/reports/tr18/#Line_Boundaries
  var lines = chunk.split(/\r\n|[\n\v\f\r\x85\u2028\u2029]/g);
  
  // don't split CRLF which spans chunks
  if (this._lastChunkEndedWithCR && chunk[0] == '\n') {
    lines.shift();
  }
  
  if (this._lineBuffer.length > 0) {
    this._lineBuffer[this._lineBuffer.length - 1] += lines[0];
    lines.shift();
  }

  this._lastChunkEndedWithCR = chunk[chunk.length - 1] == '\r';
  this._lineBuffer = this._lineBuffer.concat(lines);
  this._pushBuffer(encoding, 1, done);
};

LineStream.prototype._pushBuffer = function(encoding, keep, done) {
  // always buffer the last (possibly partial) line
  while (this._lineBuffer.length > keep) {
    var line = this._lineBuffer.shift();
    // skip empty lines
    if (this._keepEmptyLines || line.length > 0 ) {
      if (!this.push(this._reencode(line, encoding))) {
        // when the high-water mark is reached, defer pushes until the next tick
        var self = this;
        timers.setImmediate(function() {
          self._pushBuffer(encoding, keep, done);
        });
        return;
      }
    }
  }
  done();
};

LineStream.prototype._flush = function(done) {
  this._pushBuffer(this._chunkEncoding, 0, done);
};

// see Readable::push
LineStream.prototype._reencode = function(line, chunkEncoding) {
  if (this.encoding && this.encoding != chunkEncoding) {
    return new Buffer(line, chunkEncoding).toString(this.encoding);
  }
  else if (this.encoding) {
    // this should be the most common case, i.e. we're using an encoded source stream
    return line;
  }
  else {
    return new Buffer(line, chunkEncoding);
  }
};

}).call(this,require("buffer").Buffer)
},{"buffer":12,"stream":42,"timers":69,"util":73}],15:[function(require,module,exports){
// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// Copyright 2017 The Board of Trustees of the Leland Stanford Junior University
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
//
// See COPYING for details
"use strict";

module.exports = class ConsumerQueue {
    constructor() {
        this._head = null;
        this._tail = null;
        this._waiter = null;
        this._cancel = null;
    }

    tryPop() {
        if (this._head !== null) {
            let data = this._head.data;
            this._head = this._head.next;
            if (this._head === null)
                this._tail = null;
            return data;
        } else {
            return null;
        }
    }

    // For compatibility with AsyncIterator
    next() {
        return this.pop();
    }

    pop() {
        if (this._head !== null) {
            return Promise.resolve(this.tryPop());
        } else if (this._waiter !== null) {
            throw new Error('Someone is already waiting on this queue');
        } else {
            return new Promise((callback, errback) => {
                this._waiter = callback;
                this._cancel = errback;
            });
        }
    }
    cancelWait(err) {
        let cancel = this._cancel;
        this._cancel = null;
        this._waiter = null;
        if (cancel)
            cancel(err);
    }

    hasWaiter() {
        return this._waiter !== null;
    }

    push(data) {
        let waiter = this._waiter;
        this._waiter = null;
        this._cancel = null;
        if (waiter) {
            waiter(data);
        } else if (this._tail === null) {
            this._head = this._tail = { data: data, next: null };
        } else {
            this._tail.next = { data: data, next: null };
            this._tail = this._tail.next;
        }
    }
};
},{}],16:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":require("../../is-buffer/index.js")})
},{"../../is-buffer/index.js":19}],17:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],18:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],19:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],20:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],21:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],22:[function(require,module,exports){
module.exports = require('./lib/_stream_duplex.js');

},{"./lib/_stream_duplex.js":23}],23:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};
},{"./_stream_readable":25,"./_stream_writable":27,"core-util-is":16,"inherits":18,"process-nextick-args":31}],24:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":26,"core-util-is":16,"inherits":18}],25:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./_stream_duplex":23,"./internal/streams/BufferList":28,"./internal/streams/destroy":29,"./internal/streams/stream":30,"_process":21,"core-util-is":16,"events":13,"inherits":18,"isarray":20,"process-nextick-args":31,"safe-buffer":37,"string_decoder/":32,"util":10}],26:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":23,"core-util-is":16,"inherits":18}],27:[function(require,module,exports){
(function (process,global,setImmediate){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)
},{"./_stream_duplex":23,"./internal/streams/destroy":29,"./internal/streams/stream":30,"_process":21,"core-util-is":16,"inherits":18,"process-nextick-args":31,"safe-buffer":37,"timers":69,"util-deprecate":70}],28:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = require('safe-buffer').Buffer;
var util = require('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}
},{"safe-buffer":37,"util":10}],29:[function(require,module,exports){
'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":31}],30:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":13}],31:[function(require,module,exports){
(function (process){
'use strict';

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


}).call(this,require('_process'))
},{"_process":21}],32:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":37}],33:[function(require,module,exports){
module.exports = require('./readable').PassThrough

},{"./readable":34}],34:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":23,"./lib/_stream_passthrough.js":24,"./lib/_stream_readable.js":25,"./lib/_stream_transform.js":26,"./lib/_stream_writable.js":27}],35:[function(require,module,exports){
module.exports = require('./readable').Transform

},{"./readable":34}],36:[function(require,module,exports){
module.exports = require('./lib/_stream_writable.js');

},{"./lib/_stream_writable.js":27}],37:[function(require,module,exports){
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":12}],38:[function(require,module,exports){
// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// Copyright 2017 Giovanni Campagna <gcampagn@cs.stanford.edu>
//
// See LICENSE for details
"use strict";

module.exports = require('./lib/smtlib');

module.exports.BaseSolver = require('./lib/base_solver');
module.exports.LocalCVC4Solver = require('./lib/local_cvc4');

},{"./lib/base_solver":39,"./lib/local_cvc4":40,"./lib/smtlib":41}],39:[function(require,module,exports){
// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// Copyright 2017 Giovanni Campagna <gcampagn@cs.stanford.edu>
//
// See LICENSE for details
"use strict";

const smt = require('./smtlib');

module.exports = class BaseSmtSolver {
    constructor(logic) {
        this._statements = [
            smt.SetLogic('QF_ALL_SUPPORTED')
        ];

        this.withAssignments = false;
        this.timeLimit = 180000;
    }

    enableAssignments() {
        this.withAssignments = true;
        this.add(smt.SetOption('produce-assignments'));
        this.add(smt.SetOption('produce-models'));
    }

    dump() {
        for (let stmt of this._statements)
            console.log(stmt.toString());
    }

    forEachStatement(callback) {
        this._statements.forEach(callback);
    }

    checkSat() {
        throw new Error('checkSat not implemented for this solver');
    }

    add(stmt) {
        this._statements.push(stmt);
    }

    assert(expr) {
        this.add(smt.Assert(expr));
    }

    setOption(opt, value = true) {
        this.add(smt.SetOption(opt, value));
    }

    declareFun(name, args, type) {
        this.add(smt.DeclareFun(name, args, type));
    }
};

},{"./smtlib":41}],40:[function(require,module,exports){
// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// Copyright 2017 Giovanni Campagna <gcampagn@cs.stanford.edu>
//
// See LICENSE for details
"use strict";

const child_process = require('child_process');
const byline = require('byline');

const smt = require('./smtlib');
const BaseSolver = require('./base_solver');

module.exports = class LocalCVC4Solver extends BaseSolver {
    constructor(logic) {
        super(logic);
        this.setOption('strings-exp');
        this.setOption('strings-guess-model');
    }

    checkSat() {
        return new Promise((callback, errback) => {
            this.add(smt.CheckSat());

            let args = ['--lang', 'smt2.6', '--tlimit=' + this.timeLimit, '--cpu-time'];
            if (this.withAssignments) {
                args.push('--dump-models');
            }

            let now = new Date;
            let child = child_process.spawn('cvc4', args);

            child.stdin.setDefaultEncoding('utf8');
            this.forEachStatement((stmt) => child.stdin.write(stmt.toString()));
            child.stdin.end();
            child.stderr.setEncoding('utf8');
            let stderr = byline(child.stderr);
            stderr.on('data', (data) => {
                console.error('SMT-ERR:', data);
            });
            child.stdout.setEncoding('utf8');
            let stdout = byline(child.stdout);
            let sat = undefined;
            let assignment = {};
            let cidx = 0;
            let constants = {};
            stdout.on('data', (line) => {
                //console.log('SMT:', line);
                if (line === 'sat') {
                    sat = true;
                    return;
                }
                if (line === 'unsat') {
                    sat = false;
                    return;
                }
                if (line === 'unknown') {
                    sat = true;
                    console.error('SMT TIMED OUT');
                    this.dump();
                    return;
                }
                if (line.startsWith('(error')) {
                    return errback(new Error('SMT error: ' + line));
                }

                const CONSTANT_REGEX = /; rep: @uc_([A-Za-z0-9_]+)$/;
                let match = CONSTANT_REGEX.exec(line);
                if (match !== null) {
                    constants[match[1]] = cidx++;
                    return;
                }
                const ASSIGN_CONST_REGEX = /\(define-fun ([A-Za-z0-9_.]+) \(\) ([A-Za-z0-9_]+) @uc_([A-Za-z0-9_]+)\)$/
                match = ASSIGN_CONST_REGEX.exec(line);
                if (match !== null) {
                    assignment[match[1]] = constants[match[3]];
                    return;
                }

                const ASSIGN_BOOL_REGEX = /\(define-fun ([A-Za-z0-9_.]+) \(\) Bool (true|false)\)$/;
                match = ASSIGN_BOOL_REGEX.exec(line);
                if (match !== null) {
                    assignment[match[1]] = (match[2] === 'true');
                    return;
                }

                // ignore everything else
            });
            stdout.on('end', () => {
                console.log('SMT elapsed time: ' + ((new Date).getTime() - now.getTime()));

                if (sat)
                    callback([true, assignment]);
                else
                    callback([false, undefined])
            });

            child.stdout.on('error', errback);
        });
    }
}

},{"./base_solver":39,"./smtlib":41,"byline":14,"child_process":11}],41:[function(require,module,exports){
// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// Copyright 2017 Giovanni Campagna <gcampagn@cs.stanford.edu>
//
// See LICENSE for details
"use strict";

function stringEscape(str) {
    return '"' + str.replace(/(["\\])/g, '\\$1').replace(/\n/g, '\\n') + '"';
    // the following comment fixes broken syntax highlighting in GtkSourceView
    //]/
}

class SExpr {
    constructor(...children) {
        this._children = children;
    }

    toString() {
        return '(' + this._children.join(' ') + ')';
    }
}

function SetLogic(logic) {
    return new SExpr('set-logic', logic);
}
function SetOption(opt, value = true) {
    return new SExpr('set-option', ':' + opt, value);
}
function DeclareDatatype(name, constructors) {
    let sortdec = new SExpr(name, 0);
    let datatypedec = new SExpr(...constructors.map((c) => Array.isArray(c) ? new SExpr(...c) : new SExpr(c)));

    return new SExpr('declare-datatypes', new SExpr(sortdec), new SExpr(datatypedec));
}
function DeclareSort(name) {
    return new SExpr('declare-sort', name, '0');
}
function DeclareFun(name, args, ret) {
    return new SExpr('declare-fun', name, new SExpr(...args), ret);
}
function DefineFun(name, args, ret, def) {
    return new SExpr('define-fun', name, new SExpr(...args), ret, def);
}
function Assert(assert) {
    return new SExpr('assert', assert);
}
function Predicate(pred, ...args) {
    if (args.length === 0)
        return pred;
    else
        return new SExpr(pred, ...args);
}
function Implies(lhs, rhs) {
    return new SExpr('=>', lhs, rhs);
}
function And(...args) {
    if (args.length === 1)
        return args[0];
    return new SExpr('and', ...args);
}
function Or(...args) {
    if (args.length === 1)
        return args[0];
    return new SExpr('or', ...args);
}
function Not(expr) {
    return new SExpr('not', expr);
}
function Eq(lhs, rhs) {
    return new SExpr('=', lhs, rhs);
}
function NEq(lhs, rhs) {
    return Not(Eq(lhs, rhs));
}
function LEq(lhs, rhs) {
    return new SExpr('<=', lhs, rhs);
}
function GEq(lhs, rhs) {
    return new SExpr('>=', lhs, rhs);
}
function LT(lhs, rhs) {
    return new SExpr('<', lhs, rhs);
}
function GT(lhs, rhs) {
    return new SExpr('>', lhs, rhs);
}
function SetType(elementType) {
    return new SExpr('Set', elementType);
}
function StringLiteral(str) {
    return stringEscape(str);
}
function Named(name, expr) {
    return new SExpr('!', expr, ':named', name);
}
function CheckSat(name) {
    return new SExpr('check-sat');
}

module.exports = {
    SExpr,
    SetLogic,
    SetOption,
    DeclareSort,
    DeclareDatatype,
    DeclareFun,
    DefineFun,
    Assert,
    Predicate,
    Implies,
    And,
    Or,
    Not,
    Eq,
    NEq,
    LEq,
    GEq,
    LT,
    GT,
    Named,
    SetType,
    StringLiteral,
    CheckSat
};

},{}],42:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":13,"inherits":18,"readable-stream/duplex.js":22,"readable-stream/passthrough.js":33,"readable-stream/readable.js":34,"readable-stream/transform.js":35,"readable-stream/writable.js":36}],43:[function(require,module,exports){
// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2016 The Board of Trustees of the Leland Stanford Junior University
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
//
// See COPYING for details
"use strict";

const Ast = require('./lib/ast');
const Compiler = require('./lib/compiler');
const Grammar = require('./lib/grammar_api');
const ExecEnvironment = require('./lib/exec_environment');
const Type = require('./lib/type');
const SchemaRetriever = require('./lib/schema');
const Generate = require('./lib/generate');
const Describe = require('./lib/describe');
const Formatter = require('./lib/formatter');
const PermissionChecker = require('./lib/permission_checker');
const Units = require('./lib/units');
const NNSyntax = require('./lib/nn_syntax');

let { typeCheckFilter, typeCheckProgram, typeCheckPermissionRule } = require('./lib/typecheck');
Generate.typeCheckFilter = typeCheckFilter;
Generate.typeCheckProgram = typeCheckProgram;
Generate.typeCheckPermissionRule = typeCheckPermissionRule;

const builtin = require('./lib/builtin');

module.exports = {
    // AST definitions
    Ast,
    Type,

    // Syntax support
    Grammar,
    NNSyntax,

    // Compiler and runtime
    Compiler,
    ExecEnvironment,
    Formatter,
    SchemaRetriever,

    // Helper modules to manipulate ASTs
    Generate,
    Describe,

    // Policy support
    PermissionChecker,

    // Misc
    Units,

    // Value Types, exposed so that Thingpedia can reexpose them to device impls
    // (to create values of the appropriate types)
    Location: builtin.Location,
    Entity: builtin.Entity,
    Time: builtin.Time,
    Builtin: builtin,
};
},{"./lib/ast":44,"./lib/builtin":46,"./lib/compiler":48,"./lib/describe":50,"./lib/exec_environment":52,"./lib/formatter":53,"./lib/generate":54,"./lib/grammar_api":56,"./lib/nn_syntax":59,"./lib/permission_checker":61,"./lib/schema":63,"./lib/type":65,"./lib/typecheck":66,"./lib/units":67}],44:[function(require,module,exports){
// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2015-2016 The Board of Trustees of the Leland Stanford Junior University
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
//
// See COPYING for details
"use strict";

const adt = require('adt');
const Type = require('./type');
const { normalizeDate } = require('./date_utils');
const Units = require('./units');

const builtin = require('./builtin_values');

adt.nativeClone = function nativeClone(x) {
    if (x instanceof adt.__Base__)
        return x.clone();
    if (Array.isArray(x))
        return x.map((el) => nativeClone(el));
    if (x instanceof Date)
        return new Date(x);
    if (typeof x === 'object' && x !== null) {
        let clone = {};
        Object.assign(clone, x);
        return clone;
    }
    return x;
};

const Location = adt.data({
    Absolute: {
        lat: adt.only(Number),
        lon: adt.only(Number),
        display: adt.only(String, null)
    },
    Relative: {
        relativeTag: adt.only(String)
    }
});
module.exports.Location = Location.seal();

const DateEdge = adt.newtype('DateEdge', {
    edge: adt.only('start_of', 'end_of'),
    unit: adt.only(String),
});
module.exports.DateEdge = DateEdge;

const Value = adt.data({
    Array: {
        value: adt.only(Array) // of Value
    },

    VarRef: {
        name: adt.only(String),
    },
    Undefined: { // a special placeholder for values that must be slot-filled
        local: adt.only(Boolean),
    },

    Boolean: {
        value: adt.only(Boolean),
    },
    String: {
        value: adt.only(String)
    },
    Measure: {
        value: adt.only(Number),
        unit: adt.only(String)
    },
    CompoundMeasure: { // a list of measures
        value: adt.only(Array) // of Value.Measure
    },
    Number: {
        value: adt.only(Number)
    },
    Currency: {
        value: adt.only(Number),
        code: adt.only(String)
    },
    Location: {
        value: adt.only(Location),
    },
    Date: {
        value: adt.only(Date, DateEdge, null),
        operator: adt.only('+', '-'),
        offset: (x) => { // can't use adt.only here, because of recursive definition
            if (x === null)
                return x;
            if (x instanceof Value.VarRef && x.name.startsWith('__const_'))
                return x;
            if (!(x instanceof Value.CompoundMeasure) && !(x instanceof Value.Measure))
                throw new TypeError('Invalid Date offset ' + x);
            return x;
        }
    },
    Time: {
        hour: adt.only(Number),
        minute: adt.only(Number),
        second: adt.only(Number)
    },
    Entity: {
        value: adt.only(String, null),
        type: adt.only(String),
        display: adt.only(String, null)
    },
    Enum: {
        value: adt.only(String)
    },
    Event: {
        name: adt.only(String, null)
    }
});
module.exports.Value = Value.seal();

function parseTime(v) {
    if (typeof v === 'string') {
        let [hour, minute, second] = v.split(':');
        hour = parseInt(hour);
        minute = parseInt(minute);
        if (second === undefined)
            second = 0;
        else
            second = parseInt(second);
        return new Value.Time(hour, minute, second);
    } else {
        return new Value.Time(v.hour, v.minute, v.second);
    }
}

Value.fromJS = function fromJS(type, v) {
    if (type.isBoolean)
        return Value.Boolean(v);
    if (type.isString)
        return Value.String(v);
    if (type.isNumber)
        return Value.Number(v);
    if (type.isCurrency)
        return typeof v === 'number' ? new Value.Currency(v, 'usd') : new Value.Currency(v.value, v.code);
    if (type.isEntity)
        return new Value.Entity((v.value ? v.value : String(v)), type.type, v.display||null);
    if (type.isMeasure)
        return new Value.Measure(v, type.unit);
    if (type.isEnum)
        return Value.Enum(v);
    if (type.isTime)
        return parseTime(v);
    if (type.isDate)
        return new Value.Date(v, '+', null);
    if (type.isLocation)
        return new Value.Location(Location.Absolute(v.y, v.x, v.display||null));
    throw new TypeError('Invalid type ' + type);
};
Value.fromJSON = function fromJSON(type, v) {
    if (type.isDate) {
        if (v === null)
            return new Value.Date(null, null);
        let date = new Date(v);
        return new Value.Date(date, null);
    } else {
        return Value.fromJS(type, v);
    }
};

Value.prototype.isConcrete = function isConcrete() {
    if (this.isLocation && this.value.isRelative)
        return false;
    if (this.isEntity && !this.display)
        return false;
    if (this.isEntity && this.value === null)
        return false;
    return true;
};
Value.prototype.toJS = function toJS() {
    const v = this;
    if (v.isArray)
        return v.value.map((v) => v.toJS());
    if (v.isVarRef || v.isEvent)
        throw new TypeError("Value is not constant");
    if (v.isUndefined)
        return undefined;
    if (v.isLocation && v.value.isAbsolute)
        return new builtin.Location(v.value.lat, v.value.lon, v.value.display);
    if (v.isLocation)
        throw new TypeError('Location is unknown');
    if (v.isTime)
        return new builtin.Time(v.hour, v.minute);
    if (v.isMeasure)
        return Units.transformToBaseUnit(v.value, v.unit);
    if (v.isCurrency)
        return new builtin.Currency(v.value, v.code);
    if (v.isCompoundMeasure)
        return v.value.reduce(((x, y) => x + y.toJS()), 0);
    if (v.isEntity)
        return new builtin.Entity(v.value, v.display);
    if (v.isDate)
        return normalizeDate(v.value, v.operator, v.offset ? v.offset.toJS() : 0);
    return v.value;
};
Value.prototype.getType = function getType() {
    const v = this;
    if (v.isVarRef || v.isUndefined)
        return Type.Any;
    if (v.isBoolean)
        return Type.Boolean;
    if (v.isString)
        return Type.String;
    if (v.isMeasure)
        return Type.Measure(v.unit);
    if (v.isCompoundMeasure)
        return Type.Measure(v.value[0].unit); // TODO check that all units are compatible
    if (v.isNumber)
        return Type.Number;
    if (v.isCurrency)
        return Type.Currency;
    if (v.isLocation)
        return Type.Location;
    if (v.isDate)
        return Type.Date;
    if (v.isTime)
        return Type.Time;
    if (v.isEntity)
        return Type.Entity(v.type);
    if (v.isArray)
        return Type.Array(v.value.length ? v.value[0].getType() : Type.Any);
    if (v.isFeed)
        return Type.Feed;
    if (v.isEnum)
        return Type.Enum(null);
    if (v.isEvent && v.name === 'type')
        return Type.Entity('tt:function');
    if (v.isEvent && v.name === 'program_id')
        return Type.Entity('tt:program_id');
    if (v.isEvent)
        return Type.String;
    throw new TypeError('Invalid value ' + v);
};

Value.Date.now = function() {
    return new Value.Date(null, '+', null);
};

const Selector = adt.data({
    Device: {
        kind: adt.only(String),
        id: adt.only(String, null),
        principal: adt.only(null),
    },
    Builtin: null
});
module.exports.Selector = Selector.seal();

const Aggregation = adt.newtype('Aggregation', {
    type: adt.only(String), //max, min, argmax, argmin, sum, avg, count
    field: adt.only(String, null),
    cols: adt.only(Array, null),
    count: adt.only(Number, null)
});
module.exports.Aggregation = Aggregation.seal();

const FunctionDef = adt.newtype('FunctionDef', {
    kind_type: adt.only(String),
    args: adt.only(Array),
    types: adt.only(Array),
    index: adt.only(Object),
    inReq: adt.only(Object),
    inOpt: adt.only(Object),
    out: adt.only(Object),
    is_list: adt.only(Boolean),
    is_monitorable: adt.only(Boolean),
    canonical: adt.only(String),
    confirmation: adt.only(String),
    confirmation_remote: adt.only(String),
    argcanonicals: adt.only(Array),
    questions: adt.only(Array)
});
module.exports.FunctionDef = FunctionDef.seal();

const ClassDef = adt.newtype('ClassDef', {
    name: adt.only(String),
    extends: adt.only(String),
    queries: adt.only(Object),
    actions: adt.only(Object)
});
module.exports.ClassDef = ClassDef.seal();

const Invocation = adt.newtype('Invocation', {
    selector: adt.only(Selector),
    channel: adt.only(String),
    in_params: adt.only(Array),
    schema: adt.only(FunctionDef, null),
});
module.exports.Invocation = Invocation.seal();

// TODO
const ScalarExpression = adt.data({
    Primary: {
        value: adt.only(Value)
    },
    Derived: {
        op: adt.only(String),
        operands: adt.only(Array) // of ScalarExpression
    }
});

const BooleanExpression = adt.data(function() {
    return {
        And: {
            operands: adt.only(Array) // of BooleanExpression
        },
        Or: {
            operands: adt.only(Array) // of BooleanExpression
        },
        Atom: {
            name: adt.only(String),
            operator: adt.only(String),
            value: adt.only(Value)
        },
        Not: {
            expr: adt.only(this)
        },
        External: {
            selector: adt.only(Selector.Device),
            channel: adt.only(String),
            in_params: adt.only(Array), // of InputParam,
            filter: adt.only(this),
            schema: adt.only(FunctionDef, null)
        },

        True: null,
        False: null
    };
});
module.exports.ScalarExpression = ScalarExpression.seal();
module.exports.BooleanExpression = BooleanExpression.seal();

const InputParam = adt.newtype('InputParam', {
    name: adt.only(String),
    value: adt.only(Value)
});
module.exports.InputParam = InputParam.seal();

// Stream and Table are mutually recursive
// hence we need to define them in this weird way
var Table = adt.data({
    VarRef: {
        name: adt.only(String),
        in_params: adt.only(Array),
        schema: adt.only(FunctionDef, null),
    },
    Invocation: {
        invocation: adt.only(Invocation),
        schema: adt.only(FunctionDef, null)
    },
});
Table.type('Filter', {
    table: adt.only(Table),
    filter: adt.only(BooleanExpression),
    schema: adt.only(FunctionDef, null)
});
Table.type('Projection', {
    table: adt.only(Table),
    args: adt.only(Array), // of String
    schema: adt.only(FunctionDef, null)
});
Table.type('Compute', {
    table: adt.only(Table),
    expression: adt.only(ScalarExpression),
    alias: adt.only(String, null),
    schema: adt.only(FunctionDef, null)
});
Table.type('Alias', {
    table: adt.only(Table),
    name: adt.only(String),
    schema: adt.only(FunctionDef, null)
});
Table.type('Aggregation', {
    table: adt.only(Table),
    field: adt.only(String),
    operator: adt.only(String),
    alias: adt.only(String, null),
    schema: adt.only(FunctionDef, null)
});
Table.type('ArgMinMax', {
    table: adt.only(Table),
    field: adt.only(String),
    operator: adt.only(String),
    base: adt.only(Value),
    limit: adt.only(Value),
    schema: adt.only(FunctionDef, null)
});
Table.type('Join', {
    lhs: adt.only(Table),
    rhs: adt.only(Table),
    in_params: adt.only(Array),
    schema: adt.only(FunctionDef, null)
});
var Stream = adt.data({
    VarRef: {
        name: adt.only(String),
        in_params: adt.only(Array),
        schema: adt.only(FunctionDef, null),
    },
    Timer: {
        base: adt.only(Value),
        interval: adt.only(Value),
        schema: adt.only(FunctionDef, null)
    },
    AtTimer: {
        time: adt.only(Value),
        schema: adt.only(FunctionDef, null)
    },
    Monitor: {
        table: adt.only(Table),
        args: adt.only(Array, null),
        schema: adt.only(FunctionDef, null),
    }
});
Table.type('Window', {
    base: adt.only(Value), // : Number
    delta: adt.only(Value), // : Number
    stream: adt.only(Stream),
    schema: adt.only(FunctionDef, null)
});
Table.type('TimeSeries', {
    base: adt.only(Value), // : Date
    delta: adt.only(Value), // : Measure(ms)
    stream: adt.only(Stream),
    schema: adt.only(FunctionDef, null)
});
Table.type('Sequence', {
    base: adt.only(Value), // : Number
    delta: adt.only(Value), // : Number
    table: adt.only(Table),
    schema: adt.only(FunctionDef, null)
});
Table.type('History', {
    base: adt.only(Value), // : Date
    delta: adt.only(Value), // : Measure(ms)
    table: adt.only(Table),
    schema: adt.only(FunctionDef, null)
});
Stream.type('EdgeNew', {
    stream: adt.only(Stream),
    schema: adt.only(FunctionDef, null)
});
Stream.type('EdgeFilter', {
    stream: adt.only(Stream),
    filter: adt.only(BooleanExpression),
    schema: adt.only(FunctionDef, null)
});
Stream.type('Filter', {
    stream: adt.only(Stream),
    filter: adt.only(BooleanExpression),
    schema: adt.only(FunctionDef, null)
});
Stream.type('Projection', {
    stream: adt.only(Stream),
    args: adt.only(Array), // of String
    schema: adt.only(FunctionDef, null)
});
Stream.type('Compute', {
    stream: adt.only(Stream),
    expression: adt.only(ScalarExpression),
    alias: adt.only(String, null),
    schema: adt.only(FunctionDef, null)
});
Stream.type('Alias', {
    stream: adt.only(Stream),
    name: adt.only(String),
    schema: adt.only(FunctionDef, null)
});
Stream.type('Join', {
    stream: adt.only(Stream),
    table: adt.only(Table),
    in_params: adt.only(Array),
    schema: adt.only(FunctionDef, null)
});
module.exports.Table = Table.seal();
module.exports.Stream = Stream.seal();

const Statement = adt.data({
    Declaration: {
        name: adt.only(String),
        type: adt.only('stream', 'table', 'action'),
        args: adt.only(Object), // maps name to Type
        value: adt.only(Stream, Table, Invocation)
    },
    Rule: {
        stream: adt.only(Stream),
        actions: adt.only(Array) // of Invocation
    },
    Command: {
        table: adt.only(Table, null),
        actions: adt.only(Array)
    }
});
module.exports.Statement = Statement.seal();

var PermissionFunction = adt.data({
    Specified: {
        kind: adt.only(String),
        channel: adt.only(String),
        filter: adt.only(BooleanExpression),
        schema: adt.only(FunctionDef, null),
    },
    Builtin: null,
    ClassStar: {
        kind: adt.only(String)
    },
    Star: null
});
module.exports.PermissionFunction = PermissionFunction.seal();

const Input = adt.data({
    Program: {
        classes: adt.only(Array), // of ClassDef
        declarations: adt.only(Array), // of Statement.Declaration
        rules: adt.only(Array), // of Statement.Rule or Statement.Command
        principal: adt.only(Value, null) // either Entity(tt:username) or Entity(tt:contact)
    },
    'PermissionRule': {
        principal: adt.only(BooleanExpression),
        query: adt.only(PermissionFunction),
        action: adt.only(PermissionFunction)
    }
});
module.exports.Input = Input.seal();
module.exports.Program = Input.Program;
module.exports.PermissionRule = Input.PermissionRule;
},{"./builtin_values":47,"./date_utils":49,"./type":65,"./units":67,"adt":7}],45:[function(require,module,exports){
// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2015-2018 The Board of Trustees of the Leland Stanford Junior University
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
//
// See COPYING for details
"use strict";

const assert = require('assert');

const Ast = require('./ast');
const Type = require('./type');
const Builtin = require('./builtin');
const { prettyprint } = require('./prettyprint');

const { makeIndex,
        isUnaryStreamToStreamOp,
        isUnaryTableToTableOp,
        isUnaryStreamToTableOp,
        isUnaryTableToStreamOp } = require('./utils');
const { optimizeFilter, optimizeProgram } = require('./optimize');
let { typeCheckFilter, typeCheckProgram, typeCheckPermissionRule } = require('./typecheck');

const ProgramProto = Object.getPrototypeOf(new Ast.Program([], [], [], null));
const PermissionRuleProto = Object.getPrototypeOf(new Ast.PermissionRule(Ast.BooleanExpression.True, Ast.PermissionFunction.Builtin, Ast.PermissionFunction.Builtin));
const InvocationProto = Object.getPrototypeOf(new Ast.Invocation(Ast.Selector.Builtin, 'notify', [], null));
const DeclarationProto = Object.getPrototypeOf(new Ast.Statement.Declaration('', 'action', {},
    new Ast.Invocation(Ast.Selector.Builtin, 'notify', [], null)));

// utilities

function notifyAction(what = 'notify') {
    return new Ast.Invocation(Ast.Selector.Builtin, what, [], Builtin.Actions.notify);
}
module.exports.notifyAction = notifyAction;

DeclarationProto.toProgram = function toProgram() {
    const nametoslot = {};

    let i = 0;
    for (let name in this.args)
        nametoslot[name] = i++;

    let program;
    if (this.type === 'action')
        program = new Ast.Program([], [], [new Ast.Statement.Command(null, [this.value.clone()])], null);
    else if (this.type === 'table')
        program = new Ast.Program([], [], [new Ast.Statement.Command(this.value.clone(), [notifyAction()])], null);
    else
        program = new Ast.Program([], [], [new Ast.Statement.Rule(this.value.clone(), [notifyAction()])], null);

    for (let [, slot] of program.iterateSlots()) {
        if (slot instanceof Ast.Selector)
            continue;
        if (slot.value.isVarRef && slot.value.name in nametoslot)
            slot.value.name = '__const_SLOT_' + nametoslot[slot.value.name];
    }

    return program;
};

// *** typechecking API ***

Ast.BooleanExpression.prototype.typecheck = function(schema, scope, schemas, classes, useMeta) {
    return typeCheckFilter(this, schema, scope, schemas, classes, useMeta);
};

Ast.Input.prototype.typecheck = function(schemas, getMeta = false) {
    if (this.isProgram)
        return typeCheckProgram(this, schemas, getMeta).then(() => this);
    else
        return typeCheckPermissionRule(this, schemas, getMeta).then(() => this);
};

// *** prettyprinting API ***

Ast.Input.prototype.prettyprint = function(short) {
    return prettyprint(this, short);
};

// *** optimization API ***

Ast.BooleanExpression.prototype.optimize = function() {
    return optimizeFilter(this);
};
ProgramProto.optimize = function() {
    return optimizeProgram(this);
};

function isRemoteReceive(fn) {
    return (fn.selector.isDevice && fn.selector.kind === 'org.thingpedia.builtin.thingengine.remote' || fn.selector.kind.startsWith('__dyn_')) &&
        fn.channel === 'receive';
}
function isRemoteSend(fn) {
    return (fn.selector.isDevice && fn.selector.kind === 'org.thingpedia.builtin.thingengine.remote' || fn.selector.kind.startsWith('__dyn_')) &&
        fn.channel === 'send';
}

function convertPrimitiveToPermission(prim) {
    if (prim === null || prim.selector.isBuiltin || isRemoteSend(prim) || isRemoteReceive(prim))
        return Ast.PermissionFunction.Builtin;

    let filter = [];
    for (let inParam of prim.in_params) {
        if (inParam.value.isUndefined)
            continue;
        filter.push(Ast.BooleanExpression.Atom(inParam.name, '==', inParam.value));
    }
    filter = Ast.BooleanExpression.And(filter);
    return new Ast.PermissionFunction.Specified(prim.selector.kind, prim.channel, filter, prim.schema);
}

function convertTableToPermissionFunction(table) {
    if (table.isInvocation)
        return convertPrimitiveToPermission(table.invocation);

    if (table.isFilter) {
        let inner = convertTableToPermissionFunction(table.table);
        if (!inner)
            return inner;
        return new Ast.PermissionFunction.Specified(inner.kind, inner.channel,
            Ast.BooleanExpression.And([inner.filter, table.filter]), inner.schema);
    }

    if (table.isProjection || table.isAlias || table.isCompute)
        return convertTableToPermissionFunction(table.table);

    if (table.isJoin) {
        console.log('NOT IMPLEMENTED: cannot support more than one permission primitive');
        return null;
    }

    console.log(`NOT IMPLEMENTED: converting table ${table} to permission function`);
    return null;
}

function convertStreamToPermissionFunction(stream) {
    if (stream.isMonitor)
        return convertTableToPermissionFunction(stream.table);
    if (stream.isProjection || stream.isAlias || stream.isCompute)
        return convertStreamToPermissionFunction(stream.stream);

    if (stream.isFilter || stream.isEdgeFilter) {
        let inner = convertStreamToPermissionFunction(stream.stream);
        if (!inner)
            return inner;
        return new Ast.PermissionFunction.Specified(inner.kind, inner.channel,
            Ast.BooleanExpression.And([inner.filter, stream.filter]), inner.schema);
    }

    if (stream.isJoin) {
        console.log('NOT IMPLEMENTED: cannot support more than one permission primitive');
        return null;
    }

    console.log(`NOT IMPLEMENTED: converting stream ${stream} to permission function`);
    return null;
}

ProgramProto.convertToPermissionRule = function(principal, contactName) {
    let rule;
    if (this.rules.length > 1) {
        console.log('NOT IMPLEMENTED: cannot support more than one rule');
        return null;
    }
    rule = this.rules[0];

    let query = null;
    if (rule.stream)
        query = convertStreamToPermissionFunction(rule.stream);
    else if (rule.table)
        query = convertTableToPermissionFunction(rule.table);
    else
        query = Ast.PermissionFunction.Builtin;
    if (rule.actions.length > 1) {
        console.log('NOT IMPLEMENTED: cannot support more than one action');
        return null;
    }
    const action = convertPrimitiveToPermission(rule.actions[0]);
    if (query.isSpecified)
        query.filter = optimizeFilter(query.filter);
    if (action.isSpecified)
        action.filter = optimizeFilter(action.filter);

    return new Ast.PermissionRule(Ast.BooleanExpression.Atom(
        'source', '==',
        Ast.Value.Entity(principal, 'tt:contact', contactName)
    ), query, action);
};

// *** slot iteration ***

InvocationProto.iterateSlots = function* iterateSlotsInputParams(scope) {
    yield [null, this.selector, this, null];
    for (let in_param of this.in_params)
        yield [this.schema, in_param, this, scope];
    return [this, makeScope(this)];
};

Ast.BooleanExpression.prototype.iterateSlots = function* iterateSlotsFilter(schema, prim, scope) {
    if (this.isTrue || this.isFalse)
        return;
    if (this.isAnd || this.isOr) {
        for (let op of this.operands)
            yield* op.iterateSlots(schema, prim, scope);
        return;
    }
    if (this.isNot) {
        yield* this.expr.iterateSlots(schema, prim, scope);
        return;
    }
    if (this.isExternal) {
        yield* InvocationProto.iterateSlots.call(this, scope);
        yield* this.filter.iterateSlots(this.schema, prim, makeScope(this));
    } else {
        yield [schema, this, prim, scope];
    }
};

Ast.Table.prototype.iterateSlots = function* iterateSlotsTable(scope) {
    if (this.isVarRef) {
        // this will be handled when we visit the declaration
        return [null, {}];
    } else if (this.isInvocation) {
        return yield* this.invocation.iterateSlots(scope);
    } else if (this.isFilter) {
        let [prim, newScope] = yield* this.table.iterateSlots(scope);
        yield* this.filter.iterateSlots(this.table.schema, prim, newScope);
        return [prim, newScope];
    } else if (this.isProjection) {
        let [prim, nestedScope] = yield* this.table.iterateSlots(scope);
        let newScope = {};
        for (let name of this.args)
            newScope[name] = nestedScope[name];
        return [prim, newScope];
    } else if (isUnaryTableToTableOp(this)) {
        return yield* this.table.iterateSlots(scope);
    } else if (isUnaryStreamToTableOp(this)) {
        return yield* this.stream.iterateSlots(scope);
    } else if (this.isJoin) {
        let [, leftScope] = yield* this.lhs.iterateSlots(scope);
        let [, rightScope] = yield* this.rhs.iterateSlots(scope);
        let newScope = {};
        Object.assign(newScope, leftScope, rightScope);
        return [null, newScope];
    } else {
        throw new TypeError("Can't handle " + this);
    }
};

function makeScope(invocation) {
    // make out parameters available in the "scope", which puts
    // them as possible options for a later slot fill
    const schema = invocation.schema;
    const scope = {};
    for (let argname in schema.out) {
        let index = schema.index[argname];
        let argcanonical = schema.argcanonicals[index] || argname;
        scope[argname] = {
            value: Ast.Value.VarRef(argname),
            type: schema.out[argname],
            argcanonical: argcanonical,
            kind: invocation.selector.kind
        };
    }
    scope['$event'] = {
        value: Ast.Value.Event(null),
        type: Type.String,
    };
    return scope;
}

Ast.Stream.prototype.iterateSlots = function* iterateSlotsStream(scope) {
    if (this.isVarRef) {
        // this will be handled when we visit the declaration
        return [null, {}];
    } else if (this.isTimer || this.isAtTimer) {
        // no primitive here
        return [null, {}];
    } else if (this.isFilter || this.isEdgeFilter) {
        let [prim, newScope] = yield* this.stream.iterateSlots(scope);
        yield* this.filter.iterateSlots(this.stream.schema, prim, newScope);
        return [prim, newScope];
    } else if (this.isProjection) {
        let [prim, nestedScope] = yield* this.stream.iterateSlots(scope);
        let newScope = {};
        for (let name of this.args)
            newScope[name] = nestedScope[name];
        return [prim, newScope];
    } else if (isUnaryStreamToStreamOp(this)) {
        return yield* this.stream.iterateSlots(scope);
    } else if (isUnaryTableToStreamOp(this)) {
        return yield* this.table.iterateSlots(scope);
    } else if (this.isJoin) {
        let [, leftScope] = yield* this.stream.iterateSlots(scope);
        let [, rightScope] = yield* this.table.iterateSlots(scope);
        let newScope = {};
        Object.assign(newScope, leftScope, rightScope);
        return [null, newScope];
    } else {
        throw new TypeError("Can't handle " + this);
    }
};

ProgramProto.iterateSlots = function* iterateSlots() {
    let scope = {};
    for (let decl of this.declarations)
        yield* decl.value.iterateSlots(scope);
    for (let rule of this.rules) {
        if (rule.isRule)
            [,scope] = yield* rule.stream.iterateSlots(scope);
        else if (rule.isCommand && rule.table)
            [,scope] = yield* rule.table.iterateSlots(scope);
        for (let action of rule.actions)
            yield* action.iterateSlots(scope);
    }
};

PermissionRuleProto.iterateSlots = function* iterateSlots() {
    yield* this.principal.iterateSlots(null, null, {});

    if (this.query.isSpecified)
        yield* this.query.filter.iterateSlots(this.query.schema, this.query, {});
    if (this.action.isSpecified)
        yield* this.action.filter.iterateSlots(this.action.schema, this.action, this.query.isSpecified ? this.query.schema.out : {});
};

// *** primitive iteration ***

ProgramProto.iteratePrimitives = function* iteratePrimitives() {
    for (let decl of this.declarations)
        yield* decl.iteratePrimitives();
    for (let rule of this.rules)
        yield* rule.iteratePrimitives();
};

Ast.Statement.prototype.iteratePrimitives = function* iteratePrimitivesRule() {
    if (this.isDeclaration) {
        switch (this.type) {
        case 'table':
        case 'stream':
            yield* this.value.iteratePrimitives();
            break;
        case 'action':
            yield ['action', this.value];
        }
    } else {
        if (this.isRule)
            yield* this.stream.iteratePrimitives();
        else if (this.isCommand && this.table)
            yield* this.table.iteratePrimitives();
        yield* this.actions.map((a) => ['action', a]);
    }
};

Ast.Stream.prototype.iteratePrimitives = function* iteratePrimitivesStream() {
    if (this.isVarRef) {
        // this will be handled when we visit the declaration
    } else if (this.isTimer || this.isAtTimer) {
        // no primitive here
    } else if (this.isFilter || this.isEdgeFilter) {
        yield* this.stream.iteratePrimitives();
        yield* this.filter.iteratePrimitives();
    } else if (isUnaryStreamToStreamOp(this)) {
        yield* this.stream.iteratePrimitives();
    } else if (isUnaryTableToStreamOp(this)) {
        yield* this.table.iteratePrimitives();
    } else if (this.isJoin) {
        yield* this.stream.iteratePrimitives();
        yield* this.table.iteratePrimitives();
    } else {
        throw new TypeError("Can't handle " + this);
    }
};

Ast.Table.prototype.iteratePrimitives = function* iteratePrimitivesTable() {
    if (this.isVarRef) {
        // this will be handled when we visit the declaration
    } else if (this.isInvocation) {
        yield ['table', this.invocation];
    } else if (this.isFilter) {
        yield* this.table.iteratePrimitives();
        yield* this.filter.iteratePrimitives();
    } else if (isUnaryTableToTableOp(this)) {
        yield* this.table.iteratePrimitives();
    } else if (isUnaryStreamToTableOp(this)) {
        yield* this.stream.iteratePrimitives();
    } else if (this.isJoin) {
        yield* this.lhs.iteratePrimitives();
        yield* this.rhs.iteratePrimitives();
    } else {
        throw new TypeError("Can't handle " + this);
    }
};

Ast.BooleanExpression.prototype.iteratePrimitives = function* iteratePrimitivesFilter() {
    if (this.isTrue || this.isTrue || this.isAtom)
        return;
    if (this.isNot) {
        yield* this.expr.iteratePrimitives();
        return;
    }
    if (this.isAnd || this.isOr) {
        for (let op of this.operands)
            yield* op.iteratePrimitives();
        return;
    }

    assert(this.isExternal);
    yield ['filter', this];
    yield* this.filter.iteratePrimitives();
};


// *** lowering API ***

function makeToken(state) {
    return state.token++;
}

function getSelf(messaging) {
    return Ast.Value.Entity(messaging.type + '-account:' + messaging.account, 'tt:contact', "me");
}

function makeSendSchema(sendFrom, secondSendFrom) {
    const args = ['__principal', '__program_id', '__flow', '__kindChannel'];
    const types = [Type.Entity('tt:contact'), Type.Entity('tt:program_id'), Type.Number, Type.Entity('tt:function')];
    const inReq = {
        __principal: Type.Entity('tt:contact'),
        __program_id: Type.Entity('tt:program_id'),
        __flow: Type.Number,
        __kindChannel: Type.Entity('tt:function')
    };
    for (let argname in sendFrom.schema.out) {
        args.push(argname);
        let type = sendFrom.schema.out[argname];
        types.push(type);
        inReq[argname] = type;
    }
    if (secondSendFrom) {
        for (let argname in secondSendFrom.schema.out) {
            args.push(argname);
            let type = secondSendFrom.schema.out[argname];
            types.push(type);
            inReq[argname] = type;
        }
    }
    return new Ast.FunctionDef('other',
        args, types, makeIndex(args),
        inReq, {}, {},
        false, // is_list
        false, // is_monitorable
        '', // canonical
        '', // confirmation
        '', // confirmation_remote
        [], // argcanonicals
        [] // questions
    );
}
function makeReceiveSchema(receiveFrom, secondReceiveFrom) {
    let args = ['__principal', '__program_id', '__flow', '__kindChannel'];
    let types = [Type.Entity('tt:contact'), Type.Entity('tt:program_id'), Type.Number, Type.Entity('tt:function')];
    let inReq = {
        __principal: Type.Entity('tt:contact'),
        __program_id: Type.Entity('tt:program_id'),
        __flow: Type.Number,
    };
    let out = {
        __kindChannel: Type.Entity('tt:function'),
    };
    for (let argname in receiveFrom.schema.out) {
        args.push(argname);
        let type = receiveFrom.schema.out[argname];
        types.push(type);
        out[argname] = type;
    }
    if (secondReceiveFrom) {
        for (let argname in secondReceiveFrom.schema.out) {
            args.push(argname);
            let type = secondReceiveFrom.schema.out[argname];
            types.push(type);
            out[argname] = type;
        }
    }

    return new Ast.FunctionDef('other',
        args, types, makeIndex(args),
        inReq, {}, out,
        true, // is_list
        true, // is_monitorable
        '', // canonical
        '', // confirmation
        '', // confirmation_remote
        [], // argcanonicals
        [] // questions
    );
}

function makeDynamicClass(classes, sendSchema, receiveSchema) {
    var classdef = Ast.ClassDef('__dyn_' + classes.length, 'org.thingpedia.builtin.thingengine.remote',
        {}, {});
    if (sendSchema)
        classdef.actions.send = sendSchema;
    if (receiveSchema)
        classdef.queries.receive = receiveSchema;
    classes.push(classdef);
    return classdef;
}

// note: this is similar to factorRemoteAction, but self/remote are flipped
// the "lowered" action is what will be shipped out as a blob, whereas ourrules is what
// we need to run locally to receive the results
//
// because we don't mess with queries, we never need to split something in more than one piece
// which drastically simplifies the implementation
function lowerReturnAction(state, action, lastPrimitive, principal) {
    if (!action.selector.isBuiltin || action.channel !== 'return')
        return;
    if (principal === null || lastPrimitive === null) {
        action.channel = 'notify';
        return;
    }
    assert(lastPrimitive !== null);

    let token = makeToken(state);
    let sendSchema = makeSendSchema(lastPrimitive);
    let receiveSchema = makeReceiveSchema(lastPrimitive);
    let localClass = makeDynamicClass(state.newclasses, sendSchema, null);
    let toSendClass = makeDynamicClass([], null, receiveSchema);

    let sendInputs = [
        Ast.InputParam('__principal', getSelf(state.messaging)),
        Ast.InputParam('__program_id', Ast.Value.Event('program_id')),
        Ast.InputParam('__flow',  Ast.Value.Number(token)),
        Ast.InputParam('__kindChannel', Ast.Value.Event('type'))
    ];
    for (let name in lastPrimitive.schema.out)
        sendInputs.push(Ast.InputParam(name, Ast.Value.VarRef(name)));
    action.selector = Ast.Selector.Device(localClass.name, null, null);
    action.channel = 'send';
    action.in_params = sendInputs;
    action.schema = sendSchema;

    let receiveInputs = [
        Ast.InputParam('__principal', principal),
        Ast.InputParam('__program_id', Ast.Value.Event('program_id')),
        Ast.InputParam('__flow',  Ast.Value.Number(token))
    ];
    let receiveTrigger = new Ast.Stream.Monitor(
        new Ast.Table.Invocation(
            new Ast.Invocation(Ast.Selector.Device(toSendClass.name, null, null), 'receive', receiveInputs, receiveSchema),
        receiveSchema),
    null, receiveSchema);

    var ourrule = new Ast.Program([toSendClass], [], [
        Ast.Statement.Rule(receiveTrigger, [notifyAction()])
    ], null);
    state.ourrules.push(ourrule);
}

function lowerReturnRule(state, rule, principal) {
    const lastPrimitive = rule.isRule ? rule.stream : rule.table;

    rule.actions.forEach((action) => {
        lowerReturnAction(state, action, lastPrimitive, principal);
    });
}

ProgramProto.lowerReturn = function(messaging) {
    let ourrules = [];
    let state = { token: 0, messaging, ourrules, newclasses: this.classes };
    this.rules.forEach((r) => {
        lowerReturnRule(state, r, this.principal);
    });
    return ourrules;
};
},{"./ast":44,"./builtin":46,"./optimize":60,"./prettyprint":62,"./type":65,"./typecheck":66,"./utils":68,"assert":8}],46:[function(require,module,exports){
// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2015-2016 The Board of Trustees of the Leland Stanford Junior University
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
//
// See COPYING for details
"use strict";

const assert = require('assert');

const Type = require('./type');
const Ast = require('./ast');
const AsyncQueue = require('consumer-queue');
const Utils = require('./utils');

// we split the module so that AST can also load it, because
// we need Ast to define function def at the end of the file
module.exports = require('./builtin_values');
const Location = module.exports.Location;
const Entity = module.exports.Entity;
const Time = module.exports.Time;
const Currency = module.exports.Currency;
const ExampleProgram = module.exports.ExampleProgram;

function arrayEquals(a, b) {
    if (a.length !== b.length)
        return false;

    for (var i = 0; i < a.length; i++) {
        if (!equalityTest(a[i], b[i]))
            return false;
    }

    return true;
}

function isLocation(obj) {
    return (obj instanceof Location || (obj.hasOwnProperty('x') && obj.hasOwnProperty('y')));
}
function isEntity(obj) {
    return obj instanceof Entity || typeof obj === 'string';
}

function distance(a, b) {
    const R = 6371000; // meters
    var lat1 = a.y;
    var lat2 = b.y;
    var lon1 = a.x;
    var lon2 = a.x;
    function toRadians(deg) { return deg * Math.PI / 180.0; }

    // formula courtesy of http://www.movable-type.co.uk/scripts/latlong.html
    var φ1 = toRadians(lat1);
    var φ2 = toRadians(lat2);
    var Δφ = toRadians(lat2-lat1);
    var Δλ = toRadians(lon2-lon1);

    var x = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
            Math.cos(φ1) * Math.cos(φ2) *
            Math.sin(Δλ/2) * Math.sin(Δλ/2);
    var c = 2 * Math.atan2(Math.sqrt(x), Math.sqrt(1-x));

    return R * c;
}
function locationEquals(a, b) {
    if (a === b)
        return true;
    if (a.x === b.x && a.y === b.y)
        return true;
    //console.log('Comparing locations', [a,b]);
    var d = distance(a, b);
    //console.log('Distance (m): ' + d.toFixed(2));
    return d <= 100;
}

function hasValueOf(x) {
    return typeof x === 'number' || x instanceof Date || x instanceof Time;
}

function equalityTest(a, b) {
    if (a === b)
        return true;
    if (a === null || b === null) // they can't be both null because a !== b
        return false;
    if (a === undefined || b === undefined)
        return false;
    if (hasValueOf(a) && hasValueOf(b))
        return +a === +b;
    if (a instanceof Currency && b instanceof Currency)
        return a.value === b.value && a.code.toLowerCase() === b.code.toLowerCase();
    if (a instanceof Currency && typeof b === 'number')
        return +a === +b;
    if (b instanceof Currency && typeof a === 'number')
        return +a === +b;
    if (a.feedId !== undefined)
        return a.feedId === b.feedId;
    if (isLocation(a) && isLocation(b))
        return locationEquals(a, b);
    if (isEntity(a) && isEntity(b))
        return String(a) === String(b);
    if (a instanceof ExampleProgram && b instanceof ExampleProgram)
        return a.id === b.id;
    if (Array.isArray(a) && Array.isArray(b))
        return arrayEquals(a, b);

    return false;
}
module.exports.equality = equalityTest;

function likeTest(a, b) {
    if (typeof a === 'string' && typeof b === 'string')
        return a.toLowerCase().indexOf(b.toLowerCase()) >= 0;
    return false;
}
module.exports.like = likeTest;

function startsWith(a, b) {
    if (typeof a === 'string' && typeof b === 'string')
        return a.toLowerCase().startsWith(b.toLowerCase());
    return false;
}
module.exports.startsWith = startsWith;

function endsWith(a, b) {
    if (typeof a === 'string' && typeof b === 'string')
        return a.toLowerCase().endsWith(b.toLowerCase());
    return false;
}
module.exports.endsWith = endsWith;

function contains(a, b) {
    return a.some((x) => equalityTest(x, b));
}
module.exports.contains = contains;

function tupleEquals(a, b, keys) {
    for (let key of keys) {
        if (!equalityTest(a[key], b[key]))
            return false;
    }
    return true;
}

function isNewTuple(state, tuple, keys) {
    if (state === null)
        return true;

    let tlast, tprevious;
    for (let i = state.length-1; i >= 0; i--) {
        if (tlast === undefined)
            tlast = state[i].__timestamp;
        else if (tprevious === undefined && state[i].__timestamp < tlast)
            tprevious = state[i].__timestamp;
        else if (state[i].__timestamp < tprevious)
            break;
    }
    if (tuple.__timestamp === tlast)
        tlast = tprevious;
    if (tlast === undefined)
        return true;

    for (let i = 0; i < state.length; i++) {
        if (state[i].__timestamp !== tlast)
            continue;
        if (tupleEquals(state[i], tuple, keys))
            return false;
    }
    return true;
}
module.exports.isNewTuple = isNewTuple;

function addTuple(state, tuple) {
    if (state === null)
        return [tuple];
    state.push(tuple);

    // trim the state to
    let tlast, tprevious;
    let i;
    for (i = state.length-1; i >= 0; i--) {
        if (tlast === undefined)
            tlast = state[i].__timestamp;
        else if (tprevious === undefined && state[i].__timestamp < tlast)
            tprevious = state[i].__timestamp;
        else if (state[i].__timestamp < tprevious)
            break;
    }
    if (i >= 0) {
        assert(state[i].__timestamp < tprevious);
        state = state.slice(i+1);
    }

    return state;
}
module.exports.addTuple = addTuple;

class IteratorAdapter {
    constructor(queue) {
        this._queue = queue;
    }

    next() {
        return this._queue.pop();
    }
}

function streamUnion(lhs, rhs) {
    let queue = new AsyncQueue();

    let currentLeft = null;
    let currentRight = null;
    let doneLeft = false;
    let doneRight = false;
    function emit() {
        if (currentLeft === null || currentRight === null)
            return;
        let [leftType, leftValue] = currentLeft;
        let [rightType, rightValue] = currentRight;
        let newValue = {};
        Object.assign(newValue, leftValue);
        Object.assign(newValue, rightValue);
        let newType = combineOutputTypes(leftType, rightType);
        queue.push({ value: [newType, newValue], done: false });
    }
    function checkDone() {
        if (doneLeft && doneRight)
            queue.push({ done: true });
    }

    Utils.generatorToAsync(lhs)((v) => {
        currentLeft = v;
        emit();
    }).then(() => {
        doneLeft = true;
        checkDone();
    }).catch((err) => queue.cancelWait(err));

    Utils.generatorToAsync(rhs)((v) => {
        currentRight = v;
        emit();
    }).then(() => {
        doneRight = true;
        checkDone();
    }).catch((err) => queue.cancelWait(err));

    return new IteratorAdapter(queue);
}
module.exports.streamUnion = streamUnion;

function accumulateStream(stream) {
    let into = [];

    return Utils.generatorToAsync(stream)((v) => {
        into.push(v);
    }).then(() => into);
}

class DelayedIterator {
    constructor(promise) {
        this._promise = promise;
        this._iterator = null;
    }

    next() {
        if (this._iterator !== null)
            return Promise.resolve(this._iterator.next());
        return this._promise.then((iterator) => {
            this._iterator = iterator;
            return this._iterator.next();
        });
    }
}

function tableCrossJoin(lhs, rhs) {
    return new DelayedIterator(Promise.all([
        accumulateStream(lhs),
        accumulateStream(rhs)
    ]).then(([left, right]) => {
        return (function*() {
            for (let l of left) {
                for (let r of right) {
                    let [leftType, leftValue] = l;
                    let [rightType, rightValue] = r;
                    let newValue = {};
                    Object.assign(newValue, leftValue);
                    Object.assign(newValue, rightValue);
                    let newType = combineOutputTypes(leftType, rightType);
                    yield [newType, newValue];
                }
            }
        })();
    }));
}
module.exports.tableCrossJoin = tableCrossJoin;

function combineOutputTypes(t1, t2) {
    return `${t1}+${t2}`;
}
module.exports.combineOutputTypes = combineOutputTypes;

module.exports.BinaryOps = {
    '>': {
        types: [[Type.String, Type.String, Type.Boolean],
                [Type.Measure(''), Type.Measure(''), Type.Boolean],
                [Type.Number, Type.Number, Type.Boolean],
                [Type.Date, Type.Date, Type.Boolean],
                [Type.Time, Type.Time, Type.Boolean],
                [Type.Currency, Type.Currency, Type.Boolean]],
        op: '>'
    },
    '<': {
        types: [[Type.String, Type.String, Type.Boolean],
                [Type.Measure(''), Type.Measure(''), Type.Boolean],
                [Type.Number, Type.Number, Type.Boolean],
                [Type.Date, Type.Date, Type.Boolean],
                [Type.Time, Type.Time, Type.Boolean],
                [Type.Currency, Type.Currency, Type.Boolean]],
        op: '<'
    },
    '>=': {
        types: [[Type.String, Type.String, Type.Boolean],
                [Type.Measure(''), Type.Measure(''), Type.Boolean],
                [Type.Number, Type.Number, Type.Boolean],
                [Type.Date, Type.Date, Type.Boolean],
                [Type.Time, Type.Time, Type.Boolean],
                [Type.Currency, Type.Currency, Type.Boolean]],
        op: '>='
    },
    '<=': {
        types: [[Type.String, Type.String, Type.Boolean],
                [Type.Measure(''), Type.Measure(''), Type.Boolean],
                [Type.Number, Type.Number, Type.Boolean],
                [Type.Date, Type.Date, Type.Boolean],
                [Type.Time, Type.Time, Type.Boolean],
                [Type.Currency, Type.Currency, Type.Boolean]],
        op: '<='
    },
    '==': {
        types: [['a', 'a', Type.Boolean]],
        fn: 'equality',
    },
    '=~': {
        types: [[Type.String, Type.String, Type.Boolean]],
        fn: 'like'
    },
    '~=': {
        types: [[Type.String, Type.String, Type.Boolean]],
        fn: 'like',
        flip: true
    },
    starts_with: {
        types: [[Type.String, Type.String, Type.Boolean]],
        fn: 'startsWith',
    },
    ends_with: {
        types: [[Type.String, Type.String, Type.Boolean]],
        fn: 'endsWith',
    },
    prefix_of: {
        types: [[Type.String, Type.String, Type.Boolean]],
        fn: 'startsWith',
        flip: true
    },
    suffix_of: {
        types: [[Type.String, Type.String, Type.Boolean]],
        fn: 'endsWith',
        flip: true
    },
    'contains': {
        types: [[Type.Array('a'), 'a', Type.Boolean]],
        fn: 'contains',
    },
    'in_array': {
        types: [['a', Type.Array('a'), Type.Boolean]],
        fn: 'contains',
        flip: true
    },
    'has_member': {
        types: [[Type.Entity('tt:contact_group'), Type.Entity('tt:contact'), Type.Boolean]],
    },
    'group_member': {
        types: [[Type.Entity('tt:contact'), Type.Entity('tt:contact_group'), Type.Boolean]],
    }
};

function getTime(d) {
    return new Time(d.getHours(), d.getMinutes(), d.getSeconds());
}
module.exports.getTime = getTime;

module.exports.UnaryOps = {
    '!': {
        types: [[Type.Boolean, Type.Boolean]],
        op: '!'
    },
    'get_time': {
        types: [[Type.Date, Type.Time]],
        fn: 'getTime'
    }
};

module.exports.ScalarExpressionOps = {
    '+': {
        types: [[Type.String, Type.String, Type.String],
                [Type.Number, Type.Number, Type.Number],
                [Type.Currency, Type.Currency, Type.Currency],
                [Type.Measure(''), Type.Measure(''), Type.Measure('')],
                [Type.Date, Type.Measure('ms'), Type.Date],
                [Type.Time, Type.Measure('ms'), Type.Time],
                [Type.Measure('ms'), Type.Date, Type.Date],
                [Type.Measure('ms'), Type.Time, Type.Time]],
        op: '+'
    },
    '-': {
        types: [[Type.Number, Type.Number, Type.Number],
                [Type.Currency, Type.Currency, Type.Currency],
                [Type.Measure(''), Type.Measure(''), Type.Measure('')],
                [Type.Date, Type.Measure('ms'), Type.Date],
                [Type.Time, Type.Measure('ms'), Type.Time]],
        op: '-'
    },
    '*': {
        types: [[Type.Number, Type.Number, Type.Number],
                [Type.Currency, Type.Number, Type.Currency],
                [Type.Measure(''), Type.Number, Type.Measure('')]],
        op: '*'
    },
    '/': {
        types: [[Type.Number, Type.Number, Type.Number],
                [Type.Currency, Type.Number, Type.Currency],
                [Type.Measure(''), Type.Number, Type.Measure('')]],
        op: '/'
    },
    '%': {
        types: [[Type.Number, Type.Number, Type.Number]],
        op: '%'
    },
    '**': {
        types: [[Type.Number, Type.Number, Type.Number]],
        op: '**'
    },
    'distance': {
        types: [[Type.Location, Type.Location, Type.Measure('m')]],
        op: '~'
    }
};

module.exports.Aggregations = {
    'max': {
        types: [[Type.Number, Type.Number],
                [Type.Currency, Type.Currency],
                [Type.Measure(''), Type.Measure('')]]
    },
    'min': {
        types: [[Type.Number, Type.Number],
                [Type.Currency, Type.Currency],
                [Type.Measure(''), Type.Measure('')]]
    },
    'sum': {
        types: [[Type.Number, Type.Number],
                [Type.Currency, Type.Currency],
                [Type.Measure(''), Type.Measure('')]]
    },
    'avg': {
        types: [[Type.Number, Type.Number],
                [Type.Currency, Type.Currency],
                [Type.Measure(''), Type.Measure('')]]
    },
    'count': {
        types: [[Type.Any, Type.Number]]
    }
};

module.exports.ArgMinMax = {
    'argmax': {
        types: [Type.Number, Type.Measure(''), Type.Currency]
    },
    'argmin': {
        types: [Type.Number, Type.Measure(''), Type.Currency]
    }
};

const builtinFunction = new Ast.FunctionDef(
    'builtin',
    [], // args
    [], // types
    {}, // index
    {}, // inReq
    {}, // inOpt
    {}, // out
    false, // is_list,
    false, // is_monitorable
    '', // canonical
    '', // confirmation
    '', // confirmation_remote,
    [], // argcanonicals,
    [] // questions
);

module.exports.emptyFunction = builtinFunction;
module.exports.Triggers = {
};
module.exports.Actions = {
    'notify': builtinFunction,
    'return': builtinFunction,
    'save': builtinFunction,
};
module.exports.Queries = {
};

},{"./ast":44,"./builtin_values":47,"./type":65,"./utils":68,"assert":8,"consumer-queue":15}],47:[function(require,module,exports){
// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2017 The Board of Trustees of the Leland Stanford Junior University
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
//
// See COPYING for details
"use strict";

const { stringEscape } = require('./escaping');

class ExampleProgram {
    constructor(ex) {
        this.id = ex.id;
        this.utterance = ex.utterance;
        this.target_code = ex.target_code;
    }

    toString() {
        return this.utterance;
    }
}
module.exports.ExampleProgram = ExampleProgram;

class Entity {
    constructor(id, display) {
        this.value = id;
        this.display = display||null;
    }

    toString() {
        return this.value;
    }

    toJSSource() {
        return `new __builtin.Entity(${stringEscape(this.value)}, ${stringEscape(this.display)})`;
    }
}
module.exports.Entity = Entity;

class Location {
    constructor(lat, lon, display) {
        if (typeof lat !== 'number' || typeof lon !== 'number')
            throw new Error(`Invalid location (${lat}, ${lon})`);
        this.x = lon;
        this.y = lat;
        this.display = display||null;
    }

    toString() {
        if (this.display !== null)
            return this.display;
        else
            return '[Latitude: ' + Number(this.y).toFixed(5) + ' deg, Longitude: ' + Number(this.x).toFixed(5) + ' deg]';
    }

    toJSSource() {
        return `new __builtin.Location(${this.y}, ${this.x}, ${stringEscape(this.display)})`;
    }
}
module.exports.Location = Location;

class Time {
    constructor(hour, minute, second = 0) {
        if (!(hour >= 0) || !(minute >= 0) || !(second >= 0))
            throw new Error(`Invalid time ${hour}:${minute}:${second}`);
        this.hour = hour;
        this.minute = minute;
        this.second = second;
    }

    // for comparisons
    valueOf() {
        return this.hour * 3600 + this.minute * 60 + this.second;
    }

    toString() {
        if (this.second === 0)
            return `${this.hour}:${this.minute < 10 ? '0' : ''}${this.minute}`;
        else
            return `${this.hour}:${this.minute < 10 ? '0' : ''}${this.minute}:${this.second < 10 ? '0' : ''}${this.second}`;
    }

    toJSON() {
        return this.toString();
    }

    toJSSource() {
        return `new __builtin.Time(${this.hour}, ${this.minute}, ${this.second})`;
    }
}
module.exports.Time = Time;

class Currency {
    constructor(value, code) {
        this.value = value;
        this.code = code;
    }
    
    valueOf() {
        return this.value;
    }
    
    toString() {
        return `${this.value} ${this.code.toUpperCase()}`;
    }

    toLocaleString(locale, options = {}) {
        options.style = 'currency';
        options.currency = this.code.toUpperCase();
        return this.value.toLocaleString(locale, options);
    }
    
    toJSSource() {
        return `new __builtin.Currency(${this.value}, "${this.code}")`;
    }
}
module.exports.Currency = Currency;

class Aggregation {
    constructor(type, field, cols, count) {
        this.type = type;
        this.field = field;
        this.cols = cols;
        this.count = count;
    }
}
module.exports.Aggregation = Aggregation;

},{"./escaping":51}],48:[function(require,module,exports){
// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2015-2016 The Board of Trustees of the Leland Stanford Junior University
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
//
// See COPYING for details
"use strict";

const assert = require('assert');
const adt = require('adt');

const Ast = require('./ast');
const Grammar = require('./grammar');
const Type = require('./type');
const JSIr = require('./jsir');
const Builtin = require('./builtin');
const { typeCheckProgram } = require('./typecheck');

function compileEvent(irBuilder, varScope, name) {
    let reg;
    if (name === 'type') {
        return varScope.$outputType;
    } else if (name === 'program_id') {
        reg = irBuilder.allocRegister();
        irBuilder.add(new JSIr.GetEnvironment('program_id', reg));
    } else {
        let hint = name ? 'string-' + name : 'string';
        reg = irBuilder.allocRegister();
        irBuilder.add(new JSIr.FormatEvent(hint, varScope.$outputType, varScope.$output, reg));
    }
    return reg;
}

function typeForValue(ast, scope) {
    if (ast.isVarRef)
        return scope[ast.name];
    else
        return ast.getType();
}

function compileValue(irBuilder, ast, varScope) {
    if (ast.isUndefined)
        throw new Error('Invalid undefined value, should have been slot-filled');
    if (ast.isEvent)
        return compileEvent(irBuilder, varScope, ast.name);
    if (ast.isVarRef)
        return varScope[ast.name];

    let reg = irBuilder.allocRegister();
    irBuilder.add(new JSIr.LoadConstant(ast, reg));
    return reg;
}

function compileBinaryOp(irBuilder, op, lhs, rhs, into) {
    let binaryOp = Builtin.BinaryOps[op];
    if (binaryOp.op)
        irBuilder.add(new JSIr.BinaryOp(lhs, rhs, binaryOp.op, into));
    else if (binaryOp.flip)
        irBuilder.add(new JSIr.BinaryFunctionOp(rhs, lhs, binaryOp.fn, into));
    else
        irBuilder.add(new JSIr.BinaryFunctionOp(lhs, rhs, binaryOp.fn, into));
}

function compileUnaryOp(irBuilder, op, arg, into) {
    let unaryOp = Builtin.UnaryOps[op];
    if (unaryOp.op)
        irBuilder.add(new JSIr.UnaryOp(arg, unaryOp.op, into));
    else
        irBuilder.add(new JSIr.UnaryOp(arg, '__builtin.' + unaryOp.fn, into));
}

function compileCast(irBuilder, reg, type, toType) {
    if (type.equals(toType)) {
        if (type.isEntity && (type.type === 'tt:hashtag' || type.type === 'tt:username' || type.type === 'tt:picture_url')) {
            // for compatibility with the ton of devices that take inputs of these types, we auto-cast to string,
            // this is ok because these types don't really need .display that much
            let casted = irBuilder.allocRegister();
            irBuilder.add(new JSIr.UnaryOp(reg, 'String', casted));
            return casted;
        }
        return reg;
    }

    if (toType.isString) {
        let casted = irBuilder.allocRegister();
        irBuilder.add(new JSIr.UnaryOp(reg, 'String', casted));
        return casted;
    }

    if (type.isDate && toType.isTime) {
        let casted = irBuilder.allocRegister();
        compileUnaryOp(irBuilder, 'get_time', reg, casted);
        return casted;
    }

    return reg;
}

class Invocation {
    constructor(selector, channel, type) {
        this.selector = selector;
        this.channel = channel;
        this.type = type;
    }
}

function isRemoteSend(fn) {
    return (fn.selector.kind === 'org.thingpedia.builtin.thingengine.remote' || fn.selector.kind.startsWith('__dyn_')) &&
        fn.channel === 'send';
}

class NotImplementedError extends Error {
    constructor(construct) {
        super('NOT IMPLEMENTED: ' + construct);
    }
}

// Low-level ThingTalk operations
// Each ThingTalk AST node can be implemented in terms of these low-level ops
// Each of these ops can be compiled into JS code individually

// PointWiseOp : operates on each produced tuple
const PointWiseOp = adt.data({
    Projection: { args: adt.only(Array) },
    Compute: { expression: adt.only(Ast.ScalarExpression) }
});

// StreamOp : operates on streams
const StreamOp = adt.data(function() {
    return {
        Now: null,
        InvokeSubscribe: {
            invocation: adt.only(Ast.Invocation),
            filter: adt.only(Ast.BooleanExpression)
        },
        Timer: {
            base: adt.only(Ast.Value),
            interval: adt.only(Ast.Value),
        },
        AtTimer: {
            time: adt.only(Ast.Value),
        },
        Filter: {
            stream: adt.only(this),
            filter: adt.only(Ast.BooleanExpression)
        },
        Map: {
            stream: adt.only(this),
            op: adt.only(PointWiseOp)
        },
        EdgeNew: {
            stream: adt.only(this)
        },
        EdgeFilter: {
            stream: adt.only(this),
            filter: adt.only(Ast.BooleanExpression),
        },
        Union: {
            lhs: adt.only(this),
            rhs: adt.only(this)
        },
    };
});

// TableOp : operates on in-memory table
const TableOp = adt.data(function() {
    return {
        InvokeGet: {
            invocation: adt.only(Ast.Invocation),
            extra_in_params: adt.only(Array), // coming from a join
            filter: adt.only(Ast.BooleanExpression)
        },

        Filter: {
            table: adt.only(this),
            filter: adt.only(Ast.BooleanExpression)
        },
        Map: {
            table: adt.only(this),
            op: adt.only(PointWiseOp)
        },

        CrossJoin: {
            lhs: adt.only(this),
            rhs: adt.only(this)
        },
        NestedLoopJoin: {
            lhs: adt.only(this),
            rhs: adt.only(this),
        }
    };
});

StreamOp.type('Join', {
    // when the stream fires, get the whole table and join it
    stream: adt.only(StreamOp),
    table: adt.only(TableOp)
});

// The overall structure of the rule
// this reflects the overall "when => get* => do" structure of ThingTalk
// which is what it optimizes for
const RuleOp = adt.newtype('RuleOp', {
    stream: adt.only(StreamOp, null),
    actions: adt.only(Array)
});

// compile a table that is being monitored to a stream
function compileMonitorTableToOps(table) {
    if (table.isVarRef ||
        table.isAggregation ||
        table.isArgMinMax ||
        table.isWindow ||
        table.isTimeSeries ||
        table.isHistory ||
        table.isSequence ||
        table.isAlias)
        throw new NotImplementedError(table);

    if (table.isInvocation) {
        // subscribe is optimistic, we still need EdgeNew
        return new StreamOp.EdgeNew(new StreamOp.InvokeSubscribe(table.invocation, Ast.BooleanExpression.True));
    } else if (table.isFilter) {
        return new StreamOp.Filter(
            compileMonitorTableToOps(table.table),
            table.filter);
    } else if (table.isProjection) {
        // note the "edge new" operation here, because
        // the projection might cause fewer values to
        // be new
        return new StreamOp.EdgeNew(
            new StreamOp.Map(
                compileMonitorTableToOps(table.table),
                new PointWiseOp.Projection(table.args)
            ));
    } else if (table.isCompute) {
        // note the "edge new" operation here, because
        // the projection might cause fewer values to
        // be new
        return new StreamOp.EdgeNew(
            new StreamOp.Map(
                compileMonitorTableToOps(table.table),
                new PointWiseOp.Compute(table.expression)
            ));
    } else if (table.isJoin) {
        if (table.in_params.length === 0) {
            // if there is no parameter passing, we can individually monitor
            // the two tables and return the union

            return new StreamOp.EdgeNew(new StreamOp.Union(
                compileMonitorTableToOps(table.lhs),
                compileMonitorTableToOps(table.rhs)));
        } else {
            // otherwise we need to subscribe to the left hand side, and
            // every time it fires, create/update a subscription to the
            // right hand side
            // this is VERY MESSY
            // so it's not implemented
            throw new NotImplementedError(table);
        }
    } else {
        throw new TypeError();
    }
}

// compile a TT stream to a stream op and zero or more
// tableops
function compileStreamToOps(stream) {
    if (stream.isVarRef || stream.isAlias)
        throw new NotImplementedError(stream);

    if (stream.isTimer) {
        return new StreamOp.Timer(stream.base, stream.interval);
    } else if (stream.isAtTimer) {
        return new StreamOp.AtTimer(stream.time);
    } else if (stream.isMonitor) {
        return compileMonitorTableToOps(stream.table);
    } else if (stream.isEdgeNew) {
        return new StreamOp.EdgeNew(
            compileStreamToOps(stream.stream));
    } else if (stream.isEdgeFilter) {
        return new StreamOp.EdgeFilter(
            compileStreamToOps(stream.stream),
            stream.filter);
    } else if (stream.isFilter) {
        return new StreamOp.Filter(
            compileStreamToOps(stream.stream),
            stream.filter);
    } else if (stream.isProjection) {
        return new StreamOp.Map(
            compileStreamToOps(stream.stream),
            new PointWiseOp.Projection(stream.args)
        );
    } else if (stream.isCompute) {
        return new StreamOp.Map(
            compileStreamToOps(stream.stream),
            new PointWiseOp.Compute(stream.expression)
        );
    } else if (stream.isJoin) {
        return new StreamOp.Join(
            compileStreamToOps(stream.stream),
            compileTableToOps(stream.table, stream.in_params)
        );
    } else {
        throw new TypeError();
    }
}

function compileTableToOps(table, extra_in_params) {
    if (table.isVarRef ||
        table.isAggregation ||
        table.isArgMinMax ||
        table.isWindow ||
        table.isTimeSeries ||
        table.isHistory ||
        table.isSequence ||
        table.isAlias)
        throw new NotImplementedError(table);

    if (table.isInvocation) {
        return new TableOp.InvokeGet(table.invocation, extra_in_params, Ast.BooleanExpression.True);
    } else if (table.isFilter) {
        return new TableOp.Filter(
            compileTableToOps(table.table, extra_in_params),
            table.filter
        );
    } else if (table.isProjection) {
        return new TableOp.Map(
            compileTableToOps(table.table, extra_in_params),
            new PointWiseOp.Projection(table.args)
        );
    } else if (table.isCompute) {
        return new TableOp.Map(
            compileTableToOps(table.table, extra_in_params),
            new PointWiseOp.Compute(table.expression)
        );
    } else if (table.isJoin) {
        if (table.in_params.length === 0) {
            return new TableOp.CrossJoin(
                compileTableToOps(table.lhs, extra_in_params),
                compileTableToOps(table.rhs, extra_in_params)
            );
        } else {
            let lhs_in_params = [];
            let rhs_in_params = [];
            for (let in_param of extra_in_params) {
                if (in_param.name in table.lhs.schema.inReq ||
                    in_param.name in table.lhs.schema.inOpt)
                    lhs_in_params.push(in_param);
                if (in_param.name in table.rhs.schema.inReq ||
                    in_param.name in table.rhs.schema.inOpt)
                    rhs_in_params.push(in_param);
            }

            return new TableOp.NestedLoopJoin(
                compileTableToOps(table.lhs, lhs_in_params),
                compileTableToOps(table.rhs, rhs_in_params.concat(table.in_params))
            );
        }
    } else {
        throw new TypeError();
    }
}

function optimizeStreamOp(streamop) {
    return streamop;
}
/*function optimizeTableOp(tableop) {
    return tableop;
}*/

function optimizeLoop(what, optimizer) {
    let optimized = optimizer(what);
    if (optimized !== what)
        return optimizeLoop(optimized, optimizer);
    else
        return optimized;
}

// compile a rule/command statement to a RuleOp
function compileStatementToOp(statement) {
    let streamop = null;
    if (statement.isRule) {
        streamop = compileStreamToOps(statement.stream);
    } else if (statement.table) {
        let tableop = compileTableToOps(statement.table, []);
        streamop = new StreamOp.Join(StreamOp.Now, tableop);
    }
    streamop = optimizeLoop(streamop, optimizeStreamOp);

    return new RuleOp(streamop, statement.actions);
}

class CompiledRule {
    constructor(hasTrigger, functions, states, code) {
        this.hasTrigger = hasTrigger;
        this.functions = functions;
        this.states = states;
        this.code = code;
    }
}

class RuleCompiler {
    constructor(compiler, rule, testMode) {
        this._testMode = testMode;
        this._compiler = compiler;
        this._rule = rule;
        this._irBuilder = new JSIr.IRBuilder();

        this._functions = [];
        this._nextFunction = 0;

        this._currentStateId = null;
        this._nextStateVar = 0;

        this._typeScope = {};
        this._varScope = {};
        this._varScopeNames = [];
        this._versions = {};
        this._retryLoopLabel = undefined;
    }

    _allocFunction(ast, type) {
        let id = this._nextFunction++;

        if (!ast.__effectiveSelector) {
            // __effectiveSelector is used to turn dynamically declared classes for @remote
            // into just @remote
            console.error('WARNING: TypeCheck must set __effectiveSelector');
            ast.__effectiveSelector = ast.selector;
        }
        this._functions[id] = new Invocation(ast.__effectiveSelector, ast.channel, type);
        return id;
    }

    _allocState() {
        return this._nextStateVar++;
    }

    _compileOneInputParam(args, ast, inParam) {
        let reg = compileValue(this._irBuilder, inParam.value, this._varScope);
        let ptype = ast.schema.inReq[inParam.name] || ast.schema.inOpt[inParam.name];
        reg = compileCast(this._irBuilder, reg, typeForValue(inParam.value, this._typeScope), ptype);
        this._irBuilder.add(new JSIr.SetKey(args, inParam.name, reg));
        return reg;
    }

    _compileInputParams(ast, extra_in_params = []) {
        let args = this._irBuilder.allocRegister();
        this._irBuilder.add(new JSIr.CreateObject(args));

        let argmap = {};
        for (let inParam of ast.in_params)
            argmap[inParam.name] = this._compileOneInputParam(args, ast, inParam);
        for (let inParam of extra_in_params)
            argmap[inParam.name] = this._compileOneInputParam(args, ast, inParam);
        return [argmap, args];
    }

    _compileAggregation(ast) {
        if (ast.aggregation) {
            let agg = this._irBuilder.allocRegister();
            this._irBuilder.add(new JSIr.CreateAggregation(ast.aggregation, agg));
            return agg;
        }
        return null;
    }

    _compileIterateQuery(list) {
        let iterator = this._irBuilder.allocRegister();
        this._irBuilder.add(new JSIr.Iterator(iterator, list));

        let deviceAndResult = this._irBuilder.allocRegister();
        let loop = new JSIr.AsyncWhileLoop(deviceAndResult, iterator);
        this._irBuilder.add(loop);
        this._irBuilder.pushBlock(loop.body);

        return deviceAndResult;
    }

    _compileFilter(ast, varScope, typeScope) {
        return (function recursiveHelper(expr) {
            let cond = this._irBuilder.allocRegister();
            if (expr.isTrue) {
                this._irBuilder.add(new JSIr.LoadConstant(Ast.Value.Boolean(true), cond));
            } else if (expr.isFalse) {
                this._irBuilder.add(new JSIr.LoadConstant(Ast.Value.Boolean(false), cond));
            } else if (expr.isAnd) {
                this._irBuilder.add(new JSIr.LoadConstant(Ast.Value.Boolean(true), cond));
                for (let op of expr.operands) {
                    let opv = recursiveHelper.call(this, op);
                    this._irBuilder.add(new JSIr.BinaryOp(cond, opv, '&&', cond));
                }
            } else if (expr.isOr) {
                this._irBuilder.add(new JSIr.LoadConstant(Ast.Value.Boolean(false), cond));
                for (let op of expr.operands) {
                    let opv = recursiveHelper.call(this, op);
                    this._irBuilder.add(new JSIr.BinaryOp(cond, opv, '||', cond));
                }
            } else if (expr.isNot) {
                const op = recursiveHelper.call(this, expr.expr);
                this._irBuilder.add(new JSIr.UnaryOp(op, '!', cond));
            } else if (expr.isExternal) {
                this._irBuilder.add(new JSIr.LoadConstant(Ast.Value.Boolean(false), cond));

                let tryCatch = new JSIr.TryCatch("Failed to invoke get-predicate query");
                this._irBuilder.add(tryCatch);
                this._irBuilder.pushBlock(tryCatch.try);

                assert(expr.selector.isDevice);
                let fnid = this._allocFunction(ast, 'query');
                let list = this._irBuilder.allocRegister();
                let [argmap, args] = this._compileInputParams(expr);
                this._irBuilder.add(new JSIr.InvokeQuery(fnid, list, args));

                let typeAndResult = this._compileIterateQuery(list);
                let [, result] = this._readTypeResult(typeAndResult);

                let nestedTypeScope = {};
                let nestedVarScope = {};
                for (let name in argmap) {
                    nestedTypeScope[name] = expr.schema.inReq[name] || expr.schema.inOpt[name];
                    nestedVarScope[name] = argmap[name];
                }
                for (let outParam in expr.schema.out) {
                    let reg = this._irBuilder.allocRegister();
                    this._irBuilder.add(new JSIr.GetKey(result, outParam, reg));
                    nestedTypeScope[outParam] = expr.schema.out[outParam];
                    nestedVarScope[outParam] = reg;
                }
                let ok = this._compileFilter(expr.filter, nestedVarScope, nestedTypeScope);
                let ifStmt = new JSIr.IfStatement(ok);
                this._irBuilder.add(ifStmt);
                this._irBuilder.pushBlock(ifStmt.iftrue);
                this._irBuilder.add(new JSIr.LoadConstant(Ast.Value.Boolean(true), cond));
                this._irBuilder.add(new JSIr.Break());
                this._irBuilder.popBlock();

                this._irBuilder.popBlock(); // for-of
                this._irBuilder.popBlock(); // try-catch
            } else {
                let op = expr.operator;
                let lhsType = typeScope[expr.name];
                let lhs = varScope[expr.name];
                lhs = compileCast(this._irBuilder, lhs, lhsType, expr.overload[0]);
                let rhs = compileValue(this._irBuilder, expr.value, varScope);
                rhs = compileCast(this._irBuilder, rhs, typeForValue(expr.value, typeScope), expr.overload[1]);
                compileBinaryOp(this._irBuilder, op, lhs, rhs, cond);
                cond = compileCast(this._irBuilder, cond, expr.overload[2], Type.Boolean);
            }
            return cond;
        }).call(this, ast);
    }

    _setInvocationOutputs(invocation, argmap, typeAndResult) {
        let [outputType, result] = this._readTypeResult(typeAndResult);

        this._typeScope = {};
        this._varScope = {};
        this._varScopeNames = [];
        this._varScope.$outputType = outputType;
        this._varScope.$output = result;

        for (let arg in argmap) {
            this._typeScope[arg] = invocation.schema.inReq[arg] || invocation.schema.inOpt[arg];
            this._varScope[arg] = argmap[arg];
            this._varScopeNames.push(arg);
        }
        for (let outParam in invocation.schema.inOpt) {
            if (outParam in argmap)
                continue;
            let reg = this._irBuilder.allocRegister();
            this._irBuilder.add(new JSIr.GetKey(result, outParam, reg));
            this._typeScope[outParam] = invocation.schema.inOpt[outParam];
            this._varScope[outParam] = reg;
            this._varScopeNames.push(outParam);
        }

        for (let outParam in invocation.schema.out) {
            let reg = this._irBuilder.allocRegister();
            this._irBuilder.add(new JSIr.GetKey(result, outParam, reg));
            this._typeScope[outParam] = invocation.schema.out[outParam];
            this._varScope[outParam] = reg;
            this._varScopeNames.push(outParam);
        }
    }

    _compileInvokeSubscribe(streamop) {
        let tryCatch = new JSIr.TryCatch("Failed to invoke trigger");
        this._irBuilder.add(tryCatch);
        this._irBuilder.pushBlock(tryCatch.try);

        let fnid = this._allocFunction(streamop.invocation, 'trigger');
        let [argmap, argmapreg] = this._compileInputParams(streamop.invocation);

        let iterator = this._irBuilder.allocRegister();
        this._irBuilder.add(new JSIr.InvokeMonitor(fnid, iterator, argmapreg, false));

        let result = this._irBuilder.allocRegister();
        let loop = new JSIr.AsyncWhileLoop(result, iterator);
        this._irBuilder.add(loop);
        this._irBuilder.pushBlock(loop.body);

        this._setInvocationOutputs(streamop.invocation, argmap, result);
    }

    _compileTimer(streamop) {
        let tryCatch = new JSIr.TryCatch("Failed to invoke timer");
        this._irBuilder.add(tryCatch);
        this._irBuilder.pushBlock(tryCatch.try);

        let iterator = this._irBuilder.allocRegister();
        let base = compileValue(this._irBuilder, streamop.base, this._varScope);
        let interval = compileValue(this._irBuilder, streamop.interval, this._varScope);

        this._irBuilder.add(new JSIr.InvokeTimer(iterator, base, interval));

        let result = this._irBuilder.allocRegister();
        let loop = new JSIr.AsyncWhileLoop(result, iterator);
        this._irBuilder.add(loop);
        this._irBuilder.pushBlock(loop.body);

        this._typeScope = {};
        this._varScope = {};
        this._varScope.$outputType = null;
        this._varScope.$output = result;
    }

    _compileAtTimer(ast) {
        let tryCatch = new JSIr.TryCatch("Failed to invoke at-timer");
        this._irBuilder.add(tryCatch);
        this._irBuilder.pushBlock(tryCatch.try);

        let iterator = this._irBuilder.allocRegister();
        let time = compileValue(this._irBuilder, ast.time, this._varScope);

        this._irBuilder.add(new JSIr.InvokeAtTimer(iterator, time));

        let result = this._irBuilder.allocRegister();
        let loop = new JSIr.AsyncWhileLoop(result, iterator);
        this._irBuilder.add(loop);
        this._irBuilder.pushBlock(loop.body);

        this._typeScope = {};
        this._varScope = {};
        this._varScope.$outputType = null;
        this._varScope.$output = result;
    }

    _compileInvokeGet(tableop) {
        let tryCatch = new JSIr.TryCatch("Failed to invoke query");
        this._irBuilder.add(tryCatch);
        this._irBuilder.pushBlock(tryCatch.try);

        let fnid = this._allocFunction(tableop.invocation, 'query');
        let [argmap, argmapreg] = this._compileInputParams(tableop.invocation, tableop.extra_in_params);
        let list = this._irBuilder.allocRegister();
        this._irBuilder.add(new JSIr.InvokeQuery(fnid, list, argmapreg));

        let result = this._compileIterateQuery(list);
        this._setInvocationOutputs(tableop.invocation, argmap, result);
    }

    _compileAction(ast) {
        let tryCatch = new JSIr.TryCatch("Failed to invoke action");
        this._irBuilder.add(tryCatch);
        this._irBuilder.pushBlock(tryCatch.try);

        if (ast.selector.isBuiltin) {
            if (ast.channel === 'return')
                throw new TypeError('return must be lowered before execution, use Generate.lowerReturn');
            assert(ast.channel === 'notify');

            this._irBuilder.add(new JSIr.InvokeOutput(this._varScope.$outputType, this._varScope.$output));
        } else {
            let fnid = this._allocFunction(ast, 'action');
            let [,args] = this._compileInputParams(ast);
            this._irBuilder.add(new JSIr.InvokeAction(fnid, args));
        }

        this._irBuilder.popBlock();
    }

    _compileStreamFilter(streamop) {
        this._compileStream(streamop.stream);

        let filter = this._compileFilter(streamop.filter, this._varScope,
            this._typeScope);

        let ifStmt = new JSIr.IfStatement(filter);
        this._irBuilder.add(ifStmt);
        this._irBuilder.pushBlock(ifStmt.iftrue);
    }

    _compileTableFilter(tableop) {
        this._compileTable(tableop.table);

        let filter = this._compileFilter(tableop.filter, this._varScope,
            this._typeScope);

        let ifStmt = new JSIr.IfStatement(filter);
        this._irBuilder.add(ifStmt);
        this._irBuilder.pushBlock(ifStmt.iftrue);
    }

    _compileProjection(proj) {
        let newTypeScope = {};
        let newVarScope = {};

        for (let name of proj.args) {
            newTypeScope[name] = this._typeScope[name];
            newVarScope[name] = this._varScope[name];
        }

        newVarScope.$outputType = this._varScope.$outputType;
        newVarScope.$output = this._varScope.$output;

        this._typeScope = newTypeScope;
        this._varScope = newVarScope;
        this._varScopeNames = proj.args;
    }

    _compileCompute(compute) {
        throw new NotImplementedError(compute);
    }

    _compileStreamMap(streamop) {
        this._compileStream(streamop.stream);

        if (streamop.op.isProjection)
            this._compileProjection(streamop.op);
        else if (streamop.op.isCompute)
            this._compileCompute(streamop.op);
        else
            throw new TypeError();
    }

    _compileTableMap(tableop) {
        this._compileTable(tableop.table);

        if (tableop.op.isProjection)
            this._compileProjection(tableop.op);
        else if (tableop.op.isCompute)
            this._compileCompute(tableop.op);
        else
            throw new TypeError();
    }

    _compileStreamEdgeNew(streamop) {
        let state = this._irBuilder.allocRegister();
        let stateId = this._allocState();

        this._irBuilder.add(new JSIr.InvokeReadState(state, stateId));

        this._compileStream(streamop.stream);

        let isNewTuple = this._irBuilder.allocRegister();
        this._irBuilder.add(new JSIr.CheckIsNewTuple(isNewTuple, state, this._varScope.$output,
                            this._varScopeNames));

        let newState = this._irBuilder.allocRegister();
        this._irBuilder.add(new JSIr.AddTupleToState(newState, state, this._varScope.$output));

        this._irBuilder.add(new JSIr.InvokeWriteState(newState, stateId));
        this._irBuilder.add(new JSIr.Copy(newState, state));

        let ifStmt = new JSIr.IfStatement(isNewTuple);
        this._irBuilder.add(ifStmt);
        this._irBuilder.pushBlock(ifStmt.iftrue);
    }

    _compileStreamEdgeFilter(streamop) {
        let stateId = this._allocState();

        this._compileStream(streamop.stream);

        let state = this._irBuilder.allocRegister();
        this._irBuilder.add(new JSIr.InvokeReadState(state, stateId));

        let filter = this._compileFilter(streamop.filter, this._varScope,
            this._typeScope);

        // only write the new state if different from the old one (to avoid
        // repeated writes)
        let different = this._irBuilder.allocRegister();
        this._irBuilder.add(new JSIr.BinaryOp(filter, state, '!==', different));
        let ifDifferent = new JSIr.IfStatement(different);
        this._irBuilder.add(ifDifferent);
        this._irBuilder.pushBlock(ifDifferent.iftrue);
        this._irBuilder.add(new JSIr.InvokeWriteState(filter, stateId));
        this._irBuilder.popBlock();

        // negate the state, then and it to the filter to compute whether the rule
        // should fire or not
        this._irBuilder.add(new JSIr.UnaryOp(state, '!', state));
        this._irBuilder.add(new JSIr.BinaryOp(filter, state, '&&', filter));

        let ifStmt = new JSIr.IfStatement(filter);
        this._irBuilder.add(ifStmt);
        this._irBuilder.pushBlock(ifStmt.iftrue);
    }

    _readTypeResult(typeAndResult) {
        let outputType, result;
        outputType = this._irBuilder.allocRegister();
        result = this._irBuilder.allocRegister();

        this._irBuilder.add(new JSIr.GetIndex(typeAndResult, 0, outputType));
        this._irBuilder.add(new JSIr.GetIndex(typeAndResult, 1, result));

        return [outputType, result];
    }

    _mergeResults(lhsVarScope, rhsVarScope) {
        let newOutputType;
        if (lhsVarScope.$outputType !== null && rhsVarScope.$outputType !== null) {
            newOutputType = this._irBuilder.allocRegister();
            this._irBuilder.add(new JSIr.BinaryFunctionOp(lhsVarScope.$outputType, rhsVarScope.$outputType, 'combineOutputTypes', newOutputType));
        } else if (lhsVarScope.$outputType !== null) {
            newOutputType = lhsVarScope.$outputType;
        } else if (rhsVarScope.$outputType !== null) {
            newOutputType = rhsVarScope.$outputType;
        } else {
            newOutputType = null;
        }

        let newResult = this._irBuilder.allocRegister();
        this._irBuilder.add(new JSIr.CreateObject(newResult));

        for (let outParam in rhsVarScope) {
            if (outParam.startsWith('$'))
                continue;
            this._irBuilder.add(new JSIr.SetKey(newResult, outParam, rhsVarScope[outParam]));
        }
        for (let outParam in lhsVarScope) {
            if (outParam.startsWith('$') || rhsVarScope[outParam])
                continue;
            this._irBuilder.add(new JSIr.SetKey(newResult, outParam, lhsVarScope[outParam]));
        }

        return [newOutputType, newResult];
    }

    _mergeScopes(lhsTypeScope, rhsTypeScope, outputType, result) {
        this._typeScope = {};
        this._varScope = {};
        this._varScopeNames = [];
        this._varScope.$outputType = outputType;
        this._varScope.$output = result;

        for (let outParam in rhsTypeScope) {
            this._typeScope[outParam] = rhsTypeScope[outParam];
            let reg = this._irBuilder.allocRegister();
            this._irBuilder.add(new JSIr.GetKey(result, outParam, reg));
            this._varScope[outParam] = reg;
            this._varScopeNames.push(outParam);
        }
        for (let outParam in lhsTypeScope) {
            if (this._typeScope[outParam])
                continue;
            this._typeScope[outParam] = lhsTypeScope[outParam];
            let reg = this._irBuilder.allocRegister();
            this._irBuilder.add(new JSIr.GetKey(result, outParam, reg));
            this._varScope[outParam] = reg;
            this._varScopeNames.push(outParam);
        }
    }

    _compileStreamUnion(streamop) {
        // compile the two streams to two generator expressions, and then pass
        // them to a builtin which will to the right thing

        let lhs = this._irBuilder.allocRegister();
        let lhsbody = new JSIr.GeneratorExpression(lhs);
        this._irBuilder.add(lhsbody);
        let upto = this._irBuilder.pushBlock(lhsbody.body);

        this._compileStream(streamop.lhs);
        this._irBuilder.add(new JSIr.InvokeEmit(this._varScope.$output));

        let lhsTypeScope = this._typeScope;
        this._irBuilder.popTo(upto);

        let rhs = this._irBuilder.allocRegister();
        let rhsbody = new JSIr.GeneratorExpression(rhs);

        this._irBuilder.add(rhsbody);
        upto = this._irBuilder.pushBlock(rhsbody.body);

        this._compileStream(streamop.rhs);
        this._irBuilder.add(new JSIr.InvokeEmit(this._varScope.$output));

        let rhsTypeScope = this._typeScope;
        this._irBuilder.popTo(upto);

        let iterator = this._irBuilder.allocRegister();
        this._irBuilder.add(new JSIr.BinaryFunctionOp(lhs, rhs, 'streamUnion', iterator));

        let typeAndResult = this._irBuilder.allocRegister();
        let loop = new JSIr.AsyncWhileLoop(typeAndResult, iterator);
        this._irBuilder.add(loop);
        this._irBuilder.pushBlock(loop.body);

        let [outputType, result] = this._readTypeResult(typeAndResult);
        this._mergeScopes(lhsTypeScope, rhsTypeScope, outputType, result);
    }

    _compileStreamJoin(streamop) {
        if (streamop.stream.isNow) {
            this._compileTable(streamop.table);
            return;
        }

        this._compileStream(streamop.stream);

        let streamVarScope = this._varScope;
        let streamTypeScope = this._typeScope;

        this._compileTable(streamop.table);

        let tableVarScope = this._varScope;
        let tableTypeScope = this._typeScope;

        let [outputType, result] = this._mergeResults(streamVarScope, tableVarScope);
        this._mergeScopes(streamTypeScope, tableTypeScope, outputType, result);
    }

    _compileStream(streamop) {
        if (streamop.isNow)
            return;

        if (streamop.isInvokeSubscribe)
            this._compileInvokeSubscribe(streamop);
        else if (streamop.isTimer)
            this._compileTimer(streamop);
        else if (streamop.isAtTimer)
            this._compileAtTimer(streamop);
        else if (streamop.isFilter)
            this._compileStreamFilter(streamop);
        else if (streamop.isMap)
            this._compileStreamMap(streamop);
        else if (streamop.isEdgeNew)
            this._compileStreamEdgeNew(streamop);
        else if (streamop.isEdgeFilter)
            this._compileStreamEdgeFilter(streamop);
        else if (streamop.isUnion)
            this._compileStreamUnion(streamop);
        else if (streamop.isJoin)
            this._compileStreamJoin(streamop);
        else
            throw new TypeError();
    }

    _compileTableCrossJoin(tableop) {
        // compile the two tables to two generator expressions, and then pass
        // them to a builtin which will compute the cross join

        let lhs = this._irBuilder.allocRegister();
        let lhsbody = new JSIr.GeneratorExpression(lhs);
        this._irBuilder.add(lhsbody);
        let upto = this._irBuilder.pushBlock(lhsbody.body);

        this._compileTable(tableop.lhs);
        this._irBuilder.add(new JSIr.InvokeEmit(this._varScope.$output));

        let lhsTypeScope = this._typeScope;
        this._irBuilder.popTo(upto);

        let rhs = this._irBuilder.allocRegister();
        let rhsbody = new JSIr.GeneratorExpression(rhs);

        this._irBuilder.add(rhsbody);
        upto = this._irBuilder.pushBlock(rhsbody.body);

        this._compileTable(tableop.rhs);
        this._irBuilder.add(new JSIr.InvokeEmit(this._varScope.$output));

        let rhsTypeScope = this._typeScope;
        this._irBuilder.popTo(upto);

        let iterator = this._irBuilder.allocRegister();
        this._irBuilder.add(new JSIr.BinaryFunctionOp(lhs, rhs, 'tableCrossJoin', iterator));

        let typeAndResult = this._irBuilder.allocRegister();
        let loop = new JSIr.AsyncWhileLoop(typeAndResult, iterator);
        this._irBuilder.add(loop);
        this._irBuilder.pushBlock(loop.body);

        let [outputType, result] = this._readTypeResult(typeAndResult);
        this._mergeScopes(lhsTypeScope, rhsTypeScope, outputType, result);
    }

    _compileTableNestedLoopJoin(tableop) {
        this._compileTable(tableop.lhs);

        let lhsVarScope = this._varScope;
        let lhsTypeScope = this._typeScope;

        this._compileTable(tableop.rhs);

        let rhsVarScope = this._varScope;
        let rhsTypeScope = this._typeScope;

        let [outputType, result] = this._mergeResults(lhsVarScope, rhsVarScope);
        this._mergeScopes(lhsTypeScope, rhsTypeScope, outputType, result);
    }

    _compileTable(tableop) {
        if (tableop.isInvokeGet)
            this._compileInvokeGet(tableop);
        else if (tableop.isFilter)
            this._compileTableFilter(tableop);
        else if (tableop.isMap)
            this._compileTableMap(tableop);
        else if (tableop.isCrossJoin)
            this._compileTableCrossJoin(tableop);
        else if (tableop.isNestedLoopJoin)
            this._compileTableNestedLoopJoin(tableop);
        else
            throw new TypeError();
    }

    _compileEndOfFlow(action) {
        if (!action.selector.isDevice || !isRemoteSend(action))
            return;

        let tryCatch = new JSIr.TryCatch("Failed to signal end-of-flow");

        this._irBuilder.add(tryCatch);
        this._irBuilder.pushBlock(tryCatch.try);

        let principal, flow;
        for (let inParam of action.in_params) {
            if (inParam.name !== '__principal' && inParam.name !== '__flow')
                continue;
            let reg = compileValue(this._irBuilder, inParam.value, this._varScope);
            if (inParam.name === '__flow')
                flow = reg;
            else
                principal = reg;
        }
        this._irBuilder.add(new JSIr.SendEndOfFlow(principal, flow));

        this._irBuilder.popBlock();
    }

    compile() {
        let ruleop = compileStatementToOp(this._rule);

        if (ruleop.stream)
            this._compileStream(ruleop.stream);

        for (let action of ruleop.actions)
            this._compileAction(action);

        this._irBuilder.popAll();

        for (let action of ruleop.actions)
            this._compileEndOfFlow(action);

        let result = this._testMode ? this._irBuilder.codegen() : this._irBuilder.compile();
        return new CompiledRule(this._rule.isRule, this._functions, this._nextStateVar, result);
    }
}

module.exports = class AppCompiler {
    constructor(testMode) {
        this._testMode = testMode;

        this._name = undefined;
        this._params = {};
        this._declarations = {};
        this._classes = {};
        this._rules = [];

        this._schemaRetriever = null;
    }

    setSchemaRetriever(schemaRetriever) {
        this._schemaRetriever = schemaRetriever;
    }

    get warnings() {
        return [];
    }

    get name() {
        return this._name;
    }

    get declarations() {
        return this._declarations;
    }

    get rules() {
        return this._rules;
    }

    compileCode(code) {
        return this.compileProgram(Grammar.parse(code));
    }

    verifyProgram(ast) {
        return typeCheckProgram(ast, this._schemaRetriever).then(() => {
            ast.classes.forEach((ast) => {
                this._classes[ast.name] = ast;
            });
            ast.declarations.forEach((ast) => {
                this._declarations[ast.name] = ast;
            });
        });
    }

    compileProgram(ast) {
        return this.verifyProgram(ast).then(() => {
            if (ast.declarations.length > 0)
                throw new NotImplementedError(ast.declarations);

            ast.rules.forEach((stmt) => {
                let compiler = new RuleCompiler(this, stmt, this._testMode);
                this._rules.push(compiler.compile());
            });
        });
    }
};


},{"./ast":44,"./builtin":46,"./grammar":55,"./jsir":57,"./type":65,"./typecheck":66,"adt":7,"assert":8}],49:[function(require,module,exports){
// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2015-2018 The Board of Trustees of the Leland Stanford Junior University
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
//
// See COPYING for details
"use strict";

const assert = require('assert');

const TIME_UNITS = ['ms', 's', 'min', 'h', 'day', 'week', 'mon', 'year'];
const SET_ZERO = [(d) => {},
    (d) => {
        d.setMilliseconds(0); // start of current second
    },
    (d) => {
        d.setSeconds(0, 0); // start of current minute
    },
    (d) => {
        d.setMinutes(0, 0, 0); // start of current hour
    },
    (d) => {
        d.setHours(0, 0, 0, 0); // start of current day
    },
    (d) => {
        d.setHours(0, 0, 0, 0);
        d.setDate(d.getDate()-d.getDay()); // start of current week (week starts Sunday)
    },
    (d) => {
        d.setHours(0, 0, 0, 0);
        d.setDate(1); // start of current month
    },
    (d) => {
        d.setHours(0, 0, 0, 0);
        d.setMonth(0, 1); // start of current year
    }
];
const ADD_ONE = [
    (d) => {
        d.setMilliseconds(d.getMilliseconds()+1);
    },
    (d) => {
        d.setSeconds(d.getSeconds()+1);
    },
    (d) => {
        d.setMinutes(d.getMinutes()+1);
    },
    (d) => {
        d.setHours(d.getHours()+1);
    },
    (d) => {
        d.setDate(d.getDate()+1);
    },
    (d) => {
        d.setDate(d.getDate()+7);
    },
    (d) => {
        d.setMonth(d.getMonth()+1);
    },
    (d) => {
        d.setFullYear(d.getFullYear()+1);
    }
];
assert(SET_ZERO.length === TIME_UNITS.length);
assert(ADD_ONE.length === TIME_UNITS.length);


function createEdgeDate(edge, unit) {
    const index = TIME_UNITS.indexOf(unit);

    const date = new Date;
    SET_ZERO[index](date);
    if (edge === 'end_of')
        ADD_ONE[index](date);
    return date;
}

module.exports = {
    normalizeDate(value, operator, offset) {
        if (operator === '-')
            offset = -offset;
        let base;
        if (value === null)
            base = new Date;
        else if (value instanceof Date)
            base = value;
        else
            base = createEdgeDate(value.edge, value.unit);
        base.setMilliseconds(base.getMilliseconds() + offset);
        return base;
    },

    parseDate(form) {
        if (form instanceof Date)
            return form;

        let now = new Date;
        let year = form.year;
        if (year < 0 || year === undefined)
            year = now.getFullYear();
        let month = form.month;
        if (month < 0 || month === undefined)
            month = now.getMonth() + 1;
        let day = form.day;
        if (day < 0 || day === undefined)
            day = now.getDate();
        let hour = form.hour;
        if (hour < 0 || hour === undefined)
            hour = 0;
        let minute = form.minute;
        if (minute < 0 || minute === undefined)
            minute = 0;
        let second = form.second;
        if (second < 0 || second === undefined)
            second = 0;
        let millisecond = (second - Math.floor(second))*1000;
        second = Math.floor(second);

        return new Date(year, month-1, day, hour, minute, second, millisecond);
    },
};
},{"assert":8}],50:[function(require,module,exports){
// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Almond
//
// Copyright 2016 The Board of Trustees of the Leland Stanford Junior University
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
//
// See COPYING for details
"use strict";

const assert = require('assert');

const Ast = require('./ast');
const Type = require('./type');
const { clean } = require('./utils');

function displayLocation(_, loc) {
    if (loc.isAbsolute) {
        if (loc.display)
            return loc.display;
        else
            return '[Latitude: ' + Number(loc.lat).toFixed(3) + ' deg, Longitude: ' + Number(loc.lon).toFixed(3) + ' deg]';
    } else {
        switch (loc.relativeTag) {
        case 'current_location':
            return _("here");
        case 'home':
            return _("at home");
        case 'work':
            return _("at work");
        default:
            return loc.relativeTag;
        }
    }
}

function describeDate(_, date, operator, offset) {
    let base;

    if (date === null) {
        base = _("now");
    } else if (date.isDateEdge) {
        let unit;
        switch (date.unit) {
        case 'ms':
            unit = _("this millisecond");
            break;
        case 's':
            unit = _("this second");
            break;
        case 'm':
            unit = _("this minute");
            break;
        case 'h':
            unit = _("this hour");
            break;
        case 'day':
            unit = _("today");
            break;
        case 'week':
            unit = _("this week");
            break;
        case 'mon':
            unit = _("this month");
            break;
        case 'year':
            unit = _("this year");
            break;
        }
        if (date.edge === 'start_of')
            base = _("the start of %s").format(unit);
        else
            base = _("the end of %s").format(unit);
    } else {
        if (date.getHours() === 0 && date.getMinutes() === 0 && date.getSeconds() === 0)
            base = date.toLocaleDateString();
        else
            base = date.toLocaleString();
    }

    if (offset && operator === '+')
        return _("%s past %s").format(describeArg(_, offset, {}), base);
    else if (offset && operator === '-')
        return _("%s before %s").format(describeArg(_, offset, {}), base);
    else
        return base;
}

function describeTime(_, time) {
    if (time.second !== 0)
        return "%02d:%02d:%02d".format(time.hour, time.minute, time.second);

    if (time.hour > 0 && time.hour < 12)
        return "%d:%02dam".format(time.hour, time.minute);
    if (time.hour === 0)
        return "12:%02dam".format(time.minute);
    if (time.hour === 12)
        return "12:%02dpm".format(time.minute);
    return "%d:%02dpm".format(time.hour-12, time.minute);
}

function describeArg(_, arg, scope = {}) {
    if (arg.display)
        return arg.display;
    if (arg.isArray)
        return arg.value.map((v) => describeArg(_, v, scope)).join(', ');
    if (arg.isVarRef) {
        let name;
        if (arg.name in scope)
            name = scope[arg.name];
        else
            name = clean(arg.name);
        return _("the %s").format(name);
    }
    if (arg.isUndefined)
        return '____';
    if (arg.isEvent) {
        switch (arg.name) {
        case 'program_id':
            return _("the program ID");
        case 'type':
            return _("the device type");
        default:
            return _("the result");
        }
    }
    if (arg.isLocation)
        return displayLocation(_, arg.value);
    if (arg.isString)
        return '"' + arg.value + '"';
    if (arg.isEntity) {
        if (arg.type === 'tt:username' || arg.type === 'tt:contact_name' || arg.type === 'tt:contact_group_name')
            return '@' + arg.value;
        if (arg.type === 'tt:hashtag')
            return '#' + arg.value;
        return arg.value;
    }
    if (arg.isNumber)
        return arg.value;
    if (arg.isEnum)
        return clean(arg.value);
    if (arg.isMeasure)
        return arg.value + ' ' + arg.unit;
    if (arg.isBoolean)
        return arg.value ? _("true") : _("false");
    if (arg.isDate)
        return describeDate(_, arg.value, arg.operator, arg.offset);
    if (arg.isTime)
        return describeTime(_, arg);

    return String(arg);
}

function describePlaceholder(_, type) {
    return '____';
}

function describeOperator(_, argcanonical, op, value, negate, ptype) {
    switch (op) {
    case 'contains':
        if (negate)
            return _("the %s do not contain %s").format(argcanonical, value);
        else
            return _("the %s contain %s").format(argcanonical, value);
    case 'substr':
    case '=~':
        if (negate)
            return _("the %s does not contain %s").format(argcanonical, value);
        else
            return _("the %s contains %s").format(argcanonical, value);
    case 'in_array':
    case '~=':
        if (negate)
            return _("%s does not contain the %s").format(value, argcanonical);
        else
            return _("%s contains the %s").format(value, argcanonical);
    case 'starts_with':
        if (negate)
            return _("the %s does not start with %s").format(argcanonical, value);
        else
            return _("the %s starts with %s").format(argcanonical, value);
    case 'ends_with':
        if (negate)
            return _("the %s does not end with %s").format(argcanonical, value);
        else
            return _("the %s ends with %s").format(argcanonical, value);
    case 'prefix_of':
        if (negate)
            return _("the %s is not a prefix of %s").format(argcanonical, value);
        else
            return _("the %s is a prefix of %s").format(argcanonical, value);
    case 'suffix_of':
        if (negate)
            return _("the %s is not a suffix of %s").format(argcanonical, value);
        else
            return _("the %s is a suffix of %s").format(argcanonical, value);
    case '==':
        if (negate)
            return _("the %s is not equal to %s").format(argcanonical, value);
        else
            return _("the %s is equal to %s").format(argcanonical, value);
    case '<=':
        if (ptype.isTime || ptype.isDate) {
            if (negate)
                return _("the %s is after %s").format(argcanonical, value);
            else
                return _("the %s is before %s").format(argcanonical, value);
        } else {
            if (negate)
                return _("the %s is greater than %s").format(argcanonical, value);
            else
                return _("the %s is less than or equal to %s").format(argcanonical, value);
        }
    case '>=':
        if (ptype.isTime || ptype.isDate) {
            if (negate)
                return _("the %s is before %s").format(argcanonical, value);
            else
                return _("the %s is after %s").format(argcanonical, value);
        } else {
            if (negate)
                return _("the %s is less than %s").format(argcanonical, value);
            else
                return _("the %s is greater than or equal to %s").format(argcanonical, value);
        }
    default:
        throw new TypeError('Invalid operator ' + op);
    }
}

function describeAtomFilter(_, expr, schema, scope, negate) {
    let filter = expr;
    let argname = filter.name;
    let argcanonical;
    if (schema) {
        if (argname in schema.index) {
            let index = schema.index[argname];
            argcanonical = schema.argcanonicals[index] || clean(argname);
        } else {
            argcanonical = scope[argname];
        }
    } else {
        argcanonical = scope[argname];
    }
    let value =  describeArg(_, filter.value, scope);
    let ptype;
    if (schema === null)
        ptype = Type.Entity('tt:contact');
    else
        ptype = schema.out[argname] || schema.inReq[argname] || schema.inOpt[argname];
    return describeOperator(_, argcanonical, filter.operator, value, negate, ptype);
}

function describeFilter(_, expr, schema, scope = {}) {
    return (function recursiveHelper(expr) {
        if (expr.isTrue || (expr.isAnd && expr.operands.length === 0))
            return _("true");
        if (expr.isFalse || (expr.isOr && expr.operands.length === 0))
            return _("false");
        if (expr.isAnd)
            return expr.operands.map(recursiveHelper).reduce((x, y) => _("%s and %s").format(x, y));
        if (expr.isOr)
            return expr.operands.map(recursiveHelper).reduce((x, y) => _("%s or %s").format(x, y));
        if (expr.isNot && expr.expr.isAtom)
            return describeAtomFilter(_, expr.expr, schema, scope, true);
        if (expr.isNot)
            return _("not %s").format(recursiveHelper(expr.expr));
        if (expr.isExternal) {
            if (expr.selector.kind === 'org.thingpedia.builtin.thingengine.builtin' &&
                expr.channel === 'get_time') {
                const schema = expr.schema.clone();
                schema.argcanonicals[0] = _("current time");
                return describeFilter(_, expr.filter, schema, scope);
            }
            if (expr.selector.kind === 'org.thingpedia.builtin.thingengine.phone' &&
                expr.channel === 'get_gps') {
                const schema = expr.schema.clone();
                schema.argcanonicals[0] = _("my location");
                return describeFilter(_, expr.filter, schema, scope);
            }

            const primdesc = describePrimitive(_, expr, scope, []);

            if (expr.filter.isAtom) {
                // common case
                return describeOperator(_, _("the %s of %s").format(expr.filter.name, primdesc),
                                        expr.filter.operator, describeArg(_, expr.filter.value, scope), false,
                                        expr.schema.out[expr.filter.name]);
            } else if (expr.filter.isNot && expr.filter.expr.isAtom) {
                // common case 2
                return describeOperator(_, _("the %s of %s").format(expr.filter.expr.name, primdesc),
                                        expr.filter.expr.operator, describeArg(_, expr.filter.expr.value, scope), true,
                                        expr.schema.out[expr.filter.expr.name]);
            } else {
                // general case
                return _("for %s, %s").format(primdesc, describeFilter(_, expr.filter, expr.schema, scope));
            }
        }
        return describeAtomFilter(_, expr, schema, scope, false);
    })(expr);
}

function describePrimitive(_, obj, scope, extraInParams = []) {
    if (obj.selector.isBuiltin) {
        if (obj.channel === 'return')
            return _("send it to me");
        else if (obj.channel === 'notify')
            return _("notify you");
        else if (obj.channel === 'save')
            return _("save it");
        else
            throw new TypeError();
    }

    var kind = obj.selector.kind;
    var channel = obj.channel;
    var schema = obj.schema;

    var confirm;
    if (kind === 'remote' || kind.startsWith('__dyn')) {
        // special case internal sending/receiving
        if (channel === 'send')
            confirm = _("send it to $__principal");
        else if (channel === 'receive')
            confirm = _("you receive something from $__principal");
        else
            throw TypeError('Invalid @remote channel ' + channel);
    } else {
        confirm = schema.confirmation;
        if (obj.selector.device)
            confirm = confirm.replace('$__device', obj.selector.device.name);
        else
            confirm = confirm.replace('$__device', clean(kind));
    }

    let firstExtra = true;
    for (let inParam of obj.in_params.concat(extraInParams)) {
        let argname = inParam.name;
        let ptype = obj.schema.inReq[argname] || obj.schema.inOpt[argname];
        let index = obj.schema.index[argname];
        let argcanonical = obj.schema.argcanonicals[index] || clean(argname);
        let value = inParam.value.isUndefined ? describePlaceholder(_, ptype) : describeArg(_, inParam.value, scope);
        if (confirm.indexOf('$' + argname) >= 0) {
            confirm = confirm.replace('$' + argname, value);
        } else if (confirm.indexOf('${' + argname + '}') >= 0) {
            confirm = confirm.replace('${' + argname + '}', value);
        } else {
            if (argname.startsWith('__'))
                continue;
            if (kind === 'remote' || kind.startsWith('__dyn'))
                continue;
            if (inParam.value.isUndefined && inParam.name in obj.schema.inReq)
                continue;
            if (firstExtra) {
                confirm = confirm + _(" with %s equal to %s").format(argcanonical, value);
                firstExtra = false;
            } else {
                confirm = confirm + _(" and %s equal to %s").format(argcanonical, value);
            }
        }
    }

    return confirm;
}

function describeTable(_, table, extraInParams) {
    if (table.isVarRef) {
        return clean(table.name);
    } else if (table.isInvocation) {
        return describePrimitive(_, table.invocation, {}, extraInParams);
    } else if (table.isFilter) {
        return _("%s if %s").format(describeTable(_, table.table, extraInParams),
            describeFilter(_, table.filter, table.schema));
    } else if (table.isProjection) {
        return _("the %s of %s").format(
            describeArgList(_, table.args, table.schema),
            describeTable(_, table.table, extraInParams));
    } else if (table.isCompute) {
        return _("a value computed from %s").format(
            describeTable(_, table.table, extraInParams)); // FIXME
    } else if (table.isAlias) {
        return describeTable(_, table.table, extraInParams);
    } else if (table.isAggregation) {
        if (table.field === '*')
            return _("the count of %s").format(describeTable(_, table.table, extraInParams));
        return _("the %s of %s in %s").format(
            table.operator,
            describeArgName(_, table.field, table.schema).
            describeTable(_, table.table, extraInParams));
    } else if (table.isArgMinMax) {
        if (table.operator === 'argmin') {
            return _("the %s with the minimum %s").format(
                describeTable(_, table.table, extraInParams),
                describeArgName(_, table.field, table.schema));
        } else {
            return _("the %s with the maximum %s").format(
                describeTable(_, table.table, extraInParams),
                describeArgName(_, table.field, table.schema));
        }
    } else if (table.isJoin) {
        let lhsParams = extraInParams.filter((p) => p.name in table.lhs.schema.inReq || p.name in table.lhs.schema.inOpt);
        let rhsParams = extraInParams.filter((p) => p.name in table.rhs.schema.inReq || p.name in table.rhs.schema.inOpt);

        return _("%s and %s").format(describeTable(_, table.lhs, lhsParams),
            describeTable(_, table.rhs, rhsParams.concat(table.in_params)));
    } else if (table.isWindow) {
        if (table.base.isNumber && table.base.value === 1) {
            return _("the latest %s results of %s").format(describeArg(_, table.delta),
                describeStream(_, table.stream));
        } else {
            return _("the latest %s results, starting at the %d-th, of %s").format(
                describeArg(_, table.delta),
                describeArg(_, table.base),
                describeStream(_, table.stream));
        }
    } else if (table.isTimeSeries) {
        if (table.base.isDate && table.base.value === null) {
            return _("the results in the last %s of %s").format(
                describeArg(_, table.delta),
                describeStream(_, table.stream));
        } else {
            return _("the results in the %s prior to %s of %s").format(
                describeArg(_, table.delta),
                describeArg(_, table.base),
                describeStream(_, table.stream));
        }
    } else if (table.isSequence) {
        if (table.base.isNumber && table.base.value === 1) {
            return _("the latest %s %s").format(describeArg(_, table.delta),
                describeTable(_, table.table, []));
        } else {
            return _("the latest %s %s, starting at the %d-th").format(
                describeArg(_, table.delta),
                describeTable(_, table.table, []),
                describeArg(_, table.base));
        }
    } else if (table.isHistory) {
        if (table.base.isDate && table.base.value === null) {
            return _("the %s that changed in in the last %s").format(
                describeTable(_, table.table, []),
                describeArg(_, table.delta));
        } else {
            return _("the %s that changed in the %s prior to %s").format(
                describeTable(_, table.table, []),
                describeArg(_, table.delta),
                describeArg(_, table.base));
        }
    } else {
        throw new TypeError();
    }
}

function describeArgName(_, argname, schema) {
    let index = schema.index[argname];
    return schema.argcanonicals[index] || clean(argname);
}

function describeArgList(_, args, schema) {
    return args.map((argname) => describeArgName(argname, schema)).join(", ");
}

function describeStream(_, stream) {
    if (stream.isVarRef) {
        return clean(stream.name);
    } else if (stream.isTimer) {
        if (stream.base.value === null) {
            return _("every %s").format(describeArg(_, stream.interval));
        } else {
            return _("every %s starting %s").format(describeArg(_, stream.interval),
                describeArg(_, stream.base));
        }
    } else if (stream.isAtTimer) {
        return _("every day at %s").format(describeArg(_, stream.time));
    } else if (stream.isMonitor) {
        if (stream.table.isFilter) {
            // flip monitor of filter to filter of monitor
            if (stream.table.schema.is_list) {
                return _("when %s change if %s").format(describeTable(_, stream.table.table, []),
                    describeFilter(_, stream.table.filter, stream.table.schema));
            } else {
                return _("when %s changes if %s").format(describeTable(_, stream.table.table, []),
                    describeFilter(_, stream.table.filter, stream.table.schema));
            }
        }

        if (stream.table.schema.is_list)
            return _("when %s change").format(describeTable(_, stream.table, []));
        else
            return _("when %s changes").format(describeTable(_, stream.table, []));
    } else if (stream.isEdgeNew) {
        return _("%s changes").format(describeStream(_, stream.stream)); // XXX weird
    } else if (stream.isEdgeFilter) {
        return _("%s and it becomes true that %s").format(describeStream(_, stream.stream),
            describeFilter(_, stream.filter, stream.schema));
    } else if (stream.isFilter) {
        return _("%s and %s").format(describeStream(_, stream.stream),
            describeFilter(_, stream.filter, stream.schema));
    } else if (stream.isProjection) {
        return _("the %s of %s").format(
            describeArgList(_, stream.args, stream.schema),
            describeStream(_, stream.stream));
    }  else if (stream.isCompute) {
        return _("a value computed from %s").format(
            describeStream(_, stream.stream)); // FIXME
    } else if (stream.isAlias) {
        return describeStream(_, stream.stream);
    } else if (stream.isJoin) {
        return _("%s and then get %s").format(
            describeStream(_, stream.stream),
            describeTable(_, stream.table, stream.in_params)
        );
    } else {
        throw new TypeError();
    }
}

function describeActionList(_, actions) {
    return actions.map((a) => describePrimitive(_, a)).join(', ');
}

function describeRule(_, r) {
    if (r.isRule) {
        return _("%s %s").format(
            describeActionList(_, r.actions),
            describeStream(_, r.stream));
    } else if (r.table !== null) {
        return _("get %s and then %s").format(describeTable(_, r.table, []),
            describeActionList(_, r.actions));
    } else {
        return describeActionList(_, r.actions);
    }
}

function describeDeclaration(_, d) {
    if (d.type === 'stream')
        return _("let %s be %s").format(clean(d.name), describeStream(_, d.value));
    else if (d.type === 'table')
        return _("let %s be %s").format(clean(d.name), describeTable(_, d.value));
    else
        return _("let %s be %s").format(clean(d.name), describePrimitive(_, d.value));
}

function describeProgram(_, program) {
    let desc = program.declarations.concat(program.rules).map((r) => {
        if (r.isDeclaration)
            return describeDeclaration(_, r);
        else
            return describeRule(_, r);
    }).join('; ');
    if (program.principal)
        return _("tell %s: %s").format(describeArg(_, program.principal), desc);
    else
        return desc;
}

function describePermissionFunction(_, permissionFunction, functionType, scope) {
    if (permissionFunction.isSpecified) {
        let kind = permissionFunction.kind;
        let schema = permissionFunction.schema;

        let confirm = schema.confirmation;
        confirm = confirm.replace('$__device', clean(kind));

        if (!permissionFunction.filter.isTrue) {
            let filterClone = permissionFunction.filter.clone().optimize();

            if (!filterClone.isAnd)
                filterClone = Ast.BooleanExpression.And([filterClone]);

            filterClone.operands.forEach((operand, i) => {
                // don't traverse Ors or Nots
                if (!operand.isAtom)
                    return;
                if (operand.operator !== '==')
                    return;

                let argname = operand.name;
                if (confirm.indexOf('$' + argname) >= 0) {
                    confirm = confirm.replace('$' + argname, describeArg(_, operand.value, scope));
                    filterClone.operands[i] = Ast.BooleanExpression.True;
                } else if (confirm.indexOf('${' + argname + '}') >= 0) {
                    confirm = confirm.replace('${' + argname + '}', describeArg(_, operand.value, scope));
                    filterClone.operands[i] = Ast.BooleanExpression.True;
                }
            });
            filterClone = filterClone.optimize();

            if (!filterClone.isTrue)
                confirm = _("%s if %s").format(confirm, describeFilter(_, filterClone, schema, scope));
        }
        for (let argname of schema.args) {
            let index = schema.index[argname];
            let argcanonical = schema.argcanonicals[index];
            if (confirm.indexOf('$' + argname) >= 0)
                confirm = confirm.replace('$' + argname, _("any %s").format(argcanonical));
            else if (confirm.indexOf('${' + argname + '}') >= 0)
                confirm = confirm.replace('${' + argname + '}', _("any %s").format(argcanonical));
        }

        for (let argname in permissionFunction.schema.out) {
            let index = schema.index[argname];
            let argcanonical = schema.argcanonicals[index] || clean(argname);
            scope[argname] = argcanonical;
        }

        return confirm;
    } else {
        assert(permissionFunction.isClassStar);

        // class star
        let kind = permissionFunction.kind;
        if (kind === 'org.thingpedia.builtin.thingengine.builtin') {
            // very weird edge cases...
            switch (functionType) {
            case 'query':
                return _("your clock");
            case 'action':
                return _("send you messages, configure new accounts and open links");
            }
        }

        switch (functionType) {
        case 'query':
            return _("your %s").format(doCapitalizeSelector(kind));
        case 'action':
            return _("perform any action on your %s").format(doCapitalizeSelector(kind));
        default:
            return '';
        }
    }
}

function describePermissionRule(_, permissionRule) {
    let principal;
    if (permissionRule.principal.isTrue)
        principal = _("anyone");
    else if (permissionRule.principal.isAtom && permissionRule.principal.operator === '==')
        principal = describeArg(_, permissionRule.principal.value);
    else if (permissionRule.principal.isAtom && permissionRule.principal.operator === 'group_member')
        principal = _("anyone in the %s group").format(describeArg(_, permissionRule.principal.value));
    else
        principal = _("anyone if %s").format(describeFilter(_, permissionRule.principal, null, { source: _("requester") }));

    const scope = {};
    if (permissionRule.query.isBuiltin) {
        if (permissionRule.action.isBuiltin) {
            throw new Error();
        } else if (permissionRule.action.isStar) {
            return _("%s is allowed to perform any action").format(principal);
        } else {
            return _("%s is allowed to %s").format(principal,
                describePermissionFunction(_, permissionRule.action, 'action', scope));
        }
    } else if (permissionRule.query.isStar) {
        if (permissionRule.action.isBuiltin) {
            return _("%s is allowed to read all your data").format(principal);
        } else if (permissionRule.action.isStar) {
            return _("%s is allowed to read all your data and then perform any action with it").format(principal);
        } else {
            return _("%s is allowed to read all your data and then use it to %s").format(
                principal,
                describePermissionFunction(_, permissionRule.action, 'action', scope));
        }
    } else {
        if (permissionRule.action.isBuiltin) {
            return _("%s is allowed to read %s").format(
                principal,
                describePermissionFunction(_, permissionRule.query, 'query', scope));
        } else if (permissionRule.action.isStar) {
            return _("%s is allowed to read %s and then perform any action with it").format(
                principal,
                describePermissionFunction(_, permissionRule.query, 'query', scope));
        } else {
            return _("%s is allowed to read %s and then use it to %s").format(
                principal,
                describePermissionFunction(_, permissionRule.query, 'query', scope),
                describePermissionFunction(_, permissionRule.action, 'action', scope));
        }
    }
}

function capitalize(str) {
    return (str[0].toUpperCase() + str.substr(1)).replace(/[.\-_]([a-z])/g, (whole, char) => ' ' + char.toUpperCase()).replace(/[.\-_]/g, '');
}

function capitalizeSelector(prim) {
    return doCapitalizeSelector(prim.selector.kind, prim.channel);
}

function doCapitalizeSelector(kind, channel) {
    // thingengine.phone -> phone
    if (kind.startsWith('org.thingpedia.builtin.thingengine.'))
        kind = kind.substr('org.thingpedia.builtin.thingengine.'.length);
    // org.thingpedia.builtin.omlet -> omlet
    if (kind.startsWith('org.thingpedia.builtin.'))
        kind = kind.substr('org.thingpedia.builtin.'.length);
    // org.thingpedia.weather -> weather
    if (kind.startsWith('org.thingpedia.'))
        kind = kind.substr('org.thingpedia.'.length);
    // com.xkcd -> xkcd
    if (kind.startsWith('com.'))
        kind = kind.substr('com.'.length);
    if (kind.startsWith('gov.'))
        kind = kind.substr('gov.'.length);
    if (kind.startsWith('org.'))
        kind = kind.substr('org.'.length);
    if (kind.startsWith('uk.co.'))
        kind = kind.substr('uk.co.'.length);

    if (kind === 'builtin' || kind === 'remote' || kind.startsWith('__dyn_'))
        return capitalize(channel);
    else
        return capitalize(kind);
}

function getProgramName(_, program) {
    let descriptions = [];
    for (let [,prim] of program.iteratePrimitives()) {
        if (prim.selector.isBuiltin)
            descriptions.push(_("Notification"));
        else
            descriptions.push(capitalizeSelector(prim));
    }
    return descriptions.join(" ⇒ ");
}

function pubDescribeArg(gettext, arg) {
    return describeArg(gettext.dgettext.bind(gettext, 'thingtalk'), arg, {});
}
function pubDescribeFilter(gettext, filter, schema, scope = {}) {
    return describeFilter(gettext.dgettext.bind(gettext, 'thingtalk'), filter, schema, scope);
}
function pubDescribeProgram(gettext, program) {
    return describeProgram(gettext.dgettext.bind(gettext, 'thingtalk'), program);
}
function pubGetProgramName(gettext, program) {
    return getProgramName(gettext.dgettext.bind(gettext, 'thingtalk'), program);
}
function pubDescribePrimitive(gettext, prim, scope) {
    return describePrimitive(gettext.dgettext.bind(gettext, 'thingtalk'), prim, scope);
}
function pubDescribeStream(gettext, stream) {
    return describeStream(gettext.dgettext.bind(gettext, 'thingtalk'), stream);
}
function pubDescribeTable(gettext, table, extraInParams = []) {
    return describeTable(gettext.dgettext.bind(gettext, 'thingtalk'), table, extraInParams);
}

function pubDescribePermissionRule(gettext, permissionRule) {
    return describePermissionRule(gettext.dgettext.bind(gettext, 'thingtalk'), permissionRule);
}
function pubDescribePermissionFunction(gettext, permissionFunction, functionType, scope) {
    return describePermissionFunction(gettext.dgettext.bind(gettext, 'thingtalk'), permissionFunction, functionType, scope);
}

module.exports = {
    describeArg: pubDescribeArg,
    describeFilter: pubDescribeFilter,
    describeProgram: pubDescribeProgram,
    describePrimitive: pubDescribePrimitive,
    describeStream: pubDescribeStream,
    describeTable: pubDescribeTable,
    describePermissionRule: pubDescribePermissionRule,
    describePermissionFunction: pubDescribePermissionFunction,
    getProgramName: pubGetProgramName
};
},{"./ast":44,"./type":65,"./utils":68,"assert":8}],51:[function(require,module,exports){
// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2017 The Board of Trustees of the Leland Stanford Junior University
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
//
// See COPYING for details
"use strict";

function stringEscape(str) {
    if (str === null || str === undefined)
        return 'null';
    return '"' + str.replace(/(["\\])/g, '\\$1').replace(/\n/g, '\\n') + '"';
    // the following comment fixes broken syntax highlighting in GtkSourceView
    //]/
}

module.exports = {
    stringEscape
};

},{}],52:[function(require,module,exports){
// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2015 The Board of Trustees of the Leland Stanford Junior University
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
//
// See COPYING for details
"use strict";

const Formatter = require('./formatter');

module.exports = class ExecEnvironment {
    constructor(locale, timezone, schemaRetriever) {
        this.format = new Formatter(locale, timezone, schemaRetriever);
        this._scope = {};
    }

    /* istanbul ignore next */
    get program_id() {
        throw new Error('Must be overridden');
    }

    /* istanbul ignore next */
    invokeMonitor(fnid, params) {
        throw new Error('Must be overridden');
    }
    /* istanbul ignore next */
    invokeTimer(base, interval) {
        throw new Error('Must be overridden');
    }
    /* istanbul ignore next */
    invokeAtTimer(time) {
        throw new Error('Must be overridden');
    }
    /* istanbul ignore next */
    invokeQuery(fnid, params) {
        throw new Error('Must be overridden');
    }
    /* istanbul ignore next */
    invokeAction(fnid, params) {
        throw new Error('Must be overridden');
    }

    /* istanbul ignore next */
    sendEndOfFlow(principal, flow) {
        throw new Error('Must be overridden');
    }
    /* istanbul ignore next */
    output(outputType, output) {
        throw new Error('Must be overridden');
    }

    /* istanbul ignore next */
    readState(stateId) {
        throw new Error('Must be overridden');
    }
    /* istanbul ignore next */
    writeState(stateId, value) {
        throw new Error('Must be overridden');
    }
    /* istanbul ignore next */
    reportError(message, err) {
        throw new Error('Must be overridden');
    }

    formatEvent(outputType, output, hint) {
        return this.format.formatForType(outputType, output, hint);
    }
};

},{"./formatter":53}],53:[function(require,module,exports){
// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2017 The Board of Trustees of the Leland Stanford Junior University
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
//
// See COPYING for details
"use strict";

const vm = require('vm');

const Units = require('./units');
const { clean } = require('./utils');

function compileCode(code) {
    return vm.runInNewContext(code);
}

module.exports = class Formatter {
    constructor(locale, timezone, schemaRetriever) {
        this._locale = locale;
        this._timezone = timezone;
        this._schemas = schemaRetriever;
    }

    _displayValue(value, opt) {
        if (value === undefined || value === null)
            return value;
        if (value.display)
            return value.display;
        if (value instanceof Date) {
            if (opt === 'iso-date')
                return value.toISOString();
            if (opt === 'time')
                return this.timeToString(value);
            else if (opt === 'date')
                return this.dateToString(value);
            else
                return this.dateAndTimeToString(value);
        }
        if (typeof value === 'number') {
            if (opt === '%') {
                value = value*100;
                opt = '';
            }
            if (opt)
                return this.measureToString(value, 1, opt);
            else
                return (Math.floor(value) === value ? value.toFixed(0) : value.toFixed(2));
        }
        if (value.x && value.y)
            return this.locationToString(value);
        else
            return value.toLocaleString(this._locale);
    }

    _replaceInString(str, argMap) {
        if (typeof str !== 'string')
            return undefined;
        return str.replace(/\$(?:\$|([a-zA-Z0-9_]+(?![a-zA-Z0-9_]))|{([a-zA-Z0-9_]+)(?::(%|[a-zA-Z-]+))?})/g, (match, param1, param2, opt) => {
            if (match === '$$')
                return '$';
            let param = param1 || param2;
            if (param.startsWith('{'))
                param = param.substring(0, param.length-1);
            let value = argMap[param];
            return this._displayValue(value, opt);
        });
    }

    _formatKey(key) {
        if (key.startsWith('__')) {
            let agg = key.split('_')[2];
            let field = key.substring(agg.length + 3);
            return `${agg}${field === 'star'? '' : ` of ${field}`}`; //` <- fix GtkSourceView screwup
        } else {
            return key;
        }
    }

    _formatFallback(outputValue) {
        return Object.keys(outputValue).map((key) => {
            return `${clean(key)}: ${this._displayValue(outputValue[key])}`;
        });
    }

    formatForType(outputType, outputValue, hint) {
        // apply masquerading for @remote.receive
        // outputValue[0..2] are the input parameters (principal, programId and flow)
        // outputValue[3] is the real underlying output type, and outputValue.slice(4)
        // is the real data
        if (outputType === 'org.thingpedia.builtin.thingengine.remote:receive')
            outputType = String(outputValue.__kindChannel);

        // Handle builtin:get_commands specially
        if (outputType === 'org.thingpedia.builtin.thingengine.builtin:get_commands')
            return { type: 'program', program: outputValue.program };

        if (outputType === null)
            return this._formatFallback(outputValue);

        // for now, ignore multiple output types
        if (outputType.indexOf('+') >= 0) {
            let types = outputType.split('+');
            outputType = types[types.length-1];
        }

        let [kind, function_name] = outputType.split(':');
        return this._schemas.getFormatMetadata(kind, function_name).then((metadata) => {
            if (metadata.length)
                return this.format(metadata, outputValue, hint);
            else
                return this._formatFallback(outputValue);
        });
    }

    format(formatspec, argMap, hint) {
        return this._postprocess(formatspec.map((f, i) => {
            if (typeof f === 'function')
                return f(argMap, hint, this);
            if (typeof f === 'string')
                return this._replaceInString(f, argMap) || '';
            if (typeof f !== 'object' || f === null)
                return String(f);
            if (f.type === 'text')
                return this._replaceInString(f.text, argMap) || '';
            if (f.type === 'picture') {
                return {
                    type: 'picture',
                    url: this._replaceInString(f.url, argMap)
                };
            }
            if (f.type === 'rdl') {
                return {
                    type: 'rdl',
                    callback: this._replaceInString(f.callback, argMap),
                    webCallback: this._replaceInString(f.webCallback, argMap),
                    displayTitle: this._replaceInString(f.displayTitle, argMap),
                    displayText: this._replaceInString(f.displayText, argMap)
                };
            }
            if (f.type === 'code') {
                var compiled = compileCode('(' + f.code + ')');
                formatspec[i] = compiled;
                return compiled(argMap, hint, this);
            }
            throw new Error('Unrecognized formatter type ' + f.type);
        }), hint);
    }

    _postprocess(formatted, hint) {
        if (typeof formatted === 'string')
            return formatted;
        if (formatted === null)
            return '';
        if (typeof formatted === 'object' &&
            formatted.type === 'text')
            return formatted.text;
        if (!Array.isArray(formatted))
            formatted = [formatted];

        if (hint === 'string') {
            formatted = formatted.map((x) => {
                if (typeof x === 'string')
                    return x;
                if (x === null)
                    return 'null';
                if (typeof x !== 'object')
                    return this.anyToString(x);
                if (x.type === 'text')
                    return x.text;
                if (x.type === 'picture')
                    return 'Picture: ' + x.url;
                if (x.type === 'rdl')
                    return 'Link: ' + x.displayTitle + ' <' + x.webCallback + '>';
                return this.anyToString(x);
            });
            return formatted.join('\n');
        } else {
            return formatted;
        }
    }

    measureToString(value, precision, unit) {
        var baseUnit = Units.UnitsToBaseUnit[unit];
        if (!baseUnit)
            throw new Error('Invalid unit ' + unit);

        var coeff = Units.UnitsTransformToBaseUnit[unit];
        if (typeof coeff === 'function')
            return Units.UnitsInverseTransformFromBaseUnit[unit](value).toFixed(precision);
        else
            return ((1/coeff)*value).toFixed(precision);
    }

    dateToString(date, options) {
        if (!options) {
            options = {
                weekday: 'long',
                day: 'numeric',
                month: 'long',
                year: 'numeric',
            };
        }
        options.timeZone = this._timezone;
        return date.toLocaleDateString(this._locale, options);
    }

    timeToString(date, options) {
        if (!options) {
            options = {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                timeZoneName: 'short'
            };
        }
        options.timeZone = this._timezone;
        return date.toLocaleTimeString(this._locale, options);
    }

    dateAndTimeToString(date, options = {}) {
        options.timeZone = this._timezone;
        return date.toLocaleString(this._locale, options);
    }

    locationToString(o) {
        if (o.display)
            return o.display;
        return '[Latitude: ' + Number(o.y).toFixed(3) + ' deg, Longitude: ' + Number(o.x).toFixed(3) + ' deg]';
    }

    anyToString(o) {
        if (Array.isArray(o))
            return (o.map(this.anyToString, this).join(', '));
        else if (typeof o === 'object' && o !== null &&
             o.hasOwnProperty('x') && o.hasOwnProperty('y'))
            return this.locationToString(o);
        else if (typeof o === 'number')
            return (Math.floor(o) === o ? o.toFixed(0) : o.toFixed(3));
        else if (o instanceof Date)
            return this.dateAndTimeToString(o);
        else
            return String(o);
    }
};

},{"./units":67,"./utils":68,"vm":74}],54:[function(require,module,exports){
// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Almond
//
// Copyright 2016 The Board of Trustees of the Leland Stanford Junior University
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
//
// See COPYING for details
"use strict";

const { isUnaryStreamToStreamOp,
        isUnaryTableToTableOp,
        isUnaryStreamToTableOp,
        isUnaryTableToStreamOp } = require('./utils');

// Initialize the AST API
const { notifyAction } = require('./ast_api');

module.exports = {
    notifyAction,

    // recursive utilities
    isUnaryTableToTableOp,
    isUnaryStreamToTableOp,
    isUnaryStreamToStreamOp,
    isUnaryTableToStreamOp,
};

},{"./ast_api":45,"./utils":68}],55:[function(require,module,exports){
module.exports = (function() {
  "use strict";

  /*
   * Generated by PEG.js 0.9.0.
   *
   * http://pegjs.org/
   */

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function peg$SyntaxError(message, expected, found, location) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.location = location;
    this.name     = "SyntaxError";

    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, peg$SyntaxError);
    }
  }

  peg$subclass(peg$SyntaxError, Error);

  function peg$parse(input) {
    var options = arguments.length > 1 ? arguments[1] : {},
        parser  = this,

        peg$FAILED = {},

        peg$startRuleFunctions = { input: peg$parseinput, program: peg$parseprogram, type_ref: peg$parsetype_ref, permission_rule: peg$parsepermission_rule },
        peg$startRuleFunction  = peg$parseinput,

        peg$c0 = "executor",
        peg$c1 = { type: "literal", value: "executor", description: "\"executor\"" },
        peg$c2 = "=",
        peg$c3 = { type: "literal", value: "=", description: "\"=\"" },
        peg$c4 = "self",
        peg$c5 = { type: "literal", value: "self", description: "\"self\"" },
        peg$c6 = ":",
        peg$c7 = { type: "literal", value: ":", description: "\":\"" },
        peg$c8 = function(value) {
            if (value === 'self')
                return null;
            else if (value.isString) // for compat and ease of use, a raw string is a contact name
                return Ast.Value.Entity(value.value, 'tt:username', null);
            else
                return value;
        },
        peg$c9 = "{",
        peg$c10 = { type: "literal", value: "{", description: "\"{\"" },
        peg$c11 = "}",
        peg$c12 = { type: "literal", value: "}", description: "\"}\"" },
        peg$c13 = function(principal, classes, declarations, rules) {
            return optimizeProgram(new Ast.Program(take(classes, 0), take(declarations, 0), take(rules, 0), principal));
        },
        peg$c14 = function(principal, rule) {
          if (rule.isDeclaration)
            return optimizeProgram(new Ast.Program([], [rule], [], principal));
          else
            return optimizeProgram(new Ast.Program([], [], [rule], principal));
        },
        peg$c15 = ".",
        peg$c16 = { type: "literal", value: ".", description: "\".\"" },
        peg$c17 = "*",
        peg$c18 = { type: "literal", value: "*", description: "\"*\"" },
        peg$c19 = function(kind) {
            return new Ast.PermissionFunction.ClassStar(kind);
        },
        peg$c20 = ",",
        peg$c21 = { type: "literal", value: ",", description: "\",\"" },
        peg$c22 = function(fn, filter) {
            let [selector, channel] = fn;
            let kind = selector.kind;
            if (filter === null)
                filter = Ast.BooleanExpression.True;
            else
                filter = filter[2];
            return new Ast.PermissionFunction.Specified(kind, channel, optimizeFilter(filter), null);
        },
        peg$c23 = function() { return Ast.PermissionFunction.Star },
        peg$c24 = "now",
        peg$c25 = { type: "literal", value: "now", description: "\"now\"" },
        peg$c26 = "=>",
        peg$c27 = { type: "literal", value: "=>", description: "\"=>\"" },
        peg$c28 = "notify",
        peg$c29 = { type: "literal", value: "notify", description: "\"notify\"" },
        peg$c30 = ";",
        peg$c31 = { type: "literal", value: ";", description: "\";\"" },
        peg$c32 = function(principal, first, second) {
            if (first === 'now')
                first = Ast.PermissionFunction.Builtin;
            if (second === 'notify')
                second = Ast.PermissionFunction.Builtin;
            if (first === Ast.PermissionFunction.Builtin && second === Ast.PermissionFunction.Builtin)
                throw new Error('Permission function specifies no access');
            return new Ast.PermissionRule(optimizeFilter(principal), first, second);
        },
        peg$c33 = "@",
        peg$c34 = { type: "literal", value: "@", description: "\"@\"" },
        peg$c35 = "(",
        peg$c36 = { type: "literal", value: "(", description: "\"(\"" },
        peg$c37 = ")",
        peg$c38 = { type: "literal", value: ")", description: "\")\"" },
        peg$c39 = function(first_name, rest_names) {
            return first_name + (rest_names.length > 0 ? ('.' + take(rest_names, 2).join('.')) : '');
        },
        peg$c40 = "class",
        peg$c41 = { type: "literal", value: "class", description: "\"class\"" },
        peg$c42 = "extends",
        peg$c43 = { type: "literal", value: "extends", description: "\"extends\"" },
        peg$c44 = function(name, extends_, members) {
            var _class = new Ast.ClassDef(name, extends_, {}, {});
            for (var [type, name, ast] of members) {
                switch (type) {
                case 'query':
                    _class.queries[name] = ast;
                    break;
                case 'action':
                    _class.actions[name] = ast;
                    break;
                }
            }
            return _class;
        },
        peg$c45 = "query",
        peg$c46 = { type: "literal", value: "query", description: "\"query\"" },
        peg$c47 = "action",
        peg$c48 = { type: "literal", value: "action", description: "\"action\"" },
        peg$c49 = function(type, name, params) {
            var fn = new Ast.FunctionDef('other', [] /*args*/, [] /*types*/, {} /*index*/, {}, {}, {},
                                         (type==='query') /*is_list*/, (type==='query') /*is_monitorable*/,
                                         '' /*canonical*/, '' /*confirmation*/, ''/*confirmation_remote*/,
                                         [] /*argcanonicals*/, [] /*questions*/);
            for (var i = 0; i < params.length; i++) {
                var [direction, argname, argtype] = params[i];
                fn.args.push(argname);
                fn.types.push(argtype);
                fn.index[argname] = i;
                fn[direction][argname] = argtype;
            }
            return [type, name, fn];
        },
        peg$c50 = function() { return []; },
        peg$c51 = function(first, rest) {
            return [first].concat(take(rest, 2));
        },
        peg$c52 = function(direction, name, type) {
            return [direction, name, type];
        },
        peg$c53 = "in",
        peg$c54 = { type: "literal", value: "in", description: "\"in\"" },
        peg$c55 = "req",
        peg$c56 = { type: "literal", value: "req", description: "\"req\"" },
        peg$c57 = function() { return 'inReq'; },
        peg$c58 = "opt",
        peg$c59 = { type: "literal", value: "opt", description: "\"opt\"" },
        peg$c60 = function() { return 'inOpt'; },
        peg$c61 = "out",
        peg$c62 = { type: "literal", value: "out", description: "\"out\"" },
        peg$c63 = function() { return 'out'; },
        peg$c64 = function(type, values) {
            var id;
            if (values.id !== undefined)
                id = values.id;
            else
                id = null;
            if (id !== null)
                id = id.toJS();
            return new Ast.Selector.Device(type, id, null);
        },
        peg$c65 = function(first, rest) {
            var obj = {};
            obj[first[0]] = first[1];
            for (var [name, value] of rest) {
                if (obj[name] !== undefined) return error('Duplicate device attribute ' + name);
                obj[name] = value;
            }
            return obj;
        },
        peg$c66 = "id",
        peg$c67 = { type: "literal", value: "id", description: "\"id\"" },
        peg$c68 = function(value) {
            return ['id', value];
        },
        peg$c69 = function(first_name, rest_names) {
            let channel = rest_names[rest_names.length-1];
            rest_names.pop();

            let kind = first_name + (rest_names.length > 0 ? ('.' + take(rest_names, 2).join('.')) : '');
            return [Ast.Selector.Device(kind, null, null), channel[2]];
        },
        peg$c70 = function(sel, name) {
            return [sel, name];
        },
        peg$c71 = function(name, value) {
            return new Ast.InputParam(name, value);
        },
        peg$c72 = function() { return [] },
        peg$c73 = function(fn, in_params) {
            let [selector, function_name] = fn;
            return new Ast.Invocation(selector, function_name, in_params, null);
        },
        peg$c74 = function(name, in_params) {
          return new Ast.Table.VarRef(name, in_params || [], null);
        },
        peg$c75 = function(call) { return new Ast.Table.Invocation(call, null); },
        peg$c76 = function(table) { return table; },
        peg$c77 = "[",
        peg$c78 = { type: "literal", value: "[", description: "\"[\"" },
        peg$c79 = "]",
        peg$c80 = { type: "literal", value: "]", description: "\"]\"" },
        peg$c81 = "of",
        peg$c82 = { type: "literal", value: "of", description: "\"of\"" },
        peg$c83 = function(first, rest, table) {
          return new Ast.Table.Projection(table, [first].concat(take(rest, 2)), null);
        },
        peg$c84 = "compute",
        peg$c85 = { type: "literal", value: "compute", description: "\"compute\"" },
        peg$c86 = "as",
        peg$c87 = { type: "literal", value: "as", description: "\"as\"" },
        peg$c88 = function(expr, alias, table) {
            return new Ast.Table.Compute(table, expr, alias !== null ? alias[2] : null, null);
        },
        peg$c89 = "window",
        peg$c90 = { type: "literal", value: "window", description: "\"window\"" },
        peg$c91 = "timeseries",
        peg$c92 = { type: "literal", value: "timeseries", description: "\"timeseries\"" },
        peg$c93 = function(what, base, delta, stream) {
          if (what === 'window')
            return new Ast.Table.Window(base, delta, stream, null);
          else
            return new Ast.Table.TimeSeries(base, delta, stream, null);
        },
        peg$c94 = "sequence",
        peg$c95 = { type: "literal", value: "sequence", description: "\"sequence\"" },
        peg$c96 = "history",
        peg$c97 = { type: "literal", value: "history", description: "\"history\"" },
        peg$c98 = function(what, base, delta, table) {
          if (what === 'sequence')
            return new Ast.Table.Sequence(base, delta, table, null);
          else
            return new Ast.Table.History(base, delta, table, null);
        },
        peg$c99 = "aggregate",
        peg$c100 = { type: "literal", value: "aggregate", description: "\"aggregate\"" },
        peg$c101 = "argmin",
        peg$c102 = { type: "literal", value: "argmin", description: "\"argmin\"" },
        peg$c103 = "argmax",
        peg$c104 = { type: "literal", value: "argmax", description: "\"argmax\"" },
        peg$c105 = function(op, base, limit, field, table) {
          return new Ast.Table.ArgMinMax(table, field, op, base, limit, null);
        },
        peg$c106 = "count",
        peg$c107 = { type: "literal", value: "count", description: "\"count\"" },
        peg$c108 = function(alias, table) {
          return new Ast.Table.Aggregation(table, '*', 'count', alias !== null ? alias[2] : null, null);
        },
        peg$c109 = function(op, field, alias, table) {
          return new Ast.Table.Aggregation(table, field, op, alias !== null ? alias[2] : null, null);
        },
        peg$c110 = function(table, alias) {
          if (alias !== null)
            return new Ast.Table.Alias(table, alias[2], null);
          else
            return table;
        },
        peg$c111 = function(table, filter) {
          if (filter !== null)
            return new Ast.Table.Filter(table, optimizeFilter(filter[3]), null);
          else
            return table;
        },
        peg$c112 = "join",
        peg$c113 = { type: "literal", value: "join", description: "\"join\"" },
        peg$c114 = "on",
        peg$c115 = { type: "literal", value: "on", description: "\"on\"" },
        peg$c116 = function(first, rest) {
          return rest.reduce(((x, y) =>
              new Ast.Table.Join(x, y[2], y[4] ? y[4][2]:[], null)), first);
        },
        peg$c117 = function(name, in_params) {
          return new Ast.Stream.VarRef(name, in_params || [], null);
        },
        peg$c118 = function(stream) { return stream; },
        peg$c119 = "timer",
        peg$c120 = { type: "literal", value: "timer", description: "\"timer\"" },
        peg$c121 = "base",
        peg$c122 = { type: "literal", value: "base", description: "\"base\"" },
        peg$c123 = "interval",
        peg$c124 = { type: "literal", value: "interval", description: "\"interval\"" },
        peg$c125 = function(base, interval) {
          return new Ast.Stream.Timer(base, interval, null);
        },
        peg$c126 = "attimer",
        peg$c127 = { type: "literal", value: "attimer", description: "\"attimer\"" },
        peg$c128 = "time",
        peg$c129 = { type: "literal", value: "time", description: "\"time\"" },
        peg$c130 = function(time) {
          return new Ast.Stream.AtTimer(time, null);
        },
        peg$c131 = "edge",
        peg$c132 = { type: "literal", value: "edge", description: "\"edge\"" },
        peg$c133 = "new",
        peg$c134 = { type: "literal", value: "new", description: "\"new\"" },
        peg$c135 = function(stream, edge) {
          if (edge instanceof Ast.BooleanExpression)
            return new Ast.Stream.EdgeFilter(stream, edge, null);
          else
            return new Ast.Stream.EdgeNew(stream, null);
        },
        peg$c136 = function(first, rest) {
          return [first].concat(take(rest, 2));
        },
        peg$c137 = "monitor",
        peg$c138 = { type: "literal", value: "monitor", description: "\"monitor\"" },
        peg$c139 = function(table, params) {
          return new Ast.Stream.Monitor(table, params !== null ? params[4] : null, null);
        },
        peg$c140 = function(params, stream) {
          return new Ast.Stream.Projection(stream, params, null);
        },
        peg$c141 = function(expr, alias, stream) {
            return new Ast.Stream.Compute(stream, expr, alias !== null ? alias[2] : null, null);
        },
        peg$c142 = function(stream, alias) {
          if (alias !== null)
            return new Ast.Stream.Alias(stream, alias[2], null);
          else
            return stream;
        },
        peg$c143 = function(stream, filter) {
          if (filter !== null)
            return new Ast.Stream.Filter(stream, optimizeFilter(filter[3]), null);
          else
            return stream;
        },
        peg$c144 = function(first, rest) {
          return rest.reduce(((x, y) => new Ast.Stream.Join(x, y[2], y[4] ? y[4][2] : [], null)), first);
        },
        peg$c145 = function(first, rest) {
            let ret = {};
            for (let [name, type] of [first, ...take(rest, 2)]) {
              ret[name] = type;
            }
            return ret;
        },
        peg$c146 = function(name, type) {
            return [name, type];
        },
        peg$c147 = "let",
        peg$c148 = { type: "literal", value: "let", description: "\"let\"" },
        peg$c149 = "stream",
        peg$c150 = { type: "literal", value: "stream", description: "\"stream\"" },
        peg$c151 = ":=",
        peg$c152 = { type: "literal", value: ":=", description: "\":=\"" },
        peg$c153 = "\\",
        peg$c154 = { type: "literal", value: "\\", description: "\"\\\\\"" },
        peg$c155 = "->",
        peg$c156 = { type: "literal", value: "->", description: "\"->\"" },
        peg$c157 = function(name, lambda, stream) {
          return new Ast.Statement.Declaration(name, 'stream', lambda !== null ? lambda[2] : {}, stream);
        },
        peg$c158 = "table",
        peg$c159 = { type: "literal", value: "table", description: "\"table\"" },
        peg$c160 = function(name, lambda, table) {
          return new Ast.Statement.Declaration(name, 'table', lambda !== null ? lambda[2] : {}, table);
        },
        peg$c161 = function(name, lambda, action) {
          return new Ast.Statement.Declaration(name, 'action', lambda !== null ? lambda[2] : {}, action);
        },
        peg$c162 = "return",
        peg$c163 = { type: "literal", value: "return", description: "\"return\"" },
        peg$c164 = function(builtin) {
          return new Ast.Invocation(Ast.Selector.Builtin, builtin, [], null);
        },
        peg$c165 = function(single) { return [single]; },
        peg$c166 = function(actions) {
          return take(actions, 0);
        },
        peg$c167 = function(table, actions) {
          return new Ast.Statement.Command(table, actions);
        },
        peg$c168 = function(actions) {
          return new Ast.Statement.Command(null, actions);
        },
        peg$c169 = function(stream, actions) {
          return new Ast.Statement.Rule(stream, actions);
        },
        peg$c170 = function(fn, in_params, filter) {
            let [selector, function_name] = fn;
            return new Ast.BooleanExpression.External(selector, function_name, in_params, filter, null);
         },
        peg$c171 = function(fn, lhs, rhs) {
            if (fn === 'substr')
                fn = '=~';
            return new Ast.BooleanExpression.Atom(lhs, fn, rhs);
        },
        peg$c172 = function(lhs, op, rhs) {
            return new Ast.BooleanExpression.Atom(lhs, op, rhs);
        },
        peg$c173 = "||",
        peg$c174 = { type: "literal", value: "||", description: "\"||\"" },
        peg$c175 = function(first, rest) {
            if (rest.length === 0)
                return first;
            return new Ast.BooleanExpression.Or([first].concat(take(rest, 3)));
        },
        peg$c176 = "&&",
        peg$c177 = { type: "literal", value: "&&", description: "\"&&\"" },
        peg$c178 = function(first, rest) {
            if (rest.length === 0)
                return first;
            return new Ast.BooleanExpression.And([first].concat(take(rest, 3)));
        },
        peg$c179 = function(or) { return or; },
        peg$c180 = function(v) { return v ? Ast.BooleanExpression.True : Ast.BooleanExpression.False; },
        peg$c181 = "!",
        peg$c182 = { type: "literal", value: "!", description: "\"!\"" },
        peg$c183 = function(bool) { return new Ast.BooleanExpression.Not(bool); },
        peg$c184 = function(name, args) {
          return new Ast.ScalarExpression.Derived(name, args);
        },
        peg$c185 = function(v) {
          return new Ast.ScalarExpression.Primary(v);
        },
        peg$c186 = function(expr) {
          return expr;
        },
        peg$c187 = "+",
        peg$c188 = { type: "literal", value: "+", description: "\"+\"" },
        peg$c189 = "-",
        peg$c190 = { type: "literal", value: "-", description: "\"-\"" },
        peg$c191 = function(first, rest) {
          return rest.reduce(((x, y) => new Ast.ScalarExpression.Derived(y[0], [x, y[2]])), first);
        },
        peg$c192 = "/",
        peg$c193 = { type: "literal", value: "/", description: "\"/\"" },
        peg$c194 = "%",
        peg$c195 = { type: "literal", value: "%", description: "\"%\"" },
        peg$c196 = "**",
        peg$c197 = { type: "literal", value: "**", description: "\"**\"" },
        peg$c198 = function(first, rest) {
          if (rest.length === 0)
            return first;
          else
            return first + '.' + take(rest, 2).join('.');
        },
        peg$c199 = function(name) {
          return Ast.Value.VarRef(name);
        },
        peg$c200 = "$undefined",
        peg$c201 = { type: "literal", value: "$undefined", description: "\"$undefined\"" },
        peg$c202 = "remote",
        peg$c203 = { type: "literal", value: "remote", description: "\"remote\"" },
        peg$c204 = function(remote) {
            return Ast.Value.Undefined(remote === null);
        },
        peg$c205 = function(first, rest) {
          return Ast.Value.CompoundMeasure([first].concat(take(rest, 2)));
        },
        peg$c206 = function(num, unit) { return Ast.Value.Measure(num, unit); },
        peg$c207 = function(v) { return Ast.Value.Number(v); },
        peg$c208 = "makeCurrency",
        peg$c209 = { type: "literal", value: "makeCurrency", description: "\"makeCurrency\"" },
        peg$c210 = function(num, code) {
            return new Ast.Value.Currency(num, code);
        },
        peg$c211 = "makeDate",
        peg$c212 = { type: "literal", value: "makeDate", description: "\"makeDate\"" },
        peg$c213 = function(year, month, day, hours, minutes, seconds) {
            var d = new Date;
            d.setFullYear(year);
            d.setMonth(month-1);
            d.setDate(day);
            d.setHours(hours);
            d.setMinutes(minutes);
            d.setSeconds(seconds);
            return new Ast.Value.Date(d, '+', null);
        },
        peg$c214 = function(year, month, day) {
            var d = new Date;
            d.setFullYear(year);
            d.setMonth(month-1);
            d.setDate(day);
            d.setHours(0);
            d.setMinutes(0);
            d.setSeconds(0);
            return new Ast.Value.Date(d, '+', null);
        },
        peg$c215 = function(unix) {
            var d = new Date;
            d.setTime(unix);
            return new Ast.Value.Date(d, '+', null);
        },
        peg$c216 = function(base, op, offset) {
            return new Ast.Value.Date(base.value, op, offset);
        },
        peg$c217 = function(unit) {
            if (Units.UnitsToBaseUnit[unit] !== 'ms')
                error('Invalid time unit ' + unit);
            return unit;
        },
        peg$c218 = "start_of",
        peg$c219 = { type: "literal", value: "start_of", description: "\"start_of\"" },
        peg$c220 = "end_of",
        peg$c221 = { type: "literal", value: "end_of", description: "\"end_of\"" },
        peg$c222 = function(edge, unit) {
            if (unit === 'ms' || unit === 's')
                error(`${edge}(${unit}) is not allowed (not enough resolution)`);
            return new Ast.Value.Date(Ast.DateEdge(edge, unit), '+', null);
        },
        peg$c223 = function() {
            return Ast.Value.Date(null, '+', null);
        },
        peg$c224 = "makeTime",
        peg$c225 = { type: "literal", value: "makeTime", description: "\"makeTime\"" },
        peg$c226 = function(hour, minute, second) {
            return Ast.Value.Time(hour, minute, second !== null ? second[2] : 0);
        },
        peg$c227 = function(v) { return Ast.Value.Boolean(v); },
        peg$c228 = "makeLocation",
        peg$c229 = { type: "literal", value: "makeLocation", description: "\"makeLocation\"" },
        peg$c230 = function(lat, lon, display) {
            return Ast.Value.Location(Ast.Location.Absolute(lat, lon, display !== null ? display[2] : null));
        },
        peg$c231 = "$context",
        peg$c232 = { type: "literal", value: "$context", description: "\"$context\"" },
        peg$c233 = "location",
        peg$c234 = { type: "literal", value: "location", description: "\"location\"" },
        peg$c235 = "home",
        peg$c236 = { type: "literal", value: "home", description: "\"home\"" },
        peg$c237 = "work",
        peg$c238 = { type: "literal", value: "work", description: "\"work\"" },
        peg$c239 = "current_location",
        peg$c240 = { type: "literal", value: "current_location", description: "\"current_location\"" },
        peg$c241 = function(ctx) {
            return Ast.Value.Location(Ast.Location.Relative(ctx));
        },
        peg$c242 = "enum",
        peg$c243 = { type: "literal", value: "enum", description: "\"enum\"" },
        peg$c244 = function(v) { return Ast.Value.Enum(v); },
        peg$c245 = function(v) { return Ast.Value.String(v);
        },
        peg$c246 = "$event",
        peg$c247 = { type: "literal", value: "$event", description: "\"$event\"" },
        peg$c248 = "type",
        peg$c249 = { type: "literal", value: "type", description: "\"type\"" },
        peg$c250 = "program_id",
        peg$c251 = { type: "literal", value: "program_id", description: "\"program_id\"" },
        peg$c252 = function(evt) {
            return Ast.Value.Event(evt !== null ? evt[2] : null);
        },
        peg$c253 = "^^",
        peg$c254 = { type: "literal", value: "^^", description: "\"^^\"" },
        peg$c255 = function(prefix, entity) {
            return prefix + ':' + entity;
        },
        peg$c256 = function(v, type, display) {
            return Ast.Value.Entity(v, type, display !== null ? display[2] : null);
        },
        peg$c257 = "null",
        peg$c258 = { type: "literal", value: "null", description: "\"null\"" },
        peg$c259 = function(type, display) {
            return Ast.Value.Entity(null, type, display);
        },
        peg$c260 = function(values) {
            return Ast.Value.Array(values || []);
        },
        peg$c261 = "Measure",
        peg$c262 = { type: "literal", value: "Measure", description: "\"Measure\"" },
        peg$c263 = function(unit) { return Type.Measure(unit); },
        peg$c264 = "Array",
        peg$c265 = { type: "literal", value: "Array", description: "\"Array\"" },
        peg$c266 = function(type) { return Type.Array(type); },
        peg$c267 = "Enum",
        peg$c268 = { type: "literal", value: "Enum", description: "\"Enum\"" },
        peg$c269 = function(first, rest) { return Type.Enum([first].concat(take(rest, 2))); },
        peg$c270 = "Entity",
        peg$c271 = { type: "literal", value: "Entity", description: "\"Entity\"" },
        peg$c272 = function(prefix, type) { return Type.Entity(prefix + ':' + type); },
        peg$c273 = "Any",
        peg$c274 = { type: "literal", value: "Any", description: "\"Any\"" },
        peg$c275 = function() { return Type.Any; },
        peg$c276 = "Boolean",
        peg$c277 = { type: "literal", value: "Boolean", description: "\"Boolean\"" },
        peg$c278 = function() { return Type.Boolean; },
        peg$c279 = "String",
        peg$c280 = { type: "literal", value: "String", description: "\"String\"" },
        peg$c281 = function() { return Type.String; },
        peg$c282 = "Number",
        peg$c283 = { type: "literal", value: "Number", description: "\"Number\"" },
        peg$c284 = function() { return Type.Number; },
        peg$c285 = "Currency",
        peg$c286 = { type: "literal", value: "Currency", description: "\"Currency\"" },
        peg$c287 = function() { return Type.Currency; },
        peg$c288 = "Location",
        peg$c289 = { type: "literal", value: "Location", description: "\"Location\"" },
        peg$c290 = function() { return Type.Location; },
        peg$c291 = "Date",
        peg$c292 = { type: "literal", value: "Date", description: "\"Date\"" },
        peg$c293 = function() { return Type.Date; },
        peg$c294 = "Time",
        peg$c295 = { type: "literal", value: "Time", description: "\"Time\"" },
        peg$c296 = function() { return Type.Time; },
        peg$c297 = function(first, rest) { return Type.Tuple([first].concat(take(rest, 2))); },
        peg$c298 = "EmailAddress",
        peg$c299 = { type: "literal", value: "EmailAddress", description: "\"EmailAddress\"" },
        peg$c300 = function() { return Type.Entity('tt:email_address'); },
        peg$c301 = "PhoneNumber",
        peg$c302 = { type: "literal", value: "PhoneNumber", description: "\"PhoneNumber\"" },
        peg$c303 = function() { return Type.Entity('tt:phone_number'); },
        peg$c304 = "Picture",
        peg$c305 = { type: "literal", value: "Picture", description: "\"Picture\"" },
        peg$c306 = function() { return Type.Entity('tt:picture'); },
        peg$c307 = "Resource",
        peg$c308 = { type: "literal", value: "Resource", description: "\"Resource\"" },
        peg$c309 = function() { return Type.Entity('tt:rdf_resource'); },
        peg$c310 = "URL",
        peg$c311 = { type: "literal", value: "URL", description: "\"URL\"" },
        peg$c312 = function() { return Type.Entity('tt:url'); },
        peg$c313 = "Username",
        peg$c314 = { type: "literal", value: "Username", description: "\"Username\"" },
        peg$c315 = function() { return Type.Entity('tt:username'); },
        peg$c316 = "Hashtag",
        peg$c317 = { type: "literal", value: "Hashtag", description: "\"Hashtag\"" },
        peg$c318 = function() { return Type.Entity('tt:hashtag'); },
        peg$c319 = "Table",
        peg$c320 = { type: "literal", value: "Table", description: "\"Table\"" },
        peg$c321 = function() { return Type.Table; },
        peg$c322 = "Stream",
        peg$c323 = { type: "literal", value: "Stream", description: "\"Stream\"" },
        peg$c324 = function() { return Type.Stream; },
        peg$c325 = function(invalid) { throw new TypeError("Invalid type " + invalid); },
        peg$c326 = { type: "other", description: "comparison operator" },
        peg$c327 = ">=",
        peg$c328 = { type: "literal", value: ">=", description: "\">=\"" },
        peg$c329 = "<=",
        peg$c330 = { type: "literal", value: "<=", description: "\"<=\"" },
        peg$c331 = "=~",
        peg$c332 = { type: "literal", value: "=~", description: "\"=~\"" },
        peg$c333 = "~=",
        peg$c334 = { type: "literal", value: "~=", description: "\"~=\"" },
        peg$c335 = "==",
        peg$c336 = { type: "literal", value: "==", description: "\"==\"" },
        peg$c337 = "true",
        peg$c338 = { type: "literal", value: "true", description: "\"true\"" },
        peg$c339 = function() { return true; },
        peg$c340 = "false",
        peg$c341 = { type: "literal", value: "false", description: "\"false\"" },
        peg$c342 = function() { return false; },
        peg$c343 = /^[^\\"]/,
        peg$c344 = { type: "class", value: "[^\\\\\\\"]", description: "[^\\\\\\\"]" },
        peg$c345 = "\\\"",
        peg$c346 = { type: "literal", value: "\\\"", description: "\"\\\\\\\"\"" },
        peg$c347 = function() { return '"'; },
        peg$c348 = "\\n",
        peg$c349 = { type: "literal", value: "\\n", description: "\"\\\\n\"" },
        peg$c350 = function() { return '\n'; },
        peg$c351 = "\\'",
        peg$c352 = { type: "literal", value: "\\'", description: "\"\\\\'\"" },
        peg$c353 = function() { return '\''; },
        peg$c354 = "\\\\",
        peg$c355 = { type: "literal", value: "\\\\", description: "\"\\\\\\\\\"" },
        peg$c356 = function() { return '\\'; },
        peg$c357 = /^[^\\']/,
        peg$c358 = { type: "class", value: "[^\\\\\\']", description: "[^\\\\\\']" },
        peg$c359 = { type: "other", description: "string" },
        peg$c360 = "\"",
        peg$c361 = { type: "literal", value: "\"", description: "\"\\\"\"" },
        peg$c362 = function(chars) { return chars.join(''); },
        peg$c363 = "'",
        peg$c364 = { type: "literal", value: "'", description: "\"'\"" },
        peg$c365 = { type: "other", description: "digit" },
        peg$c366 = /^[0-9]/,
        peg$c367 = { type: "class", value: "[0-9]", description: "[0-9]" },
        peg$c368 = { type: "other", description: "number" },
        peg$c369 = "e",
        peg$c370 = { type: "literal", value: "e", description: "\"e\"" },
        peg$c371 = function(num) { return parseFloat(num); },
        peg$c372 = /^[A-Za-z_]/,
        peg$c373 = { type: "class", value: "[A-Za-z_]", description: "[A-Za-z_]" },
        peg$c374 = /^[A-Za-z0-9_]/,
        peg$c375 = { type: "class", value: "[A-Za-z0-9_]", description: "[A-Za-z0-9_]" },
        peg$c376 = { type: "other", description: "identifier" },
        peg$c377 = function(v) {
          // for debugging the prettyprinter
          if (v === 'undefined')
            throw new Error('Invalid undefined');
          return v;
        },
        peg$c378 = /^[A-Za-z0-9_\-]/,
        peg$c379 = { type: "class", value: "[A-Za-z0-9_-]", description: "[A-Za-z0-9_-]" },
        peg$c380 = { type: "other", description: "classidentifier" },
        peg$c381 = { type: "other", description: "whitespace" },
        peg$c382 = /^[ \r\n\t\x0B]/,
        peg$c383 = { type: "class", value: "[ \\r\\n\\t\\v]", description: "[ \\r\\n\\t\\v]" },
        peg$c384 = { type: "other", description: "comment" },
        peg$c385 = "/*",
        peg$c386 = { type: "literal", value: "/*", description: "\"/*\"" },
        peg$c387 = /^[^*]/,
        peg$c388 = { type: "class", value: "[^*]", description: "[^*]" },
        peg$c389 = /^[^\/]/,
        peg$c390 = { type: "class", value: "[^/]", description: "[^/]" },
        peg$c391 = "*/",
        peg$c392 = { type: "literal", value: "*/", description: "\"*/\"" },
        peg$c393 = "//",
        peg$c394 = { type: "literal", value: "//", description: "\"//\"" },
        peg$c395 = /^[^\n]/,
        peg$c396 = { type: "class", value: "[^\\n]", description: "[^\\n]" },
        peg$c397 = "\n",
        peg$c398 = { type: "literal", value: "\n", description: "\"\\n\"" },

        peg$currPos          = 0,
        peg$savedPos         = 0,
        peg$posDetailsCache  = [{ line: 1, column: 1, seenCR: false }],
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$savedPos, peg$currPos);
    }

    function location() {
      return peg$computeLocation(peg$savedPos, peg$currPos);
    }

    function expected(description) {
      throw peg$buildException(
        null,
        [{ type: "other", description: description }],
        input.substring(peg$savedPos, peg$currPos),
        peg$computeLocation(peg$savedPos, peg$currPos)
      );
    }

    function error(message) {
      throw peg$buildException(
        message,
        null,
        input.substring(peg$savedPos, peg$currPos),
        peg$computeLocation(peg$savedPos, peg$currPos)
      );
    }

    function peg$computePosDetails(pos) {
      var details = peg$posDetailsCache[pos],
          p, ch;

      if (details) {
        return details;
      } else {
        p = pos - 1;
        while (!peg$posDetailsCache[p]) {
          p--;
        }

        details = peg$posDetailsCache[p];
        details = {
          line:   details.line,
          column: details.column,
          seenCR: details.seenCR
        };

        while (p < pos) {
          ch = input.charAt(p);
          if (ch === "\n") {
            if (!details.seenCR) { details.line++; }
            details.column = 1;
            details.seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            details.line++;
            details.column = 1;
            details.seenCR = true;
          } else {
            details.column++;
            details.seenCR = false;
          }

          p++;
        }

        peg$posDetailsCache[pos] = details;
        return details;
      }
    }

    function peg$computeLocation(startPos, endPos) {
      var startPosDetails = peg$computePosDetails(startPos),
          endPosDetails   = peg$computePosDetails(endPos);

      return {
        start: {
          offset: startPos,
          line:   startPosDetails.line,
          column: startPosDetails.column
        },
        end: {
          offset: endPos,
          line:   endPosDetails.line,
          column: endPosDetails.column
        }
      };
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildException(message, expected, found, location) {
      function cleanupExpected(expected) {
        var i = 1;

        expected.sort(function(a, b) {
          if (a.description < b.description) {
            return -1;
          } else if (a.description > b.description) {
            return 1;
          } else {
            return 0;
          }
        });

        while (i < expected.length) {
          if (expected[i - 1] === expected[i]) {
            expected.splice(i, 1);
          } else {
            i++;
          }
        }
      }

      function buildMessage(expected, found) {
        function stringEscape(s) {
          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

          return s
            .replace(/\\/g,   '\\\\')
            .replace(/"/g,    '\\"')
            .replace(/\x08/g, '\\b')
            .replace(/\t/g,   '\\t')
            .replace(/\n/g,   '\\n')
            .replace(/\f/g,   '\\f')
            .replace(/\r/g,   '\\r')
            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
            .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
            .replace(/[\u0100-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
            .replace(/[\u1000-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
        }

        var expectedDescs = new Array(expected.length),
            expectedDesc, foundDesc, i;

        for (i = 0; i < expected.length; i++) {
          expectedDescs[i] = expected[i].description;
        }

        expectedDesc = expected.length > 1
          ? expectedDescs.slice(0, -1).join(", ")
              + " or "
              + expectedDescs[expected.length - 1]
          : expectedDescs[0];

        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
      }

      if (expected !== null) {
        cleanupExpected(expected);
      }

      return new peg$SyntaxError(
        message !== null ? message : buildMessage(expected, found),
        expected,
        found,
        location
      );
    }

    function peg$parseinput() {
      var s0;

      s0 = peg$parseprogram();
      if (s0 === peg$FAILED) {
        s0 = peg$parsepermission_rule();
      }

      return s0;
    }

    function peg$parseprogram_principal() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 8) === peg$c0) {
        s1 = peg$c0;
        peg$currPos += 8;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c1); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s3 = peg$c2;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c3); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.substr(peg$currPos, 4) === peg$c4) {
                s5 = peg$c4;
                peg$currPos += 4;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c5); }
              }
              if (s5 === peg$FAILED) {
                s5 = peg$parsevar_ref_value();
                if (s5 === peg$FAILED) {
                  s5 = peg$parseentity_value();
                  if (s5 === peg$FAILED) {
                    s5 = peg$parsestring_value();
                  }
                }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 58) {
                    s7 = peg$c6;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c7); }
                  }
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c8(s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseprogram() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseprogram_principal();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 123) {
              s4 = peg$c9;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c10); }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s6 = [];
                s7 = peg$currPos;
                s8 = peg$parseclass_def();
                if (s8 !== peg$FAILED) {
                  s9 = peg$parse_();
                  if (s9 !== peg$FAILED) {
                    s8 = [s8, s9];
                    s7 = s8;
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
                while (s7 !== peg$FAILED) {
                  s6.push(s7);
                  s7 = peg$currPos;
                  s8 = peg$parseclass_def();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parse_();
                    if (s9 !== peg$FAILED) {
                      s8 = [s8, s9];
                      s7 = s8;
                    } else {
                      peg$currPos = s7;
                      s7 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    s8 = [];
                    s9 = peg$currPos;
                    s10 = peg$parsedeclaration();
                    if (s10 !== peg$FAILED) {
                      s11 = peg$parse_();
                      if (s11 !== peg$FAILED) {
                        s10 = [s10, s11];
                        s9 = s10;
                      } else {
                        peg$currPos = s9;
                        s9 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s9;
                      s9 = peg$FAILED;
                    }
                    while (s9 !== peg$FAILED) {
                      s8.push(s9);
                      s9 = peg$currPos;
                      s10 = peg$parsedeclaration();
                      if (s10 !== peg$FAILED) {
                        s11 = peg$parse_();
                        if (s11 !== peg$FAILED) {
                          s10 = [s10, s11];
                          s9 = s10;
                        } else {
                          peg$currPos = s9;
                          s9 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s9;
                        s9 = peg$FAILED;
                      }
                    }
                    if (s8 !== peg$FAILED) {
                      s9 = [];
                      s10 = peg$currPos;
                      s11 = peg$parserule();
                      if (s11 !== peg$FAILED) {
                        s12 = peg$parse_();
                        if (s12 !== peg$FAILED) {
                          s11 = [s11, s12];
                          s10 = s11;
                        } else {
                          peg$currPos = s10;
                          s10 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s10;
                        s10 = peg$FAILED;
                      }
                      while (s10 !== peg$FAILED) {
                        s9.push(s10);
                        s10 = peg$currPos;
                        s11 = peg$parserule();
                        if (s11 !== peg$FAILED) {
                          s12 = peg$parse_();
                          if (s12 !== peg$FAILED) {
                            s11 = [s11, s12];
                            s10 = s11;
                          } else {
                            peg$currPos = s10;
                            s10 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s10;
                          s10 = peg$FAILED;
                        }
                      }
                      if (s9 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 125) {
                          s10 = peg$c11;
                          peg$currPos++;
                        } else {
                          s10 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c12); }
                        }
                        if (s10 !== peg$FAILED) {
                          s11 = peg$parse_();
                          if (s11 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c13(s2, s6, s8, s9);
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parse_();
        if (s1 !== peg$FAILED) {
          s2 = peg$parseprogram_principal();
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            if (s3 !== peg$FAILED) {
              s4 = peg$parsedeclaration();
              if (s4 === peg$FAILED) {
                s4 = peg$parserule();
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parse_();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c14(s2, s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }

      return s0;
    }

    function peg$parsepermission_function() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseclass_name();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 46) {
            s3 = peg$c15;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c16); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 42) {
                s5 = peg$c17;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c18); }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c19(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseshort_function_name();
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 44) {
              s4 = peg$c20;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c21); }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseor_expr();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    s4 = [s4, s5, s6, s7];
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            if (s3 === peg$FAILED) {
              s3 = null;
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c22(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 42) {
            s1 = peg$c17;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c18); }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c23();
          }
          s0 = s1;
        }
      }

      return s0;
    }

    function peg$parsepermission_rule() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseor_expr();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s4 = peg$c6;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c7); }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s6 = peg$parsepermission_function();
                if (s6 === peg$FAILED) {
                  if (input.substr(peg$currPos, 3) === peg$c24) {
                    s6 = peg$c24;
                    peg$currPos += 3;
                  } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c25); }
                  }
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    if (input.substr(peg$currPos, 2) === peg$c26) {
                      s8 = peg$c26;
                      peg$currPos += 2;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c27); }
                    }
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parse_();
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parsepermission_function();
                        if (s10 === peg$FAILED) {
                          if (input.substr(peg$currPos, 6) === peg$c28) {
                            s10 = peg$c28;
                            peg$currPos += 6;
                          } else {
                            s10 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c29); }
                          }
                        }
                        if (s10 !== peg$FAILED) {
                          s11 = peg$parse_();
                          if (s11 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 59) {
                              s12 = peg$c30;
                              peg$currPos++;
                            } else {
                              s12 = peg$FAILED;
                              if (peg$silentFails === 0) { peg$fail(peg$c31); }
                            }
                            if (s12 === peg$FAILED) {
                              s12 = null;
                            }
                            if (s12 !== peg$FAILED) {
                              peg$savedPos = s0;
                              s1 = peg$c32(s2, s6, s10);
                              s0 = s1;
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsefull_class_name() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 64) {
        s1 = peg$c33;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c34); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseclassident();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 46) {
              s6 = peg$c15;
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c16); }
            }
            if (s6 !== peg$FAILED) {
              s7 = peg$parse_();
              if (s7 !== peg$FAILED) {
                s8 = peg$parseclassident();
                if (s8 !== peg$FAILED) {
                  s9 = peg$parse_();
                  if (s9 !== peg$FAILED) {
                    s10 = peg$currPos;
                    peg$silentFails++;
                    s11 = peg$currPos;
                    s12 = peg$parse_();
                    if (s12 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 40) {
                        s13 = peg$c35;
                        peg$currPos++;
                      } else {
                        s13 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c36); }
                      }
                      if (s13 === peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 44) {
                          s13 = peg$c20;
                          peg$currPos++;
                        } else {
                          s13 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c21); }
                        }
                        if (s13 === peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 41) {
                            s13 = peg$c37;
                            peg$currPos++;
                          } else {
                            s13 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c38); }
                          }
                          if (s13 === peg$FAILED) {
                            if (input.substr(peg$currPos, 2) === peg$c26) {
                              s13 = peg$c26;
                              peg$currPos += 2;
                            } else {
                              s13 = peg$FAILED;
                              if (peg$silentFails === 0) { peg$fail(peg$c27); }
                            }
                          }
                        }
                      }
                      if (s13 !== peg$FAILED) {
                        s12 = [s12, s13];
                        s11 = s12;
                      } else {
                        peg$currPos = s11;
                        s11 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s11;
                      s11 = peg$FAILED;
                    }
                    peg$silentFails--;
                    if (s11 === peg$FAILED) {
                      s10 = void 0;
                    } else {
                      peg$currPos = s10;
                      s10 = peg$FAILED;
                    }
                    if (s10 !== peg$FAILED) {
                      s6 = [s6, s7, s8, s9, s10];
                      s5 = s6;
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 46) {
                s6 = peg$c15;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c16); }
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$parse_();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parseclassident();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parse_();
                    if (s9 !== peg$FAILED) {
                      s10 = peg$currPos;
                      peg$silentFails++;
                      s11 = peg$currPos;
                      s12 = peg$parse_();
                      if (s12 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 40) {
                          s13 = peg$c35;
                          peg$currPos++;
                        } else {
                          s13 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c36); }
                        }
                        if (s13 === peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 44) {
                            s13 = peg$c20;
                            peg$currPos++;
                          } else {
                            s13 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c21); }
                          }
                          if (s13 === peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 41) {
                              s13 = peg$c37;
                              peg$currPos++;
                            } else {
                              s13 = peg$FAILED;
                              if (peg$silentFails === 0) { peg$fail(peg$c38); }
                            }
                            if (s13 === peg$FAILED) {
                              if (input.substr(peg$currPos, 2) === peg$c26) {
                                s13 = peg$c26;
                                peg$currPos += 2;
                              } else {
                                s13 = peg$FAILED;
                                if (peg$silentFails === 0) { peg$fail(peg$c27); }
                              }
                            }
                          }
                        }
                        if (s13 !== peg$FAILED) {
                          s12 = [s12, s13];
                          s11 = s12;
                        } else {
                          peg$currPos = s11;
                          s11 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s11;
                        s11 = peg$FAILED;
                      }
                      peg$silentFails--;
                      if (s11 === peg$FAILED) {
                        s10 = void 0;
                      } else {
                        peg$currPos = s10;
                        s10 = peg$FAILED;
                      }
                      if (s10 !== peg$FAILED) {
                        s6 = [s6, s7, s8, s9, s10];
                        s5 = s6;
                      } else {
                        peg$currPos = s5;
                        s5 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c39(s2, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseclass_name() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 64) {
        s1 = peg$c33;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c34); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseclassident();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 46) {
              s6 = peg$c15;
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c16); }
            }
            if (s6 !== peg$FAILED) {
              s7 = peg$parse_();
              if (s7 !== peg$FAILED) {
                s8 = peg$parseclassident();
                if (s8 !== peg$FAILED) {
                  s9 = peg$parse_();
                  if (s9 !== peg$FAILED) {
                    s6 = [s6, s7, s8, s9];
                    s5 = s6;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 46) {
                s6 = peg$c15;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c16); }
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$parse_();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parseclassident();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parse_();
                    if (s9 !== peg$FAILED) {
                      s6 = [s6, s7, s8, s9];
                      s5 = s6;
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c39(s2, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseclass_def() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 5) === peg$c40) {
        s1 = peg$c40;
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c41); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseclass_name();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.substr(peg$currPos, 7) === peg$c42) {
                s5 = peg$c42;
                peg$currPos += 7;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c43); }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse__();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parsefull_class_name();
                  if (s7 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 123) {
                      s8 = peg$c9;
                      peg$currPos++;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c10); }
                    }
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parse_();
                      if (s9 !== peg$FAILED) {
                        s10 = [];
                        s11 = peg$parseclass_member();
                        while (s11 !== peg$FAILED) {
                          s10.push(s11);
                          s11 = peg$parseclass_member();
                        }
                        if (s10 !== peg$FAILED) {
                          s11 = peg$parse_();
                          if (s11 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 125) {
                              s12 = peg$c11;
                              peg$currPos++;
                            } else {
                              s12 = peg$FAILED;
                              if (peg$silentFails === 0) { peg$fail(peg$c12); }
                            }
                            if (s12 !== peg$FAILED) {
                              peg$savedPos = s0;
                              s1 = peg$c44(s3, s7, s10);
                              s0 = s1;
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseclass_member() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 5) === peg$c45) {
        s1 = peg$c45;
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c46); }
      }
      if (s1 === peg$FAILED) {
        if (input.substr(peg$currPos, 6) === peg$c47) {
          s1 = peg$c47;
          peg$currPos += 6;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c48); }
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseident();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsefunction_param_decl_list();
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 59) {
                    s7 = peg$c30;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c31); }
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse_();
                    if (s8 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c49(s1, s3, s5);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsefunction_param_decl_list() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 40) {
        s1 = peg$c35;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c36); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 41) {
            s3 = peg$c37;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c38); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c50();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 40) {
          s1 = peg$c35;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c36); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parsefunction_param_decl();
            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 44) {
                  s7 = peg$c20;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c21); }
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parsefunction_param_decl();
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse_();
                      if (s10 !== peg$FAILED) {
                        s7 = [s7, s8, s9, s10];
                        s6 = s7;
                      } else {
                        peg$currPos = s6;
                        s6 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$currPos;
                  if (input.charCodeAt(peg$currPos) === 44) {
                    s7 = peg$c20;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c21); }
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse_();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parsefunction_param_decl();
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parse_();
                        if (s10 !== peg$FAILED) {
                          s7 = [s7, s8, s9, s10];
                          s6 = s7;
                        } else {
                          peg$currPos = s6;
                          s6 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s6;
                        s6 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                }
                if (s5 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s6 = peg$c37;
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c38); }
                  }
                  if (s6 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c51(s3, s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }

      return s0;
    }

    function peg$parsefunction_param_decl() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseparam_direction();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseident();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 58) {
                s5 = peg$c6;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c7); }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parsetype_ref();
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c52(s1, s3, s7);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseparam_direction() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c53) {
        s1 = peg$c53;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c54); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          if (input.substr(peg$currPos, 3) === peg$c55) {
            s3 = peg$c55;
            peg$currPos += 3;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c56); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c57();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c53) {
          s1 = peg$c53;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c54); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse__();
          if (s2 !== peg$FAILED) {
            if (input.substr(peg$currPos, 3) === peg$c58) {
              s3 = peg$c58;
              peg$currPos += 3;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c59); }
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c60();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 3) === peg$c61) {
            s1 = peg$c61;
            peg$currPos += 3;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c62); }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c63();
          }
          s0 = s1;
        }
      }

      return s0;
    }

    function peg$parsedevice_selector() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseclass_name();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 40) {
            s3 = peg$c35;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c36); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsedevice_attribute_list();
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s7 = peg$c37;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c38); }
                  }
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c64(s1, s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsedevice_attribute_list() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

      s0 = peg$currPos;
      s1 = peg$parsedevice_id();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 44) {
            s5 = peg$c20;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c21); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parsedevice_id();
              if (s7 !== peg$FAILED) {
                s8 = peg$parse_();
                if (s8 !== peg$FAILED) {
                  s5 = [s5, s6, s7, s8];
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c20;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c21); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsedevice_id();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    s5 = [s5, s6, s7, s8];
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c65(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsedevice_id() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c66) {
        s1 = peg$c66;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c67); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s3 = peg$c2;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c3); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsestring_value();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c68(s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseshort_function_name() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 64) {
        s1 = peg$c33;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c34); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseclassident();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 46) {
              s6 = peg$c15;
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c16); }
            }
            if (s6 !== peg$FAILED) {
              s7 = peg$parse_();
              if (s7 !== peg$FAILED) {
                s8 = peg$parseclassident();
                if (s8 !== peg$FAILED) {
                  s9 = peg$parse_();
                  if (s9 !== peg$FAILED) {
                    s6 = [s6, s7, s8, s9];
                    s5 = s6;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 46) {
                  s6 = peg$c15;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c16); }
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parseclassident();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parse_();
                      if (s9 !== peg$FAILED) {
                        s6 = [s6, s7, s8, s9];
                        s5 = s6;
                      } else {
                        peg$currPos = s5;
                        s5 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              }
            } else {
              s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c69(s2, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsefull_function_name() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parsedevice_selector();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 46) {
            s3 = peg$c15;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c16); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseident();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c70(s1, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseinput_param() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseident();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s3 = peg$c2;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c3); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsevalue();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c71(s1, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseinput_param_list() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 40) {
        s1 = peg$c35;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c36); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 41) {
            s3 = peg$c37;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c38); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c72();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 40) {
          s1 = peg$c35;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c36); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseinput_param();
            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 44) {
                  s7 = peg$c20;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c21); }
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parseinput_param();
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse_();
                      if (s10 !== peg$FAILED) {
                        s7 = [s7, s8, s9, s10];
                        s6 = s7;
                      } else {
                        peg$currPos = s6;
                        s6 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$currPos;
                  if (input.charCodeAt(peg$currPos) === 44) {
                    s7 = peg$c20;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c21); }
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse_();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseinput_param();
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parse_();
                        if (s10 !== peg$FAILED) {
                          s7 = [s7, s8, s9, s10];
                          s6 = s7;
                        } else {
                          peg$currPos = s6;
                          s6 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s6;
                        s6 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                }
                if (s5 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s6 = peg$c37;
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c38); }
                  }
                  if (s6 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c51(s3, s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }

      return s0;
    }

    function peg$parsethingpedia_function_name() {
      var s0;

      s0 = peg$parsefull_function_name();
      if (s0 === peg$FAILED) {
        s0 = peg$parseshort_function_name();
      }

      return s0;
    }

    function peg$parsethingpedia_function_call() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parsethingpedia_function_name();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseinput_param_list();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c73(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsetable_ref() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseident();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseinput_param_list();
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c74(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseprimary_table() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parsethingpedia_function_call();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c75(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 40) {
          s1 = peg$c35;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c36); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parsetable();
            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();
              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 41) {
                  s5 = peg$c37;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c38); }
                }
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c76(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$parsetable_projection();
          if (s0 === peg$FAILED) {
            s0 = peg$parsewindow_expression();
            if (s0 === peg$FAILED) {
              s0 = peg$parsehistory_expression();
              if (s0 === peg$FAILED) {
                s0 = peg$parseargmin_max_expression();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseaggregate_expression();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parsecomputed_table();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parsetable_ref();
                    }
                  }
                }
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parsetable_projection() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 91) {
        s1 = peg$c77;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c78); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseident();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = [];
              s6 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 44) {
                s7 = peg$c20;
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c21); }
              }
              if (s7 !== peg$FAILED) {
                s8 = peg$parse_();
                if (s8 !== peg$FAILED) {
                  s9 = peg$parseident();
                  if (s9 !== peg$FAILED) {
                    s10 = peg$parse_();
                    if (s10 !== peg$FAILED) {
                      s7 = [s7, s8, s9, s10];
                      s6 = s7;
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 44) {
                  s7 = peg$c20;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c21); }
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parseident();
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse_();
                      if (s10 !== peg$FAILED) {
                        s7 = [s7, s8, s9, s10];
                        s6 = s7;
                      } else {
                        peg$currPos = s6;
                        s6 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 93) {
                    s7 = peg$c79;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c80); }
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse_();
                    if (s8 !== peg$FAILED) {
                      if (input.substr(peg$currPos, 2) === peg$c81) {
                        s9 = peg$c81;
                        peg$currPos += 2;
                      } else {
                        s9 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c82); }
                      }
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parse__();
                        if (s10 !== peg$FAILED) {
                          s11 = peg$parsealias_table();
                          if (s11 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c83(s3, s5, s11);
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsecomputed_table() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 7) === peg$c84) {
        s1 = peg$c84;
        peg$currPos += 7;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c85); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseprimary_scalar_expression();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c86) {
                s6 = peg$c86;
                peg$currPos += 2;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c87); }
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$parse__();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parseident();
                  if (s8 !== peg$FAILED) {
                    s6 = [s6, s7, s8];
                    s5 = s6;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              if (s5 === peg$FAILED) {
                s5 = null;
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                if (s6 !== peg$FAILED) {
                  if (input.substr(peg$currPos, 2) === peg$c81) {
                    s7 = peg$c81;
                    peg$currPos += 2;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c82); }
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse__();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parsealias_table();
                      if (s9 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c88(s3, s5, s9);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsewindow_expression() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 6) === peg$c89) {
        s1 = peg$c89;
        peg$currPos += 6;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c90); }
      }
      if (s1 === peg$FAILED) {
        if (input.substr(peg$currPos, 10) === peg$c91) {
          s1 = peg$c91;
          peg$currPos += 10;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c92); }
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsevalue();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 44) {
                s5 = peg$c20;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c21); }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parsevalue();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse_();
                    if (s8 !== peg$FAILED) {
                      if (input.substr(peg$currPos, 2) === peg$c81) {
                        s9 = peg$c81;
                        peg$currPos += 2;
                      } else {
                        s9 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c82); }
                      }
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parse__();
                        if (s10 !== peg$FAILED) {
                          s11 = peg$parsealias_stream();
                          if (s11 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c93(s1, s3, s7, s11);
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsehistory_expression() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 8) === peg$c94) {
        s1 = peg$c94;
        peg$currPos += 8;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c95); }
      }
      if (s1 === peg$FAILED) {
        if (input.substr(peg$currPos, 7) === peg$c96) {
          s1 = peg$c96;
          peg$currPos += 7;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c97); }
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsevalue();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 44) {
                s5 = peg$c20;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c21); }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parsevalue();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse_();
                    if (s8 !== peg$FAILED) {
                      if (input.substr(peg$currPos, 2) === peg$c81) {
                        s9 = peg$c81;
                        peg$currPos += 2;
                      } else {
                        s9 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c82); }
                      }
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parse__();
                        if (s10 !== peg$FAILED) {
                          s11 = peg$parsealias_table();
                          if (s11 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c98(s1, s3, s7, s11);
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseargmin_max_expression() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 9) === peg$c99) {
        s1 = peg$c99;
        peg$currPos += 9;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c100); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          if (input.substr(peg$currPos, 6) === peg$c101) {
            s3 = peg$c101;
            peg$currPos += 6;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c102); }
          }
          if (s3 === peg$FAILED) {
            if (input.substr(peg$currPos, 6) === peg$c103) {
              s3 = peg$c103;
              peg$currPos += 6;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c104); }
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsevalue();
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 44) {
                    s7 = peg$c20;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c21); }
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse_();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parsevalue();
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parse_();
                        if (s10 !== peg$FAILED) {
                          s11 = peg$parseident();
                          if (s11 !== peg$FAILED) {
                            s12 = peg$parse_();
                            if (s12 !== peg$FAILED) {
                              if (input.substr(peg$currPos, 2) === peg$c81) {
                                s13 = peg$c81;
                                peg$currPos += 2;
                              } else {
                                s13 = peg$FAILED;
                                if (peg$silentFails === 0) { peg$fail(peg$c82); }
                              }
                              if (s13 !== peg$FAILED) {
                                s14 = peg$parse__();
                                if (s14 !== peg$FAILED) {
                                  s15 = peg$parsealias_table();
                                  if (s15 !== peg$FAILED) {
                                    peg$savedPos = s0;
                                    s1 = peg$c105(s3, s5, s9, s11, s15);
                                    s0 = s1;
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseaggregate_expression() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 9) === peg$c99) {
        s1 = peg$c99;
        peg$currPos += 9;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c100); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          if (input.substr(peg$currPos, 5) === peg$c106) {
            s3 = peg$c106;
            peg$currPos += 5;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c107); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse__();
            if (s4 !== peg$FAILED) {
              s5 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c86) {
                s6 = peg$c86;
                peg$currPos += 2;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c87); }
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$parse_();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parseident();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parse_();
                    if (s9 !== peg$FAILED) {
                      s6 = [s6, s7, s8, s9];
                      s5 = s6;
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              if (s5 === peg$FAILED) {
                s5 = null;
              }
              if (s5 !== peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c81) {
                  s6 = peg$c81;
                  peg$currPos += 2;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c82); }
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse__();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parsealias_table();
                    if (s8 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c108(s5, s8);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 9) === peg$c99) {
          s1 = peg$c99;
          peg$currPos += 9;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c100); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse__();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseident();
            if (s3 !== peg$FAILED) {
              s4 = peg$parse__();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseident();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parse_();
                  if (s6 !== peg$FAILED) {
                    s7 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c86) {
                      s8 = peg$c86;
                      peg$currPos += 2;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c87); }
                    }
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parse_();
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parseident();
                        if (s10 !== peg$FAILED) {
                          s11 = peg$parse_();
                          if (s11 !== peg$FAILED) {
                            s8 = [s8, s9, s10, s11];
                            s7 = s8;
                          } else {
                            peg$currPos = s7;
                            s7 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s7;
                          s7 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s7;
                        s7 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s7;
                      s7 = peg$FAILED;
                    }
                    if (s7 === peg$FAILED) {
                      s7 = null;
                    }
                    if (s7 !== peg$FAILED) {
                      if (input.substr(peg$currPos, 2) === peg$c81) {
                        s8 = peg$c81;
                        peg$currPos += 2;
                      } else {
                        s8 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c82); }
                      }
                      if (s8 !== peg$FAILED) {
                        s9 = peg$parse__();
                        if (s9 !== peg$FAILED) {
                          s10 = peg$parsealias_table();
                          if (s10 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c109(s3, s5, s7, s10);
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }

      return s0;
    }

    function peg$parsealias_table() {
      var s0, s1, s2, s3, s4, s5, s6;

      s0 = peg$currPos;
      s1 = peg$parseprimary_table();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c86) {
            s4 = peg$c86;
            peg$currPos += 2;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c87); }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parse__();
            if (s5 !== peg$FAILED) {
              s6 = peg$parseident();
              if (s6 !== peg$FAILED) {
                s4 = [s4, s5, s6];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c110(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsefiltered_table() {
      var s0, s1, s2, s3, s4, s5, s6;

      s0 = peg$currPos;
      s1 = peg$parsealias_table();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s4 = peg$c20;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c21); }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            if (s5 !== peg$FAILED) {
              s6 = peg$parseor_expr();
              if (s6 !== peg$FAILED) {
                s3 = [s3, s4, s5, s6];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c111(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsetable() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;

      s0 = peg$currPos;
      s1 = peg$parsefiltered_table();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c112) {
            s5 = peg$c112;
            peg$currPos += 4;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c113); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parsefiltered_table();
              if (s7 !== peg$FAILED) {
                s8 = peg$parse_();
                if (s8 !== peg$FAILED) {
                  s9 = peg$currPos;
                  if (input.substr(peg$currPos, 2) === peg$c114) {
                    s10 = peg$c114;
                    peg$currPos += 2;
                  } else {
                    s10 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c115); }
                  }
                  if (s10 !== peg$FAILED) {
                    s11 = peg$parse_();
                    if (s11 !== peg$FAILED) {
                      s12 = peg$parseinput_param_list();
                      if (s12 !== peg$FAILED) {
                        s13 = peg$parse_();
                        if (s13 !== peg$FAILED) {
                          s10 = [s10, s11, s12, s13];
                          s9 = s10;
                        } else {
                          peg$currPos = s9;
                          s9 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s9;
                        s9 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s9;
                      s9 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s9;
                    s9 = peg$FAILED;
                  }
                  if (s9 === peg$FAILED) {
                    s9 = null;
                  }
                  if (s9 !== peg$FAILED) {
                    s5 = [s5, s6, s7, s8, s9];
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$currPos;
            if (input.substr(peg$currPos, 4) === peg$c112) {
              s5 = peg$c112;
              peg$currPos += 4;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c113); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsefiltered_table();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c114) {
                      s10 = peg$c114;
                      peg$currPos += 2;
                    } else {
                      s10 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c115); }
                    }
                    if (s10 !== peg$FAILED) {
                      s11 = peg$parse_();
                      if (s11 !== peg$FAILED) {
                        s12 = peg$parseinput_param_list();
                        if (s12 !== peg$FAILED) {
                          s13 = peg$parse_();
                          if (s13 !== peg$FAILED) {
                            s10 = [s10, s11, s12, s13];
                            s9 = s10;
                          } else {
                            peg$currPos = s9;
                            s9 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s9;
                          s9 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s9;
                        s9 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s9;
                      s9 = peg$FAILED;
                    }
                    if (s9 === peg$FAILED) {
                      s9 = null;
                    }
                    if (s9 !== peg$FAILED) {
                      s5 = [s5, s6, s7, s8, s9];
                      s4 = s5;
                    } else {
                      peg$currPos = s4;
                      s4 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c116(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsestream_ref() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseident();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseinput_param_list();
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c117(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseprimary_stream() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$parsetimer();
      if (s0 === peg$FAILED) {
        s0 = peg$parseattimer();
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 40) {
            s1 = peg$c35;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c36); }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
              s3 = peg$parsestream();
              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s5 = peg$c37;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c38); }
                  }
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c118(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$parseedge_trigger();
            if (s0 === peg$FAILED) {
              s0 = peg$parsemonitor_stream();
              if (s0 === peg$FAILED) {
                s0 = peg$parsestream_projection();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsecomputed_stream();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parsestream_ref();
                  }
                }
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parsetimer() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17, s18, s19;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 5) === peg$c119) {
        s1 = peg$c119;
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c120); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 40) {
            s3 = peg$c35;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c36); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.substr(peg$currPos, 4) === peg$c121) {
                s5 = peg$c121;
                peg$currPos += 4;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c122); }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 61) {
                    s7 = peg$c2;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c3); }
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse_();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseundefined_value();
                      if (s9 === peg$FAILED) {
                        s9 = peg$parsedate_value();
                      }
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parse_();
                        if (s10 !== peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 44) {
                            s11 = peg$c20;
                            peg$currPos++;
                          } else {
                            s11 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c21); }
                          }
                          if (s11 !== peg$FAILED) {
                            s12 = peg$parse_();
                            if (s12 !== peg$FAILED) {
                              if (input.substr(peg$currPos, 8) === peg$c123) {
                                s13 = peg$c123;
                                peg$currPos += 8;
                              } else {
                                s13 = peg$FAILED;
                                if (peg$silentFails === 0) { peg$fail(peg$c124); }
                              }
                              if (s13 !== peg$FAILED) {
                                s14 = peg$parse_();
                                if (s14 !== peg$FAILED) {
                                  if (input.charCodeAt(peg$currPos) === 61) {
                                    s15 = peg$c2;
                                    peg$currPos++;
                                  } else {
                                    s15 = peg$FAILED;
                                    if (peg$silentFails === 0) { peg$fail(peg$c3); }
                                  }
                                  if (s15 !== peg$FAILED) {
                                    s16 = peg$parse_();
                                    if (s16 !== peg$FAILED) {
                                      s17 = peg$parseundefined_value();
                                      if (s17 === peg$FAILED) {
                                        s17 = peg$parsecompound_measure_value();
                                      }
                                      if (s17 !== peg$FAILED) {
                                        s18 = peg$parse_();
                                        if (s18 !== peg$FAILED) {
                                          if (input.charCodeAt(peg$currPos) === 41) {
                                            s19 = peg$c37;
                                            peg$currPos++;
                                          } else {
                                            s19 = peg$FAILED;
                                            if (peg$silentFails === 0) { peg$fail(peg$c38); }
                                          }
                                          if (s19 !== peg$FAILED) {
                                            peg$savedPos = s0;
                                            s1 = peg$c125(s9, s17);
                                            s0 = s1;
                                          } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                          }
                                        } else {
                                          peg$currPos = s0;
                                          s0 = peg$FAILED;
                                        }
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseattimer() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 7) === peg$c126) {
        s1 = peg$c126;
        peg$currPos += 7;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c127); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 40) {
            s3 = peg$c35;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c36); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.substr(peg$currPos, 4) === peg$c128) {
                s5 = peg$c128;
                peg$currPos += 4;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c129); }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 61) {
                    s7 = peg$c2;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c3); }
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse_();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseundefined_value();
                      if (s9 === peg$FAILED) {
                        s9 = peg$parsetime_value();
                      }
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parse_();
                        if (s10 !== peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 41) {
                            s11 = peg$c37;
                            peg$currPos++;
                          } else {
                            s11 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c38); }
                          }
                          if (s11 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c130(s9);
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseedge_trigger() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4) === peg$c131) {
        s1 = peg$c131;
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c132); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsealias_stream();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.substr(peg$currPos, 2) === peg$c114) {
                s5 = peg$c114;
                peg$currPos += 2;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c115); }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse__();
                if (s6 !== peg$FAILED) {
                  s7 = peg$currPos;
                  if (input.substr(peg$currPos, 3) === peg$c133) {
                    s8 = peg$c133;
                    peg$currPos += 3;
                  } else {
                    s8 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c134); }
                  }
                  if (s8 !== peg$FAILED) {
                    s9 = peg$currPos;
                    peg$silentFails++;
                    s10 = peg$parseidentchar();
                    peg$silentFails--;
                    if (s10 === peg$FAILED) {
                      s9 = void 0;
                    } else {
                      peg$currPos = s9;
                      s9 = peg$FAILED;
                    }
                    if (s9 !== peg$FAILED) {
                      s8 = [s8, s9];
                      s7 = s8;
                    } else {
                      peg$currPos = s7;
                      s7 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                  if (s7 === peg$FAILED) {
                    s7 = peg$parseor_expr();
                  }
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c135(s3, s7);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseout_param_list() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 91) {
        s1 = peg$c77;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c78); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseident();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = [];
              s6 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 44) {
                s7 = peg$c20;
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c21); }
              }
              if (s7 !== peg$FAILED) {
                s8 = peg$parse_();
                if (s8 !== peg$FAILED) {
                  s9 = peg$parseident();
                  if (s9 !== peg$FAILED) {
                    s10 = peg$parse_();
                    if (s10 !== peg$FAILED) {
                      s7 = [s7, s8, s9, s10];
                      s6 = s7;
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 44) {
                  s7 = peg$c20;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c21); }
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parseident();
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse_();
                      if (s10 !== peg$FAILED) {
                        s7 = [s7, s8, s9, s10];
                        s6 = s7;
                      } else {
                        peg$currPos = s6;
                        s6 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 93) {
                    s7 = peg$c79;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c80); }
                  }
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c136(s3, s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsemonitor_stream() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 7) === peg$c137) {
        s1 = peg$c137;
        peg$currPos += 7;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c138); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsealias_table();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c114) {
                s6 = peg$c114;
                peg$currPos += 2;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c115); }
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$parse__();
                if (s7 !== peg$FAILED) {
                  if (input.substr(peg$currPos, 3) === peg$c133) {
                    s8 = peg$c133;
                    peg$currPos += 3;
                  } else {
                    s8 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c134); }
                  }
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parse_();
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parseout_param_list();
                      if (s10 !== peg$FAILED) {
                        s6 = [s6, s7, s8, s9, s10];
                        s5 = s6;
                      } else {
                        peg$currPos = s5;
                        s5 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              if (s5 === peg$FAILED) {
                s5 = null;
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c139(s3, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsestream_projection() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseout_param_list();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c81) {
            s3 = peg$c81;
            peg$currPos += 2;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c82); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse__();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsealias_stream();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c140(s1, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsecomputed_stream() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 7) === peg$c84) {
        s1 = peg$c84;
        peg$currPos += 7;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c85); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseprimary_scalar_expression();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c86) {
                s6 = peg$c86;
                peg$currPos += 2;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c87); }
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$parse__();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parseident();
                  if (s8 !== peg$FAILED) {
                    s6 = [s6, s7, s8];
                    s5 = s6;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              if (s5 === peg$FAILED) {
                s5 = null;
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                if (s6 !== peg$FAILED) {
                  if (input.substr(peg$currPos, 2) === peg$c81) {
                    s7 = peg$c81;
                    peg$currPos += 2;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c82); }
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse__();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parsealias_stream();
                      if (s9 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c141(s3, s5, s9);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsealias_stream() {
      var s0, s1, s2, s3, s4, s5, s6;

      s0 = peg$currPos;
      s1 = peg$parseprimary_stream();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c86) {
            s4 = peg$c86;
            peg$currPos += 2;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c87); }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parse__();
            if (s5 !== peg$FAILED) {
              s6 = peg$parseident();
              if (s6 !== peg$FAILED) {
                s4 = [s4, s5, s6];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c142(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsefiltered_stream() {
      var s0, s1, s2, s3, s4, s5, s6;

      s0 = peg$currPos;
      s1 = peg$parsealias_stream();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s4 = peg$c20;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c21); }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            if (s5 !== peg$FAILED) {
              s6 = peg$parseor_expr();
              if (s6 !== peg$FAILED) {
                s3 = [s3, s4, s5, s6];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c143(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsestream() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;

      s0 = peg$currPos;
      s1 = peg$parsefiltered_stream();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c112) {
            s5 = peg$c112;
            peg$currPos += 4;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c113); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parsefiltered_table();
              if (s7 !== peg$FAILED) {
                s8 = peg$parse_();
                if (s8 !== peg$FAILED) {
                  s9 = peg$currPos;
                  if (input.substr(peg$currPos, 2) === peg$c114) {
                    s10 = peg$c114;
                    peg$currPos += 2;
                  } else {
                    s10 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c115); }
                  }
                  if (s10 !== peg$FAILED) {
                    s11 = peg$parse_();
                    if (s11 !== peg$FAILED) {
                      s12 = peg$parseinput_param_list();
                      if (s12 !== peg$FAILED) {
                        s13 = peg$parse_();
                        if (s13 !== peg$FAILED) {
                          s10 = [s10, s11, s12, s13];
                          s9 = s10;
                        } else {
                          peg$currPos = s9;
                          s9 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s9;
                        s9 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s9;
                      s9 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s9;
                    s9 = peg$FAILED;
                  }
                  if (s9 === peg$FAILED) {
                    s9 = null;
                  }
                  if (s9 !== peg$FAILED) {
                    s5 = [s5, s6, s7, s8, s9];
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$currPos;
            if (input.substr(peg$currPos, 4) === peg$c112) {
              s5 = peg$c112;
              peg$currPos += 4;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c113); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse__();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsefiltered_table();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c114) {
                      s10 = peg$c114;
                      peg$currPos += 2;
                    } else {
                      s10 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c115); }
                    }
                    if (s10 !== peg$FAILED) {
                      s11 = peg$parse_();
                      if (s11 !== peg$FAILED) {
                        s12 = peg$parseinput_param_list();
                        if (s12 !== peg$FAILED) {
                          s13 = peg$parse_();
                          if (s13 !== peg$FAILED) {
                            s10 = [s10, s11, s12, s13];
                            s9 = s10;
                          } else {
                            peg$currPos = s9;
                            s9 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s9;
                          s9 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s9;
                        s9 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s9;
                      s9 = peg$FAILED;
                    }
                    if (s9 === peg$FAILED) {
                      s9 = null;
                    }
                    if (s9 !== peg$FAILED) {
                      s5 = [s5, s6, s7, s8, s9];
                      s4 = s5;
                    } else {
                      peg$currPos = s4;
                      s4 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c144(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parselambda_param_decl_list() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 40) {
        s1 = peg$c35;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c36); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 41) {
            s3 = peg$c37;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c38); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c50();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 40) {
          s1 = peg$c35;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c36); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parselambda_param_decl();
            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 44) {
                  s7 = peg$c20;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c21); }
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parselambda_param_decl();
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse_();
                      if (s10 !== peg$FAILED) {
                        s7 = [s7, s8, s9, s10];
                        s6 = s7;
                      } else {
                        peg$currPos = s6;
                        s6 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$currPos;
                  if (input.charCodeAt(peg$currPos) === 44) {
                    s7 = peg$c20;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c21); }
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse_();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parselambda_param_decl();
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parse_();
                        if (s10 !== peg$FAILED) {
                          s7 = [s7, s8, s9, s10];
                          s6 = s7;
                        } else {
                          peg$currPos = s6;
                          s6 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s6;
                        s6 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                }
                if (s5 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s6 = peg$c37;
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c38); }
                  }
                  if (s6 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c145(s3, s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }

      return s0;
    }

    function peg$parselambda_param_decl() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseident();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s3 = peg$c6;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c7); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsetype_ref();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c146(s1, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsedeclaration() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 3) === peg$c147) {
        s1 = peg$c147;
        peg$currPos += 3;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c148); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          if (input.substr(peg$currPos, 6) === peg$c149) {
            s3 = peg$c149;
            peg$currPos += 6;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c150); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse__();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseident();
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                if (s6 !== peg$FAILED) {
                  if (input.substr(peg$currPos, 2) === peg$c151) {
                    s7 = peg$c151;
                    peg$currPos += 2;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c152); }
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse_();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$currPos;
                      if (input.charCodeAt(peg$currPos) === 92) {
                        s10 = peg$c153;
                        peg$currPos++;
                      } else {
                        s10 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c154); }
                      }
                      if (s10 !== peg$FAILED) {
                        s11 = peg$parse_();
                        if (s11 !== peg$FAILED) {
                          s12 = peg$parselambda_param_decl_list();
                          if (s12 !== peg$FAILED) {
                            s13 = peg$parse_();
                            if (s13 !== peg$FAILED) {
                              if (input.substr(peg$currPos, 2) === peg$c155) {
                                s14 = peg$c155;
                                peg$currPos += 2;
                              } else {
                                s14 = peg$FAILED;
                                if (peg$silentFails === 0) { peg$fail(peg$c156); }
                              }
                              if (s14 !== peg$FAILED) {
                                s15 = peg$parse_();
                                if (s15 !== peg$FAILED) {
                                  s10 = [s10, s11, s12, s13, s14, s15];
                                  s9 = s10;
                                } else {
                                  peg$currPos = s9;
                                  s9 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s9;
                                s9 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s9;
                              s9 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s9;
                            s9 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s9;
                          s9 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s9;
                        s9 = peg$FAILED;
                      }
                      if (s9 === peg$FAILED) {
                        s9 = null;
                      }
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parsestream();
                        if (s10 !== peg$FAILED) {
                          s11 = peg$parse_();
                          if (s11 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 59) {
                              s12 = peg$c30;
                              peg$currPos++;
                            } else {
                              s12 = peg$FAILED;
                              if (peg$silentFails === 0) { peg$fail(peg$c31); }
                            }
                            if (s12 !== peg$FAILED) {
                              peg$savedPos = s0;
                              s1 = peg$c157(s5, s9, s10);
                              s0 = s1;
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 3) === peg$c147) {
          s1 = peg$c147;
          peg$currPos += 3;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c148); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse__();
          if (s2 !== peg$FAILED) {
            if (input.substr(peg$currPos, 5) === peg$c158) {
              s3 = peg$c158;
              peg$currPos += 5;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c159); }
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parse__();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseident();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parse_();
                  if (s6 !== peg$FAILED) {
                    if (input.substr(peg$currPos, 2) === peg$c151) {
                      s7 = peg$c151;
                      peg$currPos += 2;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c152); }
                    }
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parse_();
                      if (s8 !== peg$FAILED) {
                        s9 = peg$currPos;
                        if (input.charCodeAt(peg$currPos) === 92) {
                          s10 = peg$c153;
                          peg$currPos++;
                        } else {
                          s10 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c154); }
                        }
                        if (s10 !== peg$FAILED) {
                          s11 = peg$parse_();
                          if (s11 !== peg$FAILED) {
                            s12 = peg$parselambda_param_decl_list();
                            if (s12 !== peg$FAILED) {
                              s13 = peg$parse_();
                              if (s13 !== peg$FAILED) {
                                if (input.substr(peg$currPos, 2) === peg$c155) {
                                  s14 = peg$c155;
                                  peg$currPos += 2;
                                } else {
                                  s14 = peg$FAILED;
                                  if (peg$silentFails === 0) { peg$fail(peg$c156); }
                                }
                                if (s14 !== peg$FAILED) {
                                  s15 = peg$parse_();
                                  if (s15 !== peg$FAILED) {
                                    s10 = [s10, s11, s12, s13, s14, s15];
                                    s9 = s10;
                                  } else {
                                    peg$currPos = s9;
                                    s9 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s9;
                                  s9 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s9;
                                s9 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s9;
                              s9 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s9;
                            s9 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s9;
                          s9 = peg$FAILED;
                        }
                        if (s9 === peg$FAILED) {
                          s9 = null;
                        }
                        if (s9 !== peg$FAILED) {
                          s10 = peg$parsetable();
                          if (s10 !== peg$FAILED) {
                            s11 = peg$parse_();
                            if (s11 !== peg$FAILED) {
                              if (input.charCodeAt(peg$currPos) === 59) {
                                s12 = peg$c30;
                                peg$currPos++;
                              } else {
                                s12 = peg$FAILED;
                                if (peg$silentFails === 0) { peg$fail(peg$c31); }
                              }
                              if (s12 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c160(s5, s9, s10);
                                s0 = s1;
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 3) === peg$c147) {
            s1 = peg$c147;
            peg$currPos += 3;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c148); }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parse__();
            if (s2 !== peg$FAILED) {
              if (input.substr(peg$currPos, 6) === peg$c47) {
                s3 = peg$c47;
                peg$currPos += 6;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c48); }
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parse__();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseident();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parse_();
                    if (s6 !== peg$FAILED) {
                      if (input.substr(peg$currPos, 2) === peg$c151) {
                        s7 = peg$c151;
                        peg$currPos += 2;
                      } else {
                        s7 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c152); }
                      }
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parse_();
                        if (s8 !== peg$FAILED) {
                          s9 = peg$currPos;
                          if (input.charCodeAt(peg$currPos) === 92) {
                            s10 = peg$c153;
                            peg$currPos++;
                          } else {
                            s10 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c154); }
                          }
                          if (s10 !== peg$FAILED) {
                            s11 = peg$parse_();
                            if (s11 !== peg$FAILED) {
                              s12 = peg$parselambda_param_decl_list();
                              if (s12 !== peg$FAILED) {
                                s13 = peg$parse_();
                                if (s13 !== peg$FAILED) {
                                  if (input.substr(peg$currPos, 2) === peg$c155) {
                                    s14 = peg$c155;
                                    peg$currPos += 2;
                                  } else {
                                    s14 = peg$FAILED;
                                    if (peg$silentFails === 0) { peg$fail(peg$c156); }
                                  }
                                  if (s14 !== peg$FAILED) {
                                    s15 = peg$parse_();
                                    if (s15 !== peg$FAILED) {
                                      s10 = [s10, s11, s12, s13, s14, s15];
                                      s9 = s10;
                                    } else {
                                      peg$currPos = s9;
                                      s9 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s9;
                                    s9 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s9;
                                  s9 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s9;
                                s9 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s9;
                              s9 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s9;
                            s9 = peg$FAILED;
                          }
                          if (s9 === peg$FAILED) {
                            s9 = null;
                          }
                          if (s9 !== peg$FAILED) {
                            s10 = peg$parsethingpedia_function_call();
                            if (s10 !== peg$FAILED) {
                              s11 = peg$parse_();
                              if (s11 !== peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 59) {
                                  s12 = peg$c30;
                                  peg$currPos++;
                                } else {
                                  s12 = peg$FAILED;
                                  if (peg$silentFails === 0) { peg$fail(peg$c31); }
                                }
                                if (s12 !== peg$FAILED) {
                                  peg$savedPos = s0;
                                  s1 = peg$c161(s5, s9, s10);
                                  s0 = s1;
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
      }

      return s0;
    }

    function peg$parseaction() {
      var s0, s1;

      s0 = peg$parsethingpedia_function_call();
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 6) === peg$c28) {
          s1 = peg$c28;
          peg$currPos += 6;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c29); }
        }
        if (s1 === peg$FAILED) {
          if (input.substr(peg$currPos, 6) === peg$c162) {
            s1 = peg$c162;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c163); }
          }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c164(s1);
        }
        s0 = s1;
      }

      return s0;
    }

    function peg$parseaction_list() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

      s0 = peg$currPos;
      s1 = peg$parseaction();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c165(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 123) {
          s1 = peg$c9;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c10); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$currPos;
            s5 = peg$parseaction();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 59) {
                  s7 = peg$c30;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c31); }
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    s5 = [s5, s6, s7, s8];
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$currPos;
                s5 = peg$parseaction();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parse_();
                  if (s6 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 59) {
                      s7 = peg$c30;
                      peg$currPos++;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c31); }
                    }
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parse_();
                      if (s8 !== peg$FAILED) {
                        s5 = [s5, s6, s7, s8];
                        s4 = s5;
                      } else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s4;
                      s4 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              }
            } else {
              s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 125) {
                s4 = peg$c11;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c12); }
              }
              if (s4 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c166(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }

      return s0;
    }

    function peg$parserule() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 3) === peg$c24) {
        s1 = peg$c24;
        peg$currPos += 3;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c25); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c26) {
            s3 = peg$c26;
            peg$currPos += 2;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c27); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsetable();
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                if (s6 !== peg$FAILED) {
                  if (input.substr(peg$currPos, 2) === peg$c26) {
                    s7 = peg$c26;
                    peg$currPos += 2;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c27); }
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse_();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseaction_list();
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parse_();
                        if (s10 !== peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 59) {
                            s11 = peg$c30;
                            peg$currPos++;
                          } else {
                            s11 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c31); }
                          }
                          if (s11 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c167(s5, s9);
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 3) === peg$c24) {
          s1 = peg$c24;
          peg$currPos += 3;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c25); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse__();
          if (s2 !== peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c26) {
              s3 = peg$c26;
              peg$currPos += 2;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c27); }
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseaction_list();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parse_();
                  if (s6 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 59) {
                      s7 = peg$c30;
                      peg$currPos++;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c31); }
                    }
                    if (s7 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c168(s5);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsestream();
          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
              if (input.substr(peg$currPos, 2) === peg$c26) {
                s3 = peg$c26;
                peg$currPos += 2;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c27); }
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseaction_list();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parse_();
                    if (s6 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 59) {
                        s7 = peg$c30;
                        peg$currPos++;
                      } else {
                        s7 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c31); }
                      }
                      if (s7 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c169(s1, s5);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
      }

      return s0;
    }

    function peg$parseget_predicate() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

      s0 = peg$currPos;
      s1 = peg$parsethingpedia_function_name();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseinput_param_list();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 123) {
                s5 = peg$c9;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c10); }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseor_expr();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse_();
                    if (s8 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 125) {
                        s9 = peg$c11;
                        peg$currPos++;
                      } else {
                        s9 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c12); }
                      }
                      if (s9 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c170(s1, s3, s7);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsefunction_style_predicate() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;

      s0 = peg$currPos;
      s1 = peg$parseident();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 40) {
            s3 = peg$c35;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c36); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseident();
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 44) {
                    s7 = peg$c20;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c21); }
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse_();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parsevalue();
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parse_();
                        if (s10 !== peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 41) {
                            s11 = peg$c37;
                            peg$currPos++;
                          } else {
                            s11 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c38); }
                          }
                          if (s11 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c171(s1, s5, s9);
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseinfix_predicate() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseident();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsecomparison_operator();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsevalue();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c172(s1, s3, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseor_expr() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

      s0 = peg$currPos;
      s1 = peg$parseand_expr();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c173) {
            s5 = peg$c173;
            peg$currPos += 2;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c174); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseand_expr();
              if (s7 !== peg$FAILED) {
                s8 = peg$parse_();
                if (s8 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7, s8];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c173) {
              s5 = peg$c173;
              peg$currPos += 2;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c174); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseand_expr();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    s4 = [s4, s5, s6, s7, s8];
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c175(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseand_expr() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parsecomp_expr();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c176) {
            s5 = peg$c176;
            peg$currPos += 2;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c177); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parsecomp_expr();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c176) {
              s5 = peg$c176;
              peg$currPos += 2;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c177); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsecomp_expr();
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c178(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsecomp_expr() {
      var s0;

      s0 = peg$parseinfix_predicate();
      if (s0 === peg$FAILED) {
        s0 = peg$parseprimary_bool_expr();
      }

      return s0;
    }

    function peg$parseprimary_bool_expr() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 40) {
        s1 = peg$c35;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c36); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseor_expr();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 41) {
                s5 = peg$c37;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c38); }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c179(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseliteral_bool();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c180(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 33) {
            s1 = peg$c181;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c182); }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseprimary_bool_expr();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c183(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$parseget_predicate();
            if (s0 === peg$FAILED) {
              s0 = peg$parsefunction_style_predicate();
            }
          }
        }
      }

      return s0;
    }

    function peg$parsescalar_function_args() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 40) {
        s1 = peg$c35;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c36); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 41) {
            s3 = peg$c37;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c38); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c50();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 40) {
          s1 = peg$c35;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c36); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseadd_expr();
            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 44) {
                  s7 = peg$c20;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c21); }
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parseadd_expr();
                    if (s9 !== peg$FAILED) {
                      s7 = [s7, s8, s9];
                      s6 = s7;
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$currPos;
                  if (input.charCodeAt(peg$currPos) === 44) {
                    s7 = peg$c20;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c21); }
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse_();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseadd_expr();
                      if (s9 !== peg$FAILED) {
                        s7 = [s7, s8, s9];
                        s6 = s7;
                      } else {
                        peg$currPos = s6;
                        s6 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                }
                if (s5 !== peg$FAILED) {
                  s6 = peg$parse_();
                  if (s6 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 41) {
                      s7 = peg$c37;
                      peg$currPos++;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c38); }
                    }
                    if (s7 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c136(s3, s5);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }

      return s0;
    }

    function peg$parsescalar_function() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseident();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsescalar_function_args();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c184(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseprimary_scalar_expression() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parsevalue();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c185(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$parsescalar_function();
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 40) {
            s1 = peg$c35;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c36); }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseadd_expr();
              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s5 = peg$c37;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c38); }
                  }
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c186(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
      }

      return s0;
    }

    function peg$parseadd_expr() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

      s0 = peg$currPos;
      s1 = peg$parsemul_expr();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 43) {
            s5 = peg$c187;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c188); }
          }
          if (s5 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 45) {
              s5 = peg$c189;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c190); }
            }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parsemul_expr();
              if (s7 !== peg$FAILED) {
                s8 = peg$parse_();
                if (s8 !== peg$FAILED) {
                  s5 = [s5, s6, s7, s8];
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 43) {
              s5 = peg$c187;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c188); }
            }
            if (s5 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 45) {
                s5 = peg$c189;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c190); }
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsemul_expr();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    s5 = [s5, s6, s7, s8];
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c191(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsemul_expr() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

      s0 = peg$currPos;
      s1 = peg$parseexp_expr();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 42) {
            s5 = peg$c17;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c18); }
          }
          if (s5 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 47) {
              s5 = peg$c192;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c193); }
            }
            if (s5 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 37) {
                s5 = peg$c194;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c195); }
              }
            }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseexp_expr();
              if (s7 !== peg$FAILED) {
                s8 = peg$parse_();
                if (s8 !== peg$FAILED) {
                  s5 = [s5, s6, s7, s8];
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 42) {
              s5 = peg$c17;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c18); }
            }
            if (s5 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 47) {
                s5 = peg$c192;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c193); }
              }
              if (s5 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 37) {
                  s5 = peg$c194;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c195); }
                }
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseexp_expr();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    s5 = [s5, s6, s7, s8];
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c191(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseexp_expr() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

      s0 = peg$currPos;
      s1 = peg$parseprimary_scalar_expression();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c196) {
            s5 = peg$c196;
            peg$currPos += 2;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c197); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseprimary_scalar_expression();
              if (s7 !== peg$FAILED) {
                s8 = peg$parse_();
                if (s8 !== peg$FAILED) {
                  s5 = [s5, s6, s7, s8];
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c196) {
              s5 = peg$c196;
              peg$currPos += 2;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c197); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseprimary_scalar_expression();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    s5 = [s5, s6, s7, s8];
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c191(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsedate_value() {
      var s0;

      s0 = peg$parserelative_date_value();
      if (s0 === peg$FAILED) {
        s0 = peg$parseabsolute_date_value();
        if (s0 === peg$FAILED) {
          s0 = peg$parseedge_date_value();
          if (s0 === peg$FAILED) {
            s0 = peg$parsenow();
          }
        }
      }

      return s0;
    }

    function peg$parsevalue() {
      var s0;

      s0 = peg$parseundefined_value();
      if (s0 === peg$FAILED) {
        s0 = peg$parsedate_value();
        if (s0 === peg$FAILED) {
          s0 = peg$parsebool_value();
          if (s0 === peg$FAILED) {
            s0 = peg$parseevent_value();
            if (s0 === peg$FAILED) {
              s0 = peg$parsecompound_measure_value();
              if (s0 === peg$FAILED) {
                s0 = peg$parsenumber_value();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsecurrency_value();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parsetime_value();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parselocation_value();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseenum_value();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parseentity_value();
                          if (s0 === peg$FAILED) {
                            s0 = peg$parsevar_ref_value();
                            if (s0 === peg$FAILED) {
                              s0 = peg$parsestring_value();
                              if (s0 === peg$FAILED) {
                                s0 = peg$parsearray_value();
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parsequalified_name() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

      s0 = peg$currPos;
      s1 = peg$parseident();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s5 = peg$c15;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c16); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseident();
              if (s7 !== peg$FAILED) {
                s8 = peg$parse_();
                if (s8 !== peg$FAILED) {
                  s5 = [s5, s6, s7, s8];
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 46) {
              s5 = peg$c15;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c16); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseident();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    s5 = [s5, s6, s7, s8];
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c198(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsequalified_class_name() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

      s0 = peg$currPos;
      s1 = peg$parseclassident();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s5 = peg$c15;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c16); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseclassident();
              if (s7 !== peg$FAILED) {
                s8 = peg$parse_();
                if (s8 !== peg$FAILED) {
                  s5 = [s5, s6, s7, s8];
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 46) {
              s5 = peg$c15;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c16); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseclassident();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    s5 = [s5, s6, s7, s8];
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c198(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsevar_ref_value() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$parsequalified_name();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          peg$silentFails++;
          if (input.charCodeAt(peg$currPos) === 40) {
            s4 = peg$c35;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c36); }
          }
          peg$silentFails--;
          if (s4 === peg$FAILED) {
            s3 = void 0;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c199(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseundefined_value() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 10) === peg$c200) {
        s1 = peg$c200;
        peg$currPos += 10;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c201); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 46) {
          s3 = peg$c15;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c16); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.substr(peg$currPos, 6) === peg$c202) {
              s5 = peg$c202;
              peg$currPos += 6;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c203); }
            }
            if (s5 !== peg$FAILED) {
              s3 = [s3, s4, s5];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c204(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsecompound_measure_value() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;

      s0 = peg$parsemeasure_value();
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 40) {
          s1 = peg$c35;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c36); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parsemeasure_value();
            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 43) {
                  s7 = peg$c187;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c188); }
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parsemeasure_value();
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse_();
                      if (s10 !== peg$FAILED) {
                        s7 = [s7, s8, s9, s10];
                        s6 = s7;
                      } else {
                        peg$currPos = s6;
                        s6 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
                if (s6 !== peg$FAILED) {
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 43) {
                      s7 = peg$c187;
                      peg$currPos++;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c188); }
                    }
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parse_();
                      if (s8 !== peg$FAILED) {
                        s9 = peg$parsemeasure_value();
                        if (s9 !== peg$FAILED) {
                          s10 = peg$parse_();
                          if (s10 !== peg$FAILED) {
                            s7 = [s7, s8, s9, s10];
                            s6 = s7;
                          } else {
                            peg$currPos = s6;
                            s6 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s6;
                          s6 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s6;
                        s6 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                  }
                } else {
                  s5 = peg$FAILED;
                }
                if (s5 !== peg$FAILED) {
                  s6 = peg$parse_();
                  if (s6 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 41) {
                      s7 = peg$c37;
                      peg$currPos++;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c38); }
                    }
                    if (s7 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c205(s3, s5);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }

      return s0;
    }

    function peg$parsemeasure_value() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parseliteral_number();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseident();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c206(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsenumber_value() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseliteral_number();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c207(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parsecurrency_value() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 12) === peg$c208) {
        s1 = peg$c208;
        peg$currPos += 12;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c209); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 40) {
            s3 = peg$c35;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c36); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseliteral_number();
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 44) {
                    s7 = peg$c20;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c21); }
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse_();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseident();
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parse_();
                        if (s10 !== peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 41) {
                            s11 = peg$c37;
                            peg$currPos++;
                          } else {
                            s11 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c38); }
                          }
                          if (s11 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c210(s5, s9);
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parselong_date_value() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17, s18, s19, s20, s21, s22, s23, s24, s25, s26;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 8) === peg$c211) {
        s1 = peg$c211;
        peg$currPos += 8;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c212); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 40) {
            s3 = peg$c35;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c36); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseliteral_number();
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 44) {
                  s6 = peg$c20;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c21); }
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parseliteral_number();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parse_();
                      if (s9 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 44) {
                          s10 = peg$c20;
                          peg$currPos++;
                        } else {
                          s10 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c21); }
                        }
                        if (s10 !== peg$FAILED) {
                          s11 = peg$parse_();
                          if (s11 !== peg$FAILED) {
                            s12 = peg$parseliteral_number();
                            if (s12 !== peg$FAILED) {
                              s13 = peg$parse_();
                              if (s13 !== peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 44) {
                                  s14 = peg$c20;
                                  peg$currPos++;
                                } else {
                                  s14 = peg$FAILED;
                                  if (peg$silentFails === 0) { peg$fail(peg$c21); }
                                }
                                if (s14 !== peg$FAILED) {
                                  s15 = peg$parse_();
                                  if (s15 !== peg$FAILED) {
                                    s16 = peg$parseliteral_number();
                                    if (s16 !== peg$FAILED) {
                                      s17 = peg$parse_();
                                      if (s17 !== peg$FAILED) {
                                        if (input.charCodeAt(peg$currPos) === 44) {
                                          s18 = peg$c20;
                                          peg$currPos++;
                                        } else {
                                          s18 = peg$FAILED;
                                          if (peg$silentFails === 0) { peg$fail(peg$c21); }
                                        }
                                        if (s18 !== peg$FAILED) {
                                          s19 = peg$parse_();
                                          if (s19 !== peg$FAILED) {
                                            s20 = peg$parseliteral_number();
                                            if (s20 !== peg$FAILED) {
                                              s21 = peg$parse_();
                                              if (s21 !== peg$FAILED) {
                                                if (input.charCodeAt(peg$currPos) === 44) {
                                                  s22 = peg$c20;
                                                  peg$currPos++;
                                                } else {
                                                  s22 = peg$FAILED;
                                                  if (peg$silentFails === 0) { peg$fail(peg$c21); }
                                                }
                                                if (s22 !== peg$FAILED) {
                                                  s23 = peg$parse_();
                                                  if (s23 !== peg$FAILED) {
                                                    s24 = peg$parseliteral_number();
                                                    if (s24 !== peg$FAILED) {
                                                      s25 = peg$parse_();
                                                      if (s25 !== peg$FAILED) {
                                                        if (input.charCodeAt(peg$currPos) === 41) {
                                                          s26 = peg$c37;
                                                          peg$currPos++;
                                                        } else {
                                                          s26 = peg$FAILED;
                                                          if (peg$silentFails === 0) { peg$fail(peg$c38); }
                                                        }
                                                        if (s26 !== peg$FAILED) {
                                                          peg$savedPos = s0;
                                                          s1 = peg$c213(s4, s8, s12, s16, s20, s24);
                                                          s0 = s1;
                                                        } else {
                                                          peg$currPos = s0;
                                                          s0 = peg$FAILED;
                                                        }
                                                      } else {
                                                        peg$currPos = s0;
                                                        s0 = peg$FAILED;
                                                      }
                                                    } else {
                                                      peg$currPos = s0;
                                                      s0 = peg$FAILED;
                                                    }
                                                  } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$FAILED;
                                                  }
                                                } else {
                                                  peg$currPos = s0;
                                                  s0 = peg$FAILED;
                                                }
                                              } else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                              }
                                            } else {
                                              peg$currPos = s0;
                                              s0 = peg$FAILED;
                                            }
                                          } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                          }
                                        } else {
                                          peg$currPos = s0;
                                          s0 = peg$FAILED;
                                        }
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseshort_date_value() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 8) === peg$c211) {
        s1 = peg$c211;
        peg$currPos += 8;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c212); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 40) {
            s3 = peg$c35;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c36); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseliteral_number();
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 44) {
                  s6 = peg$c20;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c21); }
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parseliteral_number();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parse_();
                      if (s9 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 44) {
                          s10 = peg$c20;
                          peg$currPos++;
                        } else {
                          s10 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c21); }
                        }
                        if (s10 !== peg$FAILED) {
                          s11 = peg$parse_();
                          if (s11 !== peg$FAILED) {
                            s12 = peg$parseliteral_number();
                            if (s12 !== peg$FAILED) {
                              s13 = peg$parse_();
                              if (s13 !== peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 41) {
                                  s14 = peg$c37;
                                  peg$currPos++;
                                } else {
                                  s14 = peg$FAILED;
                                  if (peg$silentFails === 0) { peg$fail(peg$c38); }
                                }
                                if (s14 !== peg$FAILED) {
                                  peg$savedPos = s0;
                                  s1 = peg$c214(s4, s8, s12);
                                  s0 = s1;
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseunix_date_value() {
      var s0, s1, s2, s3, s4, s5, s6;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 8) === peg$c211) {
        s1 = peg$c211;
        peg$currPos += 8;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c212); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 40) {
            s3 = peg$c35;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c36); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseliteral_number();
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 41) {
                  s6 = peg$c37;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c38); }
                }
                if (s6 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c215(s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseabsolute_date_value() {
      var s0;

      s0 = peg$parselong_date_value();
      if (s0 === peg$FAILED) {
        s0 = peg$parseshort_date_value();
        if (s0 === peg$FAILED) {
          s0 = peg$parseunix_date_value();
        }
      }

      return s0;
    }

    function peg$parserelative_date_value() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseabsolute_date_value();
      if (s1 === peg$FAILED) {
        s1 = peg$parsenow();
        if (s1 === peg$FAILED) {
          s1 = peg$parseedge_date_value();
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 43) {
            s3 = peg$c187;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c188); }
          }
          if (s3 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 45) {
              s3 = peg$c189;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c190); }
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsecompound_measure_value();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c216(s1, s3, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsetime_unit() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseident();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c217(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseedge_date_value() {
      var s0, s1, s2, s3, s4, s5, s6;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 8) === peg$c218) {
        s1 = peg$c218;
        peg$currPos += 8;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c219); }
      }
      if (s1 === peg$FAILED) {
        if (input.substr(peg$currPos, 6) === peg$c220) {
          s1 = peg$c220;
          peg$currPos += 6;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c221); }
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 40) {
            s3 = peg$c35;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c36); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parsetime_unit();
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 41) {
                  s6 = peg$c37;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c38); }
                }
                if (s6 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c222(s1, s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsenow() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 8) === peg$c211) {
        s1 = peg$c211;
        peg$currPos += 8;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c212); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 40) {
            s3 = peg$c35;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c36); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 41) {
                s5 = peg$c37;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c38); }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c223();
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsetime_value() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 8) === peg$c224) {
        s1 = peg$c224;
        peg$currPos += 8;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c225); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 40) {
            s3 = peg$c35;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c36); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseliteral_number();
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 44) {
                  s6 = peg$c20;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c21); }
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parseliteral_number();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parse_();
                      if (s9 !== peg$FAILED) {
                        s10 = peg$currPos;
                        if (input.charCodeAt(peg$currPos) === 44) {
                          s11 = peg$c20;
                          peg$currPos++;
                        } else {
                          s11 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c21); }
                        }
                        if (s11 !== peg$FAILED) {
                          s12 = peg$parse_();
                          if (s12 !== peg$FAILED) {
                            s13 = peg$parseliteral_number();
                            if (s13 !== peg$FAILED) {
                              s14 = peg$parse_();
                              if (s14 !== peg$FAILED) {
                                s11 = [s11, s12, s13, s14];
                                s10 = s11;
                              } else {
                                peg$currPos = s10;
                                s10 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s10;
                              s10 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s10;
                            s10 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s10;
                          s10 = peg$FAILED;
                        }
                        if (s10 === peg$FAILED) {
                          s10 = null;
                        }
                        if (s10 !== peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 41) {
                            s11 = peg$c37;
                            peg$currPos++;
                          } else {
                            s11 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c38); }
                          }
                          if (s11 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c226(s4, s8, s10);
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsebool_value() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseliteral_bool();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c227(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parselocation_value() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 12) === peg$c228) {
        s1 = peg$c228;
        peg$currPos += 12;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c229); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 40) {
            s3 = peg$c35;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c36); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseliteral_number();
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 44) {
                    s7 = peg$c20;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c21); }
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse_();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseliteral_number();
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parse_();
                        if (s10 !== peg$FAILED) {
                          s11 = peg$currPos;
                          if (input.charCodeAt(peg$currPos) === 44) {
                            s12 = peg$c20;
                            peg$currPos++;
                          } else {
                            s12 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c21); }
                          }
                          if (s12 !== peg$FAILED) {
                            s13 = peg$parse_();
                            if (s13 !== peg$FAILED) {
                              s14 = peg$parseliteral_string();
                              if (s14 !== peg$FAILED) {
                                s15 = peg$parse_();
                                if (s15 !== peg$FAILED) {
                                  s12 = [s12, s13, s14, s15];
                                  s11 = s12;
                                } else {
                                  peg$currPos = s11;
                                  s11 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s11;
                                s11 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s11;
                              s11 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s11;
                            s11 = peg$FAILED;
                          }
                          if (s11 === peg$FAILED) {
                            s11 = null;
                          }
                          if (s11 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 41) {
                              s12 = peg$c37;
                              peg$currPos++;
                            } else {
                              s12 = peg$FAILED;
                              if (peg$silentFails === 0) { peg$fail(peg$c38); }
                            }
                            if (s12 !== peg$FAILED) {
                              peg$savedPos = s0;
                              s1 = peg$c230(s5, s9, s11);
                              s0 = s1;
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 8) === peg$c231) {
          s1 = peg$c231;
          peg$currPos += 8;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c232); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s3 = peg$c15;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c16); }
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();
              if (s4 !== peg$FAILED) {
                if (input.substr(peg$currPos, 8) === peg$c233) {
                  s5 = peg$c233;
                  peg$currPos += 8;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c234); }
                }
                if (s5 !== peg$FAILED) {
                  s6 = peg$parse_();
                  if (s6 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 46) {
                      s7 = peg$c15;
                      peg$currPos++;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c16); }
                    }
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parse_();
                      if (s8 !== peg$FAILED) {
                        if (input.substr(peg$currPos, 4) === peg$c235) {
                          s9 = peg$c235;
                          peg$currPos += 4;
                        } else {
                          s9 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c236); }
                        }
                        if (s9 === peg$FAILED) {
                          if (input.substr(peg$currPos, 4) === peg$c237) {
                            s9 = peg$c237;
                            peg$currPos += 4;
                          } else {
                            s9 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c238); }
                          }
                          if (s9 === peg$FAILED) {
                            if (input.substr(peg$currPos, 16) === peg$c239) {
                              s9 = peg$c239;
                              peg$currPos += 16;
                            } else {
                              s9 = peg$FAILED;
                              if (peg$silentFails === 0) { peg$fail(peg$c240); }
                            }
                          }
                        }
                        if (s9 !== peg$FAILED) {
                          peg$savedPos = s0;
                          s1 = peg$c241(s9);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }

      return s0;
    }

    function peg$parseenum_value() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4) === peg$c242) {
        s1 = peg$c242;
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c243); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 40) {
            s3 = peg$c35;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c36); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseident();
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s7 = peg$c37;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c38); }
                  }
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c244(s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsestring_value() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseliteral_string();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c245(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseevent_value() {
      var s0, s1, s2, s3, s4, s5, s6;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 6) === peg$c246) {
        s1 = peg$c246;
        peg$currPos += 6;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c247); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s4 = peg$c15;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c16); }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            if (s5 !== peg$FAILED) {
              if (input.substr(peg$currPos, 4) === peg$c248) {
                s6 = peg$c248;
                peg$currPos += 4;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c249); }
              }
              if (s6 === peg$FAILED) {
                if (input.substr(peg$currPos, 10) === peg$c250) {
                  s6 = peg$c250;
                  peg$currPos += 10;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c251); }
                }
              }
              if (s6 !== peg$FAILED) {
                s4 = [s4, s5, s6];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c252(s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseentity_type() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c253) {
        s1 = peg$c253;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c254); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsequalified_class_name();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 58) {
                s5 = peg$c6;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c7); }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseident();
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c255(s3, s7);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseentity_value1() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;

      s0 = peg$currPos;
      s1 = peg$parseliteral_string();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseentity_type();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 40) {
                s6 = peg$c35;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c36); }
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$parse_();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parseliteral_string();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parse_();
                    if (s9 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 41) {
                        s10 = peg$c37;
                        peg$currPos++;
                      } else {
                        s10 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c38); }
                      }
                      if (s10 !== peg$FAILED) {
                        s11 = peg$parse_();
                        if (s11 !== peg$FAILED) {
                          s6 = [s6, s7, s8, s9, s10, s11];
                          s5 = s6;
                        } else {
                          peg$currPos = s5;
                          s5 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s5;
                        s5 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              if (s5 === peg$FAILED) {
                s5 = null;
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c256(s1, s3, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseentity_value2() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4) === peg$c257) {
        s1 = peg$c257;
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c258); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseentity_type();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 40) {
                s5 = peg$c35;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c36); }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseliteral_string();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse_();
                    if (s8 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 41) {
                        s9 = peg$c37;
                        peg$currPos++;
                      } else {
                        s9 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c38); }
                      }
                      if (s9 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c259(s3, s7);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseentity_value() {
      var s0;

      s0 = peg$parseentity_value1();
      if (s0 === peg$FAILED) {
        s0 = peg$parseentity_value2();
      }

      return s0;
    }

    function peg$parsearray_value() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 91) {
        s1 = peg$c77;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c78); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsearray_value_list();
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 93) {
                s5 = peg$c79;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c80); }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c260(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsearray_value_list() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

      s0 = peg$currPos;
      s1 = peg$parsevalue();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 44) {
            s5 = peg$c20;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c21); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parsevalue();
              if (s7 !== peg$FAILED) {
                s8 = peg$parse_();
                if (s8 !== peg$FAILED) {
                  s5 = [s5, s6, s7, s8];
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c20;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c21); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsevalue();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    s5 = [s5, s6, s7, s8];
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c51(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsetype_ref() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 7) === peg$c261) {
        s1 = peg$c261;
        peg$currPos += 7;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c262); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 40) {
            s3 = peg$c35;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c36); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseident();
              if (s5 === peg$FAILED) {
                s5 = null;
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s7 = peg$c37;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c38); }
                  }
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c263(s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 5) === peg$c264) {
          s1 = peg$c264;
          peg$currPos += 5;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c265); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 40) {
              s3 = peg$c35;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c36); }
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();
              if (s4 !== peg$FAILED) {
                s5 = peg$parsetype_ref();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parse_();
                  if (s6 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 41) {
                      s7 = peg$c37;
                      peg$currPos++;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c38); }
                    }
                    if (s7 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c266(s5);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c267) {
            s1 = peg$c267;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c268); }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 40) {
                s3 = peg$c35;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c36); }
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseident();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parse_();
                    if (s6 !== peg$FAILED) {
                      s7 = [];
                      s8 = peg$currPos;
                      if (input.charCodeAt(peg$currPos) === 44) {
                        s9 = peg$c20;
                        peg$currPos++;
                      } else {
                        s9 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c21); }
                      }
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parse_();
                        if (s10 !== peg$FAILED) {
                          s11 = peg$parseident();
                          if (s11 !== peg$FAILED) {
                            s12 = peg$parse_();
                            if (s12 !== peg$FAILED) {
                              s9 = [s9, s10, s11, s12];
                              s8 = s9;
                            } else {
                              peg$currPos = s8;
                              s8 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s8;
                            s8 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s8;
                          s8 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s8;
                        s8 = peg$FAILED;
                      }
                      while (s8 !== peg$FAILED) {
                        s7.push(s8);
                        s8 = peg$currPos;
                        if (input.charCodeAt(peg$currPos) === 44) {
                          s9 = peg$c20;
                          peg$currPos++;
                        } else {
                          s9 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c21); }
                        }
                        if (s9 !== peg$FAILED) {
                          s10 = peg$parse_();
                          if (s10 !== peg$FAILED) {
                            s11 = peg$parseident();
                            if (s11 !== peg$FAILED) {
                              s12 = peg$parse_();
                              if (s12 !== peg$FAILED) {
                                s9 = [s9, s10, s11, s12];
                                s8 = s9;
                              } else {
                                peg$currPos = s8;
                                s8 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s8;
                              s8 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s8;
                            s8 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s8;
                          s8 = peg$FAILED;
                        }
                      }
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parse_();
                        if (s8 !== peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 41) {
                            s9 = peg$c37;
                            peg$currPos++;
                          } else {
                            s9 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c38); }
                          }
                          if (s9 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c269(s5, s7);
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 6) === peg$c270) {
              s1 = peg$c270;
              peg$currPos += 6;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c271); }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parse_();
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 40) {
                  s3 = peg$c35;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c36); }
                }
                if (s3 !== peg$FAILED) {
                  s4 = peg$parse_();
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parsequalified_class_name();
                    if (s5 !== peg$FAILED) {
                      s6 = peg$parse_();
                      if (s6 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 58) {
                          s7 = peg$c6;
                          peg$currPos++;
                        } else {
                          s7 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c7); }
                        }
                        if (s7 !== peg$FAILED) {
                          s8 = peg$parse_();
                          if (s8 !== peg$FAILED) {
                            s9 = peg$parseident();
                            if (s9 !== peg$FAILED) {
                              s10 = peg$parse_();
                              if (s10 !== peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 41) {
                                  s11 = peg$c37;
                                  peg$currPos++;
                                } else {
                                  s11 = peg$FAILED;
                                  if (peg$silentFails === 0) { peg$fail(peg$c38); }
                                }
                                if (s11 !== peg$FAILED) {
                                  peg$savedPos = s0;
                                  s1 = peg$c272(s5, s9);
                                  s0 = s1;
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 3) === peg$c273) {
                s1 = peg$c273;
                peg$currPos += 3;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c274); }
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c275();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 7) === peg$c276) {
                  s1 = peg$c276;
                  peg$currPos += 7;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c277); }
                }
                if (s1 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c278();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input.substr(peg$currPos, 6) === peg$c279) {
                    s1 = peg$c279;
                    peg$currPos += 6;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c280); }
                  }
                  if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c281();
                  }
                  s0 = s1;
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 6) === peg$c282) {
                      s1 = peg$c282;
                      peg$currPos += 6;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c283); }
                    }
                    if (s1 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c284();
                    }
                    s0 = s1;
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      if (input.substr(peg$currPos, 8) === peg$c285) {
                        s1 = peg$c285;
                        peg$currPos += 8;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c286); }
                      }
                      if (s1 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c287();
                      }
                      s0 = s1;
                      if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        if (input.substr(peg$currPos, 8) === peg$c288) {
                          s1 = peg$c288;
                          peg$currPos += 8;
                        } else {
                          s1 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c289); }
                        }
                        if (s1 !== peg$FAILED) {
                          peg$savedPos = s0;
                          s1 = peg$c290();
                        }
                        s0 = s1;
                        if (s0 === peg$FAILED) {
                          s0 = peg$currPos;
                          if (input.substr(peg$currPos, 4) === peg$c291) {
                            s1 = peg$c291;
                            peg$currPos += 4;
                          } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c292); }
                          }
                          if (s1 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c293();
                          }
                          s0 = s1;
                          if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            if (input.substr(peg$currPos, 4) === peg$c294) {
                              s1 = peg$c294;
                              peg$currPos += 4;
                            } else {
                              s1 = peg$FAILED;
                              if (peg$silentFails === 0) { peg$fail(peg$c295); }
                            }
                            if (s1 !== peg$FAILED) {
                              peg$savedPos = s0;
                              s1 = peg$c296();
                            }
                            s0 = s1;
                            if (s0 === peg$FAILED) {
                              s0 = peg$currPos;
                              if (input.charCodeAt(peg$currPos) === 40) {
                                s1 = peg$c35;
                                peg$currPos++;
                              } else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) { peg$fail(peg$c36); }
                              }
                              if (s1 !== peg$FAILED) {
                                s2 = peg$parsetype_ref();
                                if (s2 !== peg$FAILED) {
                                  s3 = peg$parse_();
                                  if (s3 !== peg$FAILED) {
                                    s4 = [];
                                    s5 = peg$currPos;
                                    if (input.charCodeAt(peg$currPos) === 44) {
                                      s6 = peg$c20;
                                      peg$currPos++;
                                    } else {
                                      s6 = peg$FAILED;
                                      if (peg$silentFails === 0) { peg$fail(peg$c21); }
                                    }
                                    if (s6 !== peg$FAILED) {
                                      s7 = peg$parse_();
                                      if (s7 !== peg$FAILED) {
                                        s8 = peg$parsetype_ref();
                                        if (s8 !== peg$FAILED) {
                                          s9 = peg$parse_();
                                          if (s9 !== peg$FAILED) {
                                            s6 = [s6, s7, s8, s9];
                                            s5 = s6;
                                          } else {
                                            peg$currPos = s5;
                                            s5 = peg$FAILED;
                                          }
                                        } else {
                                          peg$currPos = s5;
                                          s5 = peg$FAILED;
                                        }
                                      } else {
                                        peg$currPos = s5;
                                        s5 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s5;
                                      s5 = peg$FAILED;
                                    }
                                    while (s5 !== peg$FAILED) {
                                      s4.push(s5);
                                      s5 = peg$currPos;
                                      if (input.charCodeAt(peg$currPos) === 44) {
                                        s6 = peg$c20;
                                        peg$currPos++;
                                      } else {
                                        s6 = peg$FAILED;
                                        if (peg$silentFails === 0) { peg$fail(peg$c21); }
                                      }
                                      if (s6 !== peg$FAILED) {
                                        s7 = peg$parse_();
                                        if (s7 !== peg$FAILED) {
                                          s8 = peg$parsetype_ref();
                                          if (s8 !== peg$FAILED) {
                                            s9 = peg$parse_();
                                            if (s9 !== peg$FAILED) {
                                              s6 = [s6, s7, s8, s9];
                                              s5 = s6;
                                            } else {
                                              peg$currPos = s5;
                                              s5 = peg$FAILED;
                                            }
                                          } else {
                                            peg$currPos = s5;
                                            s5 = peg$FAILED;
                                          }
                                        } else {
                                          peg$currPos = s5;
                                          s5 = peg$FAILED;
                                        }
                                      } else {
                                        peg$currPos = s5;
                                        s5 = peg$FAILED;
                                      }
                                    }
                                    if (s4 !== peg$FAILED) {
                                      if (input.charCodeAt(peg$currPos) === 41) {
                                        s5 = peg$c37;
                                        peg$currPos++;
                                      } else {
                                        s5 = peg$FAILED;
                                        if (peg$silentFails === 0) { peg$fail(peg$c38); }
                                      }
                                      if (s5 !== peg$FAILED) {
                                        peg$savedPos = s0;
                                        s1 = peg$c297(s2, s4);
                                        s0 = s1;
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                              if (s0 === peg$FAILED) {
                                s0 = peg$currPos;
                                if (input.substr(peg$currPos, 12) === peg$c298) {
                                  s1 = peg$c298;
                                  peg$currPos += 12;
                                } else {
                                  s1 = peg$FAILED;
                                  if (peg$silentFails === 0) { peg$fail(peg$c299); }
                                }
                                if (s1 !== peg$FAILED) {
                                  peg$savedPos = s0;
                                  s1 = peg$c300();
                                }
                                s0 = s1;
                                if (s0 === peg$FAILED) {
                                  s0 = peg$currPos;
                                  if (input.substr(peg$currPos, 11) === peg$c301) {
                                    s1 = peg$c301;
                                    peg$currPos += 11;
                                  } else {
                                    s1 = peg$FAILED;
                                    if (peg$silentFails === 0) { peg$fail(peg$c302); }
                                  }
                                  if (s1 !== peg$FAILED) {
                                    peg$savedPos = s0;
                                    s1 = peg$c303();
                                  }
                                  s0 = s1;
                                  if (s0 === peg$FAILED) {
                                    s0 = peg$currPos;
                                    if (input.substr(peg$currPos, 7) === peg$c304) {
                                      s1 = peg$c304;
                                      peg$currPos += 7;
                                    } else {
                                      s1 = peg$FAILED;
                                      if (peg$silentFails === 0) { peg$fail(peg$c305); }
                                    }
                                    if (s1 !== peg$FAILED) {
                                      peg$savedPos = s0;
                                      s1 = peg$c306();
                                    }
                                    s0 = s1;
                                    if (s0 === peg$FAILED) {
                                      s0 = peg$currPos;
                                      if (input.substr(peg$currPos, 8) === peg$c307) {
                                        s1 = peg$c307;
                                        peg$currPos += 8;
                                      } else {
                                        s1 = peg$FAILED;
                                        if (peg$silentFails === 0) { peg$fail(peg$c308); }
                                      }
                                      if (s1 !== peg$FAILED) {
                                        peg$savedPos = s0;
                                        s1 = peg$c309();
                                      }
                                      s0 = s1;
                                      if (s0 === peg$FAILED) {
                                        s0 = peg$currPos;
                                        if (input.substr(peg$currPos, 3) === peg$c310) {
                                          s1 = peg$c310;
                                          peg$currPos += 3;
                                        } else {
                                          s1 = peg$FAILED;
                                          if (peg$silentFails === 0) { peg$fail(peg$c311); }
                                        }
                                        if (s1 !== peg$FAILED) {
                                          peg$savedPos = s0;
                                          s1 = peg$c312();
                                        }
                                        s0 = s1;
                                        if (s0 === peg$FAILED) {
                                          s0 = peg$currPos;
                                          if (input.substr(peg$currPos, 8) === peg$c313) {
                                            s1 = peg$c313;
                                            peg$currPos += 8;
                                          } else {
                                            s1 = peg$FAILED;
                                            if (peg$silentFails === 0) { peg$fail(peg$c314); }
                                          }
                                          if (s1 !== peg$FAILED) {
                                            peg$savedPos = s0;
                                            s1 = peg$c315();
                                          }
                                          s0 = s1;
                                          if (s0 === peg$FAILED) {
                                            s0 = peg$currPos;
                                            if (input.substr(peg$currPos, 7) === peg$c316) {
                                              s1 = peg$c316;
                                              peg$currPos += 7;
                                            } else {
                                              s1 = peg$FAILED;
                                              if (peg$silentFails === 0) { peg$fail(peg$c317); }
                                            }
                                            if (s1 !== peg$FAILED) {
                                              peg$savedPos = s0;
                                              s1 = peg$c318();
                                            }
                                            s0 = s1;
                                            if (s0 === peg$FAILED) {
                                              s0 = peg$currPos;
                                              if (input.substr(peg$currPos, 5) === peg$c319) {
                                                s1 = peg$c319;
                                                peg$currPos += 5;
                                              } else {
                                                s1 = peg$FAILED;
                                                if (peg$silentFails === 0) { peg$fail(peg$c320); }
                                              }
                                              if (s1 !== peg$FAILED) {
                                                peg$savedPos = s0;
                                                s1 = peg$c321();
                                              }
                                              s0 = s1;
                                              if (s0 === peg$FAILED) {
                                                s0 = peg$currPos;
                                                if (input.substr(peg$currPos, 6) === peg$c322) {
                                                  s1 = peg$c322;
                                                  peg$currPos += 6;
                                                } else {
                                                  s1 = peg$FAILED;
                                                  if (peg$silentFails === 0) { peg$fail(peg$c323); }
                                                }
                                                if (s1 !== peg$FAILED) {
                                                  peg$savedPos = s0;
                                                  s1 = peg$c324();
                                                }
                                                s0 = s1;
                                                if (s0 === peg$FAILED) {
                                                  s0 = peg$currPos;
                                                  s1 = peg$parseident();
                                                  if (s1 !== peg$FAILED) {
                                                    peg$savedPos = s0;
                                                    s1 = peg$c325(s1);
                                                  }
                                                  s0 = s1;
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parsecomparison_operator() {
      var s0, s1;

      peg$silentFails++;
      if (input.substr(peg$currPos, 2) === peg$c327) {
        s0 = peg$c327;
        peg$currPos += 2;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c328); }
      }
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c329) {
          s0 = peg$c329;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c330); }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c331) {
            s0 = peg$c331;
            peg$currPos += 2;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c332); }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c333) {
              s0 = peg$c333;
              peg$currPos += 2;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c334); }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 2) === peg$c335) {
                s0 = peg$c335;
                peg$currPos += 2;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c336); }
              }
            }
          }
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c326); }
      }

      return s0;
    }

    function peg$parseliteral_bool() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4) === peg$c337) {
        s1 = peg$c337;
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c338); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseidentchar();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c339();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 5) === peg$c340) {
          s1 = peg$c340;
          peg$currPos += 5;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c341); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          peg$silentFails++;
          s3 = peg$parseidentchar();
          peg$silentFails--;
          if (s3 === peg$FAILED) {
            s2 = void 0;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c342();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }

      return s0;
    }

    function peg$parsekeyword() {
      var s0, s1, s2, s3;

      s0 = peg$parseliteral_bool();
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 3) === peg$c24) {
          s1 = peg$c24;
          peg$currPos += 3;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c25); }
        }
        if (s1 === peg$FAILED) {
          if (input.substr(peg$currPos, 3) === peg$c133) {
            s1 = peg$c133;
            peg$currPos += 3;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c134); }
          }
          if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c86) {
              s1 = peg$c86;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c87); }
            }
            if (s1 === peg$FAILED) {
              if (input.substr(peg$currPos, 2) === peg$c81) {
                s1 = peg$c81;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c82); }
              }
              if (s1 === peg$FAILED) {
                if (input.substr(peg$currPos, 6) === peg$c28) {
                  s1 = peg$c28;
                  peg$currPos += 6;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c29); }
                }
                if (s1 === peg$FAILED) {
                  if (input.substr(peg$currPos, 6) === peg$c162) {
                    s1 = peg$c162;
                    peg$currPos += 6;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c163); }
                  }
                  if (s1 === peg$FAILED) {
                    if (input.substr(peg$currPos, 4) === peg$c112) {
                      s1 = peg$c112;
                      peg$currPos += 4;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c113); }
                    }
                    if (s1 === peg$FAILED) {
                      if (input.substr(peg$currPos, 5) === peg$c40) {
                        s1 = peg$c40;
                        peg$currPos += 5;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c41); }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          peg$silentFails++;
          s3 = peg$parseidentchar();
          peg$silentFails--;
          if (s3 === peg$FAILED) {
            s2 = void 0;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            s1 = [s1, s2];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }

      return s0;
    }

    function peg$parsedqstrchar() {
      var s0, s1;

      if (peg$c343.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c344); }
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c345) {
          s1 = peg$c345;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c346); }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c347();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c348) {
            s1 = peg$c348;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c349); }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c350();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c351) {
              s1 = peg$c351;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c352); }
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c353();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c354) {
                s1 = peg$c354;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c355); }
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c356();
              }
              s0 = s1;
            }
          }
        }
      }

      return s0;
    }

    function peg$parsesqstrchar() {
      var s0, s1;

      if (peg$c357.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c358); }
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c345) {
          s1 = peg$c345;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c346); }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c347();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c348) {
            s1 = peg$c348;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c349); }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c350();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c351) {
              s1 = peg$c351;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c352); }
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c353();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c354) {
                s1 = peg$c354;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c355); }
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c356();
              }
              s0 = s1;
            }
          }
        }
      }

      return s0;
    }

    function peg$parseliteral_string() {
      var s0, s1, s2, s3;

      peg$silentFails++;
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 34) {
        s1 = peg$c360;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c361); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsedqstrchar();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsedqstrchar();
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s3 = peg$c360;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c361); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c362(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 39) {
          s1 = peg$c363;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c364); }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parsesqstrchar();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsesqstrchar();
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 39) {
              s3 = peg$c363;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c364); }
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c362(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c359); }
      }

      return s0;
    }

    function peg$parsedigit() {
      var s0, s1;

      peg$silentFails++;
      if (peg$c366.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c367); }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c365); }
      }

      return s0;
    }

    function peg$parseliteral_number() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 45) {
        s3 = peg$c189;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c190); }
      }
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      if (s3 !== peg$FAILED) {
        s4 = [];
        s5 = peg$parsedigit();
        if (s5 !== peg$FAILED) {
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parsedigit();
          }
        } else {
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 46) {
            s5 = peg$c15;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c16); }
          }
          if (s5 !== peg$FAILED) {
            s6 = [];
            s7 = peg$parsedigit();
            while (s7 !== peg$FAILED) {
              s6.push(s7);
              s7 = peg$parsedigit();
            }
            if (s6 !== peg$FAILED) {
              s7 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 101) {
                s8 = peg$c369;
                peg$currPos++;
              } else {
                s8 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c370); }
              }
              if (s8 !== peg$FAILED) {
                s9 = [];
                s10 = peg$parsedigit();
                if (s10 !== peg$FAILED) {
                  while (s10 !== peg$FAILED) {
                    s9.push(s10);
                    s10 = peg$parsedigit();
                  }
                } else {
                  s9 = peg$FAILED;
                }
                if (s9 !== peg$FAILED) {
                  s8 = [s8, s9];
                  s7 = s8;
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
              if (s7 === peg$FAILED) {
                s7 = null;
              }
              if (s7 !== peg$FAILED) {
                s3 = [s3, s4, s5, s6, s7];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = input.substring(s1, peg$currPos);
      } else {
        s1 = s2;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c371(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 45) {
          s3 = peg$c189;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c190); }
        }
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 46) {
            s4 = peg$c15;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c16); }
          }
          if (s4 !== peg$FAILED) {
            s5 = [];
            s6 = peg$parsedigit();
            if (s6 !== peg$FAILED) {
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$parsedigit();
              }
            } else {
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 101) {
                s7 = peg$c369;
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c370); }
              }
              if (s7 !== peg$FAILED) {
                s8 = [];
                s9 = peg$parsedigit();
                if (s9 !== peg$FAILED) {
                  while (s9 !== peg$FAILED) {
                    s8.push(s9);
                    s9 = peg$parsedigit();
                  }
                } else {
                  s8 = peg$FAILED;
                }
                if (s8 !== peg$FAILED) {
                  s7 = [s7, s8];
                  s6 = s7;
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              if (s6 === peg$FAILED) {
                s6 = null;
              }
              if (s6 !== peg$FAILED) {
                s3 = [s3, s4, s5, s6];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = input.substring(s1, peg$currPos);
        } else {
          s1 = s2;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c371(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 45) {
            s3 = peg$c189;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c190); }
          }
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$parsedigit();
            if (s5 !== peg$FAILED) {
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parsedigit();
              }
            } else {
              s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 101) {
                s6 = peg$c369;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c370); }
              }
              if (s6 !== peg$FAILED) {
                s7 = [];
                s8 = peg$parsedigit();
                if (s8 !== peg$FAILED) {
                  while (s8 !== peg$FAILED) {
                    s7.push(s8);
                    s8 = peg$parsedigit();
                  }
                } else {
                  s7 = peg$FAILED;
                }
                if (s7 !== peg$FAILED) {
                  s6 = [s6, s7];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              if (s5 === peg$FAILED) {
                s5 = null;
              }
              if (s5 !== peg$FAILED) {
                s3 = [s3, s4, s5];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            s1 = input.substring(s1, peg$currPos);
          } else {
            s1 = s2;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c371(s1);
          }
          s0 = s1;
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c368); }
      }

      return s0;
    }

    function peg$parseidentstart() {
      var s0;

      if (peg$c372.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c373); }
      }

      return s0;
    }

    function peg$parseidentchar() {
      var s0;

      if (peg$c374.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c375); }
      }

      return s0;
    }

    function peg$parseident() {
      var s0, s1, s2, s3, s4, s5, s6;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$currPos;
      peg$silentFails++;
      s2 = peg$parsekeyword();
      peg$silentFails--;
      if (s2 === peg$FAILED) {
        s1 = void 0;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$currPos;
        s4 = peg$parseidentstart();
        if (s4 !== peg$FAILED) {
          s5 = [];
          s6 = peg$parseidentchar();
          while (s6 !== peg$FAILED) {
            s5.push(s6);
            s6 = peg$parseidentchar();
          }
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          s2 = input.substring(s2, peg$currPos);
        } else {
          s2 = s3;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c377(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c376); }
      }

      return s0;
    }

    function peg$parseclassidentchar() {
      var s0;

      if (peg$c378.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c379); }
      }

      return s0;
    }

    function peg$parseclassident() {
      var s0, s1, s2, s3, s4;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$parseidentstart();
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parseclassidentchar();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parseclassidentchar();
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s0 = input.substring(s0, peg$currPos);
      } else {
        s0 = s1;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c380); }
      }

      return s0;
    }

    function peg$parse_() {
      var s0, s1;

      s0 = [];
      s1 = peg$parsewhitespace();
      if (s1 === peg$FAILED) {
        s1 = peg$parsecomment();
      }
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        s1 = peg$parsewhitespace();
        if (s1 === peg$FAILED) {
          s1 = peg$parsecomment();
        }
      }

      return s0;
    }

    function peg$parse__() {
      var s0, s1;

      s0 = [];
      s1 = peg$parsewhitespace();
      if (s1 === peg$FAILED) {
        s1 = peg$parsecomment();
      }
      if (s1 !== peg$FAILED) {
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parsewhitespace();
          if (s1 === peg$FAILED) {
            s1 = peg$parsecomment();
          }
        }
      } else {
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        peg$silentFails++;
        s1 = peg$parseidentchar();
        peg$silentFails--;
        if (s1 === peg$FAILED) {
          s0 = void 0;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }

      return s0;
    }

    function peg$parsewhitespace() {
      var s0, s1;

      peg$silentFails++;
      if (peg$c382.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c383); }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c381); }
      }

      return s0;
    }

    function peg$parsecomment() {
      var s0, s1, s2, s3, s4, s5;

      peg$silentFails++;
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c385) {
        s1 = peg$c385;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c386); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        if (peg$c387.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c388); }
        }
        if (s3 === peg$FAILED) {
          s3 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 42) {
            s4 = peg$c17;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c18); }
          }
          if (s4 !== peg$FAILED) {
            if (peg$c389.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c390); }
            }
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          if (peg$c387.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c388); }
          }
          if (s3 === peg$FAILED) {
            s3 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 42) {
              s4 = peg$c17;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c18); }
            }
            if (s4 !== peg$FAILED) {
              if (peg$c389.test(input.charAt(peg$currPos))) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c390); }
              }
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
        }
        if (s2 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c391) {
            s3 = peg$c391;
            peg$currPos += 2;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c392); }
          }
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c393) {
          s1 = peg$c393;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c394); }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          if (peg$c395.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c396); }
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            if (peg$c395.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c396); }
            }
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 10) {
              s3 = peg$c397;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c398); }
            }
            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c384); }
      }

      return s0;
    }


        var Ast = require('./ast');
        var Type = require('./type');
        var Units = require('./units');
        var { optimizeFilter, optimizeProgram } = require('./optimize');

        function take(array, idx) {
            return array.map(function(v) { return v[idx]; });
        }


    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail({ type: "end", description: "end of input" });
      }

      throw peg$buildException(
        null,
        peg$maxFailExpected,
        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
        peg$maxFailPos < input.length
          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
      );
    }
  }

  return {
    SyntaxError: peg$SyntaxError,
    parse:       peg$parse
  };
})();

},{"./ast":44,"./optimize":60,"./type":65,"./units":67}],56:[function(require,module,exports){
// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2017 The Board of Trustees of the Leland Stanford Junior University
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
//
// See COPYING for details
"use strict";

const Grammar = require('./grammar');
// Initialize the AST API
require('./ast_api');

module.exports = {
    parse(code) {
        return Grammar.parse(code);
    },
    parseAndTypecheck(code, schemaRetriever, useMeta = false) {
        let ast = Grammar.parse(code);
        return ast.typecheck(schemaRetriever, useMeta);
    },

    parseType(typeStr) {
        return Grammar.parse(typeStr, { startRule: 'type_ref' });
    },

    parsePermissionRule(code) {
        return Grammar.parse(code, { startRule: 'permission_rule' });
    }
};
},{"./ast_api":45,"./grammar":55}],57:[function(require,module,exports){
// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2015-2016 The Board of Trustees of the Leland Stanford Junior University
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
//
// See COPYING for details
"use strict";

const Builtin = require('./builtin');
const { stringEscape } = require('./escaping');
const Utils = require('./utils');

// A register-based IR for ThingTalk to JS
// Typed like ThingTalk

// A sequence of instructions
class Block {
    constructor() {
        this._instructions = [];
    }

    add(instr) {
        this._instructions.push(instr);
    }

    codegen(prefix) {
        return this._instructions.map((i) => i.codegen(prefix)).join('\n');
    }
}

class Copy {
    constructor(what, into) {
        this._what = what;
        this._into = into;
    }

    codegen(prefix) {
        return `${prefix}_t_${this._into} = _t_${this._what};`;
    }
}

class CreateTuple {
    constructor(size, into) {
        this._size = size;
        this._into = into;
    }

    codegen(prefix) {
        return prefix + '_t_' + this._into + ' = new Array(' + this._size + ');';
    }
}

class CreateObject {
    constructor(into) {
        this._into = into;
    }

    codegen(prefix) {
        return `${prefix}_t_${this._into} = {};`;
    }
}

class CreateAggregation {
    constructor(aggregation, into) {
        this._aggregation = aggregation;
        this._into = into;
    }

    codegen(prefix) {
        let type = `"${this._aggregation.type}"`;
        let field = this._aggregation.field ? `"${this._aggregation.field}"` : 'null';
        let cols = this._aggregation.cols ? `["${this._aggregation.cols.join('", "')}"]` : 'null';
        let count = this._aggregation.count ? `${this._aggregation.count}` : 'null';
        return prefix + '_t_' + this._into + ' = new __builtin.Aggregation(' + type + ', ' + field + ', ' + cols + ', ' + count + ');';
    }
}

class SetIndex {
    constructor(tuple, idx, value) {
        this._tuple = tuple;
        this._idx = idx;
        this._value = value;
    }

    codegen(prefix) {
        return prefix + '_t_' + this._tuple + '[' + this._idx + '] = _t_' + this._value + ';';
    }
}

class GetIndex {
    constructor(tuple, idx, into) {
        this._tuple = tuple;
        this._idx = idx;
        this._into = into;
    }

    codegen(prefix) {
        return prefix + '_t_' + this._into + ' = _t_' + this._tuple + '[' + this._idx + '];';
    }
}

class GetKey {
    constructor(object, key, into) {
        this._object = object;
        this._key = key;
        this._into = into;
    }

    codegen(prefix) {
        return `${prefix}_t_${this._into} = _t_${this._object}.${this._key};`;
    }
}

class SetKey {
    constructor(object, key, value) {
        this._object = object;
        this._key = key;
        this._value = value;
    }

    codegen(prefix) {
        if (this._value === null)
            return `${prefix}_t_${this._object}.${this._key} = null;`;
        else
            return `${prefix}_t_${this._object}.${this._key} = _t_${this._value};`;
    }
}

class GetVariable {
    constructor(variable, into) {
        this._variable = variable;
        this._into = into;
    }

    codegen(prefix) {
        return prefix + '_t_' + this._into + ' = env._scope.' + this._variable + ';';
    }
}

class GetEnvironment {
    constructor(variable, into) {
        this._variable = variable;
        this._into = into;
    }

    codegen(prefix) {
        return `${prefix}_t_${this._into} = env.${this._variable};`;
    }
}

class Iterator {
    constructor(into, iterable) {
        this._iterable = iterable;
        this._into = into;
    }

    codegen(prefix) {
        return `${prefix}_t_${this._into} = _t_${this._iterable}[Symbol.iterator]();`;
    }
}

function valueToJSSource(value) {
    if (value === null)
        return 'null';
    if (value.isArray)
        return `[${value.value.map(valueToJSSource).join(', ')}]`;
    var js = value.toJS();
    if (typeof js === 'string')
        return stringEscape(js);
    if (js.toJSSource)
        return js.toJSSource();
    if (js instanceof Date)
        return `new Date(${js.getTime()})`;
    return String(js);
}

class LoadConstant {
    constructor(constant, into) {
        this._constant = constant;
        this._into = into;
    }

    codegen(prefix) {
        return prefix + '_t_' + this._into + ' = ' + valueToJSSource(this._constant) + ';';
    }
}

class FormatEvent {
    constructor(hint, outputType, output, into) {
        this._hint = hint;
        this._outputType = outputType;
        this._output = output;
        this._into = into;
    }

    codegen(prefix) {
        if (this._outputType === null)
            return `${prefix}_t_${this._into} = yield env.formatEvent(null, _t_${this._output}, ${stringEscape(this._hint)});`;
        else
            return `${prefix}_t_${this._into} = yield env.formatEvent(_t_${this._outputType}, _t_${this._output}, ${stringEscape(this._hint)});`;
    }
}

class BinaryFunctionOp {
    constructor(a, b, fn, into) {
        this._a = a;
        this._b = b;
        this._fn = fn;
        this._into = into;
    }

    codegen(prefix) {
        return `${prefix}_t_${this._into} = __builtin.${this._fn}(_t_${this._a}, _t_${this._b});`;
    }
}

class BinaryOp {
    constructor(a, b, op, into) {
        this._a = a;
        this._b = b;
        this._op = op;
        this._into = into;
    }

    codegen(prefix) {
        return prefix + '_t_' + this._into + ' = ' + '_t_' + this._a + ' ' + this._op + ' ' + '_t_' + this._b + ';';
    }
}

class UnaryOp {
    constructor(v, op, into) {
        this._v = v;
        this._op = op;
        this._into = into;
    }

    codegen(prefix) {
        return prefix + '_t_' + this._into + ' = ' + this._op + ' (' + '_t_' + this._v + ');';
    }
}

class InvokeMonitor {
    constructor(f, into, args, once) {
        this._f = f;
        this._into = into;
        this._args = args;
        this._once = once;
    }

    codegen(prefix) {
        return prefix + '_t_' + this._into + ' = yield env.invokeMonitor(' + this._f + ', _t_' + this._args + ', ' + this._once + ');';
    }
}

class InvokeTimer {
    constructor(into, base, interval) {
        this._into = into;
        this._base = base;
        this._interval = interval;
    }

    codegen(prefix) {
        return `${prefix}_t_${this._into} = yield env.invokeTimer(_t_${this._base}, _t_${this._interval});`;
    }
}

class InvokeAtTimer {
    constructor(into, time) {
        this._into = into;
        this._time = time;
    }

    codegen(prefix) {
        return `${prefix}_t_${this._into} = yield env.invokeAtTimer(_t_${this._time});`;
    }
}

class InvokeQuery {
    constructor(f, into, args) {
        this._f = f;
        this._into = into;
        this._args = args;
    }

    codegen(prefix) {
        return prefix + '_t_' + this._into + ' = yield env.invokeQuery(' + this._f + ', _t_' + this._args + ');';
    }
}

class InvokeAction {
    constructor(f, args) {
        this._f = f;
        this._args = args;
    }

    codegen(prefix) {
        return prefix + 'yield env.invokeAction(' + this._f + ', _t_' + this._args + ');';
    }
}

class InvokeOutput {
    constructor(outputType, output) {
        this._outputType = outputType;
        this._output = output;
    }

    codegen(prefix) {
        if (this._outputType === null)
            return `${prefix}yield env.output(null, _t_${this._output});`;
        else
            return `${prefix}yield env.output(String(_t_${this._outputType}), _t_${this._output});`;
    }
}

class InvokeReadState {
    constructor(into, stateId) {
        this._into = into;
        this._stateId = stateId;
    }

    codegen(prefix) {
        return `${prefix}_t_${this._into} = yield env.readState(${this._stateId});`;
    }
}

class InvokeWriteState {
    constructor(state, stateId) {
        this._state = state;
        this._stateId = stateId;
    }

    codegen(prefix) {
        return `${prefix}yield env.writeState(${this._stateId}, _t_${this._state});`;
    }
}

class CheckIsNewTuple {
    constructor(into, state, tuple, keys) {
        this._into = into;
        this._state = state;
        this._tuple = tuple;
        this._keys = keys;
    }

    codegen(prefix) {
        return `${prefix}_t_${this._into} = __builtin.isNewTuple(_t_${this._state}, _t_${this._tuple}, [${
            this._keys.map(stringEscape).join(', ')}]);`;
    }
}

class AddTupleToState {
    constructor(into, state, tuple) {
        this._into = into;
        this._state = state;
        this._tuple = tuple;
    }

    codegen(prefix) {
        return `${prefix}_t_${this._into} = __builtin.addTuple(_t_${this._state}, _t_${this._tuple});`;
    }
}

class SendEndOfFlow {
    constructor(principal, flow) {
        this._principal = principal;
        this._flow = flow;
    }

    codegen(prefix) {
        return `${prefix}yield env.sendEndOfFlow(_t_${this._principal}, _t_${this._flow});`;
    }
}

class ClearGetCache {
    codegen(prefix) {
        return prefix + 'env.clearGetCache();';
    }
}

class Break {
    codegen(prefix) {
        return prefix + 'break;';
    }
}

class IfStatement {
    constructor(cond) {
        this._cond = cond;
        this.iftrue = new Block;
        this.iffalse = new Block;
    }

    codegen(prefix) {
        return prefix + 'if (_t_' + this._cond + ') {\n' +
            this.iftrue.codegen(prefix + '  ') + '\n'
            + prefix + '} else {\n' +
            this.iffalse.codegen(prefix + '  ') + '\n'
            + prefix + '}';
    }
}

class ForOfStatement {
    constructor(into, iterable) {
        this._into = into;
        this._iterable = iterable;
        this.body = new Block;
    }

    codegen(prefix) {
        return prefix + 'for (_t_' + this._into + ' of _t_' + this._iterable + ') {\n' +
            this.body.codegen(prefix + '  ') + '\n'
            + prefix + '}';
    }
}

class AsyncWhileLoop {
    constructor(into, iterator) {
        this._into = into;
        this._iterator = iterator;
        this.body = new Block;
    }

    codegen(prefix) {
        return prefix + '{\n' +
            prefix + '  let _iter_tmp = yield _t_' + this._iterator + '.next();\n' +
            prefix + '  while (!_iter_tmp.done) {\n' +
            prefix + '    _t_' + this._into + ' = _iter_tmp.value;\n' +
            this.body.codegen(prefix + '    ') + '\n' +
            prefix + '    _iter_tmp = yield _t_' + this._iterator + '.next();\n' +
            prefix + '  }\n' +
            prefix + '}';
    }
}

class GeneratorExpression {
    constructor(into) {
        this._into = into;
        this.body = new Block;
    }

    codegen(prefix) {
        return prefix + `_t_${this._into} = function*(emit) {\n` +
            this.body.codegen(prefix + '  ') + '\n' +
            prefix + '}';
    }
}

class InvokeEmit {
    constructor(value) {
        this._value = value;
    }

    codegen(prefix) {
        return `${prefix}emit(_t_${this._value})`;
    }
}

class LabeledLoop {
    constructor(label) {
        this._label = label;
        this.body = new Block;
    }

    codegen(prefix) {
        return prefix + `_l_${this._label}: while (true) {\n` +
            this.body.codegen(prefix + '  ') + '\n' +
            prefix + '}';
    }
}

class LabeledBreak {
    constructor(label) {
        this._label = label;
    }

    codegen(prefix) {
        return `${prefix}break _l_${this._label};`;
    }
}

class LabeledContinue {
    constructor(label) {
        this._label = label;
    }

    codegen(prefix) {
        return `${prefix}continue _l_${this._label};`;
    }
}

class TryCatch {
    constructor(message) {
        this._message = message;
        this.try = new Block;
    }

    codegen(prefix) {
        return prefix + 'try {\n' +
        this.try.codegen(prefix + '  ') + '\n' +
        prefix + '} catch(_exc_) {\n' +
        prefix + '  env.reportError(' + stringEscape(this._message) + ', _exc_);\n' +
        prefix + '}';
    }
}

class RootBlock extends Block {
    constructor() {
        super();
        this._temps = [];
    }

    declare(reg) {
        this._temps.push(reg);
    }
    codegen(prefix) {
        return prefix + '  "use strict";\n' + this._temps.map((t) => prefix + '  let _t_' + t + ';\n').join('') +
            super.codegen(prefix+'  ');
    }
}

const GeneratorFunction = Object.getPrototypeOf(function*(){}).constructor;
class IRBuilder {
    constructor() {
        this._nextRegister = 0;
        this._nextLabel = 0;
        this._root = new RootBlock;

        this._blockStack = [this._root];
    }

    codegen() {
        for (let reg = 0; reg < this._nextRegister; reg++)
            this._root.declare(reg);
        return this._root.codegen('');
    }
    compile() {
        let code = this.codegen();
        let f = new GeneratorFunction('__builtin', 'env', code);
        return Utils.generatorToAsync(f).bind(null, Builtin);
    }

    get _currentBlock() {
        return this._blockStack[this._blockStack.length-1];
    }

    allocRegister() {
        var reg = this._nextRegister++;
        return reg;
    }
    allocLabel() {
        var lbl = this._nextLabel++;
        return lbl;
    }
    pushBlock(block) {
        let now = this._blockStack.length;
        this._blockStack.push(block);
        return now;
    }
    popBlock() {
        this._blockStack.pop();
        if (this._blockStack.length === 0)
            throw new Error('Invalid pop');
    }
    popTo(upto) {
        this._blockStack.length = upto;
    }
    popAll() {
        this._blockStack.length = 0;
        this._blockStack[0] = this._root;
    }
    add(instr) {
        this._currentBlock.add(instr);
    }
}

module.exports = {
    IRBuilder,
    IfStatement,
    Copy,
    CreateTuple,
    CreateObject,
    CreateAggregation,
    GetIndex,
    SetIndex,
    GetKey,
    SetKey,
    GetVariable,
    GetEnvironment,
    Iterator,
    LoadConstant,
    BinaryFunctionOp,
    BinaryOp,
    UnaryOp,
    FormatEvent,
    InvokeMonitor,
    InvokeTimer,
    InvokeAtTimer,
    InvokeQuery,
    InvokeAction,
    InvokeOutput,
    InvokeReadState,
    InvokeWriteState,
    InvokeEmit,
    CheckIsNewTuple,
    AddTupleToState,
    LabeledLoop,
    LabeledBreak,
    LabeledContinue,
    ClearGetCache,
    SendEndOfFlow,
    ForOfStatement,
    AsyncWhileLoop,
    GeneratorExpression,
    Break,
    TryCatch
};

},{"./builtin":46,"./escaping":51,"./utils":68}],58:[function(require,module,exports){
// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2017 The Board of Trustees of the Leland Stanford Junior University
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
//
// See COPYING for details
"use strict";

const Ast = require('./ast');
const Generate = require('./generate');
const { parseDate } = require('./date_utils');

/**
 * Differences with the actual NN Grammar (as written in
 * almond-nnparser/grammar/thingtalk.py):
 *
 * - almond-nnparser's grammar distinguishes $get and $do, while
 *   while this one uses just $call
 *   almond-nnparser can do that because it knows the full list of
 *   gets and dos (and knows that they don't interset), whereas here
 *   we have a single FUNCTION token
 * - almond-nnparser's grammar is typed around parameter types and
 *   constants, this one is not because otherwise it would be too unwieldly
 *   to write
 * - almond-nnparser uses different terminals for <entity>_i because
 *   it autogenerates the grammar; this grammar uses a single terminal
 *   <entity> plus a lexical analysis step because I was too lazy to write
 *   down all cases by hand
 *
 * Missing features, compared with full TT:
 * - single statement
 * - no complex selectors
 * - no remote primitives (yet)
 * - no declarations
 * - no multi-field projection
 * - no alias (in aggregate and as a table/stream operator)
 * - no compute
 *
 * Differences with full TT:
 * - all filter operators are infix
 * - multiple parameter passings are prefixed with on in a join
 * - function names are one token
 * - parameter names are prefixed with param:
 * - enum choices are prefixed with enum:
 * - units are prefixed with unit:
 * - relative locations are prefixed with location:
 *
 * What to keep in mind when writing the grammar:
 * - shifts are cheap, reduces are expensive
 * - adding more symbols to a rule only increases the number of shifts
 * - adding more non-terminals to the grammar increases the number of
 *   reduces
 * - splitting a rule into multiple non-terminals increases the number of
 *   reduces
 * - the breadth of reduces matters too
 * - the overall number of rules affects the breadth of reduces
 */

const identity = (x) => x;

// ignore the whole exports for coverage; coverage will occur of the copies
// of the functions that appear later
/* istanbul ignore next */
module.exports = {
    '$input':         [[['$program',], identity],
                       [['answer', '$constant'], (_, constant) => constant],
                       [['filter', '$filter'], (_, filter) => filter],
                       [['policy', '$policy'], (_, policy) => policy]],

    '$program':       [[['$rule',], (rule) => new Ast.Program([], [], [rule], null)],
                       [['executor', '=', '$constant', ':', '$rule'], (_1, _2, user, _3, rule) => new Ast.Program([], [], [rule], new Ast.Value.Entity(user.value, 'tt:username', null))]],

    '$policy':        [[['true', ':', '$policy_body'], (_1, _2, policy) => policy],
                       [['$filter', ':', '$policy_body'], (user, _, policy) => policy.set({ principal: user })]],

    '$policy_body':   [[['now', '=>', '$policy_fn'], (_1, _2, action) => new Ast.PermissionRule(Ast.BooleanExpression.True, Ast.PermissionFunction.Builtin, action)],
                       [['$policy_fn', '=>', 'notify'], (query, _1, _2) => new Ast.PermissionRule(Ast.BooleanExpression.True, query, Ast.PermissionFunction.Builtin)],
                       [['$policy_fn', '=>', '$policy_fn'], (query, _1, action) => new Ast.PermissionRule(Ast.BooleanExpression.True, query, action)]],

    '$policy_fn':     [[['*'], (_) => Ast.PermissionFunction.Star],
                       [['CLASS_STAR'], (klass) => new Ast.PermissionFunction.ClassStar(klass.value)],
                       [['FUNCTION'], (fn) => new Ast.PermissionFunction.Specified(fn.value.kind, fn.value.channel, Ast.BooleanExpression.True, null)],
                       [['FUNCTION', 'filter', '$filter'], (fn, _, filter) => new Ast.PermissionFunction.Specified(fn.value.kind, fn.value.channel, filter, null)]],

    '$rule':          [[['$stream', '=>', '$action'], (stream, _, action) => new Ast.Statement.Rule(stream, [action])],
                       [['now', '=>', '$table', '=>', '$action'], (_1, _2, table, _3, action) => new Ast.Statement.Command(table, [action])],
                       [['now', '=>', '$action'], (_1, _2, action) => new Ast.Statement.Command(null, [action])],
                       [['$rule', 'on', '$param_passing'], (rule, _, pp) => {
                           rule.actions[0].in_params.push(pp);
                           return rule;
                       }]],

    '$table':         [[['$call',], (get) => Ast.Table.Invocation(get, null)],
                       [['(', '$table', ')', 'filter', '$filter'], (_1, table, _2, _3, filter) => new Ast.Table.Filter(table, filter, null)],
                       [['aggregate', 'min', '$out_param', 'of', '(', '$table', ')'], (_1, op, field, _2, _3, table, _4) => new Ast.Table.Aggregation(table, field.name, op, null, null)],
                       [['aggregate', 'max', '$out_param', 'of', '(', '$table', ')'], (_1, op, field, _2, _3, table, _4) => new Ast.Table.Aggregation(table, field.name, op, null, null)],
                       [['aggregate', 'sum', '$out_param', 'of', '(', '$table', ')'], (_1, op, field, _2, _3, table, _4) => new Ast.Table.Aggregation(table, field.name, op, null, null)],
                       [['aggregate', 'avg', '$out_param', 'of', '(', '$table', ')'], (_1, op, field, _2, _3, table, _4) => new Ast.Table.Aggregation(table, field.name, op, null, null)],
                       [['aggregate', 'count', 'of', '(', '$table', ')'], (_1, op, _2, _3, table, _4) => new Ast.Table.Aggregation(table, '*', op, null, null)],
                       [['aggregate', 'argmin', '$out_param', '$constant_Number', ',', '$constant_Number', 'of', '(', '$table', ')'], (_1, op, field, base, _2, limit, _3, _4, table, _5) => new Ast.Table.ArgMinMax(table, field.name, op, null, null)],
                       [['aggregate', 'argmax', '$out_param', '$constant_Number', ',', '$constant_Number', 'of', '(', '$table', ')'], (_1, op, field, base, _2, limit, _3, _4, table, _5) => new Ast.Table.ArgMinMax(table, field.name, op, null, null)],
                       [['$table_join'], identity],
                       [['window', '$constant_Number', ',', '$constant_Number', 'of', '(', '$stream', ')'], (_1, base, _2, delta, _3, _4, stream, _5) => new Ast.Table.Window(base, delta, stream, null)],
                       [['timeseries', '$constant_Date', ',', '$constant_Measure(ms)', 'of', '(', '$stream', ')'], (_1, base, _2, delta, _3, _4, stream, _5) => new Ast.Table.TimeSeries(base, delta, stream, null)],
                       [['sequence', '$constant_Number', ',', '$constant_Number', 'of', '(', '$table', ')'], (_1, base, _2, delta, _3, _4, table, _5) => new Ast.Table.Sequence(base, delta, table, null)],
                       [['history', '$constant_Date', ',', '$constant_Measure(ms)', 'of', '(', '$table', ')'], (_1, base, _2, delta, _3, _4, table, _5) => new Ast.Table.History(base, delta, table, null)]],

    '$table_join':    [[['(', '$table', ')', 'join', '(', '$table', ')'], (_1, t1, _2, _3, _4, t2, _5) => new Ast.Table.Join(t1, t2, [], null)],
                       [['$table_join', 'on', '$param_passing'], (join, _, pp) => {
                           join.in_params.push(pp);
                           return join;
                       }]],

    '$stream':        [[['timer', 'base', '=', '$constant_Date', ',', 'interval', '=', '$constant_Measure(ms)'], (_1, _2, _3, base, _4, _5, _6, interval) => new Ast.Stream.Timer(base, interval, null)],
                       [['attimer', 'time', '=', '$constant_Time'], (_1, _2, _3, time) => new Ast.Stream.AtTimer(time, null)],
                       [['monitor', '(', '$table', ')'], (monitor, _1, table, _2) => new Ast.Stream.Monitor(table, null, null)],
                       [['monitor', '(', '$table', ')', 'on', 'new', '$out_param'], (monitor, _1, table, _2, _3, _4, pname) => new Ast.Stream.Monitor(table, [pname.name], null)],
                       [['monitor', '(', '$table', ')', 'on', 'new', '[', '$out_param_list', ']'], (monitor, _1, table, _2, _3, _4, _5, pnames, _6) => new Ast.Stream.Monitor(table, pnames.map((p) => p.name), null)],
                       [['edge', '(', '$stream', ')', 'on', '$filter'], (_1, _2, stream, _3, _4, filter) => new Ast.Stream.EdgeFilter(stream, filter, null)],
                       // edge on true is the equivalent of "only once"
                       [['edge', '(', '$stream', ')', 'on', 'true'], (_1, _2, stream, _3, _4, filter) => new Ast.Stream.EdgeFilter(stream, Ast.BooleanExpression.True, null)],
                       [['$stream_join'], identity]],

    '$stream_join':   [[['(', '$stream', ')', 'join', '(', '$table', ')'], (_1, s1, _2, _3, _4, t2, _5) => new Ast.Stream.Join(s1, t2, [], null)],
                       [['$stream_join', 'on', '$param_passing'], (join, _, pp) => {
                           join.in_params.push(pp);
                           return join;
                       }]],

    '$action':        [[['notify'], () => Generate.notifyAction()],
                       [['return'], () => Generate.notifyAction('return')],
                       [['$call'], identity]],

    '$call':          [[['FUNCTION'], (fn) => new Ast.Invocation(new Ast.Selector.Device(fn.value.kind, null, null), fn.value.channel, [], null)],
                       [['$call', '$const_param'], (inv, ip) => {
                           inv.in_params.push(ip);
                           return inv;
                       }]],

    '$param_passing': [[['PARAM_NAME', '=', '$out_param'], (pname, _1, out_param) => new Ast.InputParam(pname.value, out_param)],
                       [['PARAM_NAME', '=', 'event'], (pname, _1, _2) => new Ast.InputParam(pname.value, new Ast.Value.Event(null))]],

    '$const_param':   [[['PARAM_NAME', '=', '$constant'], (pname, _1, v) => new Ast.InputParam(pname.value, v)]],

    '$out_param':     [[['PARAM_NAME'], (pname) => new Ast.Value.VarRef(pname.value)]],

    '$out_param_list':[[['$out_param'], (pname) => [pname]],
                       [['$out_param_list', ',', '$out_param'], (list, _, pname) => list.concat(pname)]],

    // note that $filter is not recursive!
    // it must be in CNF form
    // also note that and takes priority over or
    // this is the opposite of regular TT (which copies JS in that respect)
    // because most filters are just a list of
    // "condition and this or that and foo or bar"
    // to be read as
    // "condition and (this or that) and (foo or bar)"
    '$filter':        [[['$or_filter'], identity],
                       [['$filter', 'and', '$or_filter'], (f1, _, f2) => new Ast.BooleanExpression.And([f1, f2])]],

    '$or_filter':     [[['$atom_filter'], identity],
                       [['not', '$atom_filter'], (_, f) => new Ast.BooleanExpression.Not(f)],
                       [['$or_filter', 'or', '$atom_filter'], (f1, _, f2) => new Ast.BooleanExpression.Or([f1, f2])]],

    '$atom_filter':   [[['PARAM_NAME', '$value_filter'], (pname, [op, v]) => new Ast.BooleanExpression.Atom(pname.value, op, v)],
                       [['$call', '{', '$filter', '}'], (fn, _1, filter, _3) => new Ast.BooleanExpression.External(fn.selector, fn.channel, fn.in_params, filter, fn.schema)]],

    // in almond-nnparser these are strongly typed constants, so only
    // numbers and measures can be compared for order, etc
    // we're a little looser here because otherwise it becomes unwieldly
    '$value_filter':  [[['==', '$constant'], (op, v) => [op, v]],
                       [['>=', '$constant'], (op, v) => [op, v]],
                       [['<=', '$constant'], (op, v) => [op, v]],
                       [['>', '$constant'], (op, v) => [op, v]],
                       [['<', '$constant'], (op, v) => [op, v]],
                       [['=~', '$constant'], (op, v) => [op, v]],
                       [['~=', '$constant'], (op, v) => [op, v]],
                       [['starts_with', '$constant'], (op, v) => [op, v]],
                       [['ends_with',  '$constant'], (op, v) => [op, v]],
                       [['prefix_of',  '$constant'], (op, v) => [op, v]],
                       [['suffix_of',  '$constant'], (op, v) => [op, v]],
                       [['contains',  '$constant'], (op, v) => [op, v]],
                       [['in_array',  '$constant_Array'], (op, v) => [op, v]],

                       [['==', '$out_param'], (op, v) => [op, v]],
                       [['>=', '$out_param'], (op, v) => [op, v]],
                       [['<=', '$out_param'], (op, v) => [op, v]],
                       [['>', '$out_param'], (op, v) => [op, v]],
                       [['<', '$out_param'], (op, v) => [op, v]],
                       [['=~', '$out_param'], (op, v) => [op, v]],
                       [['~=', '$out_param'], (op, v) => [op, v]],
                       [['starts_with', '$out_param'], (op, v) => [op, v]],
                       [['ends_with',  '$out_param'], (op, v) => [op, v]],
                       [['prefix_of',  '$out_param'], (op, v) => [op, v]],
                       [['suffix_of',  '$out_param'], (op, v) => [op, v]],
                       [['contains',  '$out_param'], (op, v) => [op, v]],
                       [['in_array',  '$out_param'], (op, v) => [op, v]]],

    // this non-terminal exists only for convenience
    // the almond nn-parser grammar does not have it
    '$constant':      [[['$constant_Array'], identity],
                       [['$constant_Boolean'], identity],
                       [['$constant_String'], identity],
                       [['$constant_Measure'], identity],
                       [['DURATION'], (tok) => new Ast.Value.Measure(tok.value.value, tok.value.unit)],
                       [['$constant_Number'], identity],
                       [['$constant_Currency'], identity],
                       [['$constant_Location'], identity],
                       [['$constant_Date'], identity],
                       [['$constant_Time'], identity],
                       [['$constant_Entity(unknown)'], identity],
                       [['$constant_Entity(tt:username)'], identity],
                       [['$constant_Entity(tt:hashtag)'], identity],
                       [['$constant_Entity(tt:phone_number)'], identity],
                       [['$constant_Entity(tt:email_address)'], identity],
                       [['$constant_Entity(tt:path_name)'], identity],
                       [['$constant_Entity(tt:url)'], identity],
                       [['$constant_Entity(tt:device)'], identity],
                       [['$constant_Entity(tt:function)'], identity],
                       [['$constant_Entity(tt:picture)'], identity],
                       [['$constant_Enum'], identity],
                       [['SLOT'], (slot) => slot.value === undefined ? Ast.Value.Undefined(true) : slot.value]],

    // we cannot represent an empty array
    // I don't think that's useful anyway
    '$constant_Array': [[['[', '$constant_array_values', ']'], (_1, values, _2) => new Ast.Value.Array(values)]],

    '$constant_array_values': [[['$constant'], (v) => [v]],
                               [['$constant_array_values', ',', '$constant'], (array, _, v) => {
                                   array.push(v);
                                   return array;
                               }]],

    '$constant_Boolean': [[['true'], () => new Ast.Value.Boolean(true)],
                          [['false'], () => new Ast.Value.Boolean(false)]],

    '$constant_String': [[['""'], (str) => new Ast.Value.String('')],
                         [['QUOTED_STRING'], (str) => new Ast.Value.String(str.value)],
                         [['"', '$word_list', '"'], (_1, str, _2) => new Ast.Value.String(str)],
                         ],

    '$word_list': [[['WORD'], (word) => word.value],
                   [['$word_list', 'WORD'], (list, word) => list + ' ' + word.value]],

    // play fast and loose with units here, because I don't want to write
    // everything by hand
    // almond-nnparser autogenerates this part
    '$constant_Measure': [[['$constant_Number', 'UNIT'], (num, unit) => new Ast.Value.Measure(num.value, unit.value)],
                          [['$constant_Measure', '$constant_Number', 'UNIT'], (v1, num, unit) => {
                              if (v1.isCompoundMeasure) {
                                  v1.value.push(new Ast.Value.Measure(num.value, unit.value));
                                  return v1;
                              } else {
                                  return new Ast.Value.CompoundMeasure([v1, new Ast.Value.Measure(num.value, unit.value)]);
                              }
                          }]],
    '$constant_Measure(ms)': [[['$constant_Measure'], identity],
                              [['DURATION'], (tok) => new Ast.Value.Measure(tok.value.value, tok.value.unit)]],

    '$constant_Number': [[['NUMBER'], (num) => new Ast.Value.Number(num.value)],
                         [['1'], () => new Ast.Value.Number(1)],
                         [['0'], () => new Ast.Value.Number(0)]],

    '$constant_Currency': [[['CURRENCY'], (tok) => new Ast.Value.Currency(tok.value.value, tok.value.unit)]],

    '$constant_Location': [[['location:current_location'], (tag) => new Ast.Value.Location(new Ast.Location.Relative(tag.substr('location:'.length)))],
                           [['location:home'], (tag) => new Ast.Value.Location(new Ast.Location.Relative(tag.substr('location:'.length)))],
                           [['location:work'], (tag) => new Ast.Value.Location(new Ast.Location.Relative(tag.substr('location:'.length)))],
                           [['LOCATION'], (loc) => new Ast.Value.Location(new Ast.Location.Absolute(loc.value.latitude, loc.value.longitude, loc.value.display||null))]],

    // start_of/end_of with less than 1h are not supported
    // (they don't make sense)
    '$constant_Date': [[['now'], (loc) => new Ast.Value.Date(null, '+', null)],
                       [['start_of', 'UNIT'], (edge, unit) => new Ast.Value.Date(new Ast.DateEdge(edge, unit.value), '+', null)],
                       [['end_of', 'UNIT'], (edge, unit) => new Ast.Value.Date(new Ast.DateEdge(edge, unit.value), '+', null)],
                       [['DATE'], (abs) => new Ast.Value.Date(parseDate(abs.value), '+', null)],
                       [['$constant_Date', '+', '$constant_Measure(ms)'], (date, op, offset) => new Ast.Value.Date(date.value, op, offset)],
                       [['$constant_Date', '-', '$constant_Measure(ms)'], (date, op, offset) => new Ast.Value.Date(date.value, op, offset)]],

    '$constant_Time': [[['TIME'], (time) => new Ast.Value.Time(time.value.hour, time.value.minute, time.value.second||0)]],

    // almond-nnparser expands this into the various enums in the right
    // place for a parameter (as the meaning of an enum changes according
    // to the parameter anyway)
    '$constant_Enum': [[['ENUM'], (venum) => new Ast.Value.Enum(venum.value)]],

    '$constant_Entity(unknown)': [[['GENERIC_ENTITY'], (entity) => new Ast.Value.Entity(entity.value.value, entity.value.type, entity.value.display)],
                                  [['"', '$word_list', '"', 'ENTITY_TYPE'], (_1, str, _2, type) => {
                                    if (type.value === 'tt:hashtag' || type.value === 'tt:username')
                                        return new Ast.Value.Entity(str, type.value, null);
                                    else
                                        return new Ast.Value.Entity(null, type.value, str);
                                    }]
                                  ],

    '$constant_Entity(tt:username)': [[['USERNAME'], (entity) => new Ast.Value.Entity(entity.value, 'tt:username', null)]],

    '$constant_Entity(tt:hashtag)': [[['HASHTAG'], (entity) => new Ast.Value.Entity(entity.value, 'tt:hashtag', null)]],

    '$constant_Entity(tt:url)': [[['URL'], (entity) => new Ast.Value.Entity(entity.value, 'tt:url', null)]],

    '$constant_Entity(tt:phone_number)': [[['PHONE_NUMBER'], (entity) => new Ast.Value.Entity(entity.value, 'tt:phone_number', null)]],

    '$constant_Entity(tt:email_address)': [[['EMAIL_ADDRESS'], (entity) => new Ast.Value.Entity(entity.value, 'tt:email_address', null)]],

    '$constant_Entity(tt:path_name)': [[['PATH_NAME'], (entity) => new Ast.Value.Entity(entity.value, 'tt:path_name', null)]],

    '$constant_Entity(tt:device)': [[['DEVICE'], (entity) => new Ast.Value.Entity(entity.value, 'tt:device', null)]],

    '$constant_Entity(tt:function)': [[['FUNCTION'], (entity) => new Ast.Value.Entity(entity.kind + ':' + entity.device, 'tt:function', null)]],

    '$constant_Entity(tt:picture)': [[['PICTURE'], (entity) => new Ast.Value.Entity(entity.value, 'tt:picture', null)]],
};
const TERMINAL_IDS = {"0":8,"1":9,"\"":0,"\"\"":1,"(":2,")":3,"*":4,"+":5,",":6,"-":7,":":10,"<":11,"<<EOF>>":12,"<=":13,"=":14,"==":15,"=>":16,"=~":17,">":18,">=":19,"CLASS_STAR":20,"CURRENCY":21,"DATE":22,"DEVICE":23,"DURATION":24,"EMAIL_ADDRESS":25,"ENTITY_TYPE":26,"ENUM":27,"FUNCTION":28,"GENERIC_ENTITY":29,"HASHTAG":30,"LOCATION":31,"NUMBER":32,"PARAM_NAME":33,"PATH_NAME":34,"PHONE_NUMBER":35,"PICTURE":36,"QUOTED_STRING":37,"SLOT":38,"TIME":39,"UNIT":40,"URL":41,"USERNAME":42,"WORD":43,"[":44,"]":45,"aggregate":46,"and":47,"answer":48,"argmax":49,"argmin":50,"attimer":51,"avg":52,"base":53,"contains":54,"count":55,"edge":56,"end_of":57,"ends_with":58,"event":59,"executor":60,"false":61,"filter":62,"history":63,"in_array":64,"interval":65,"join":66,"location:current_location":67,"location:home":68,"location:work":69,"max":70,"min":71,"monitor":72,"new":73,"not":74,"notify":75,"now":76,"of":77,"on":78,"or":79,"policy":80,"prefix_of":81,"return":82,"sequence":83,"start_of":84,"starts_with":85,"suffix_of":86,"sum":87,"time":88,"timer":89,"timeseries":90,"true":91,"window":92,"{":93,"}":94,"~=":95};
const RULE_NON_TERMINALS = [29,29,29,29,37,37,34,34,35,35,35,36,36,36,36,38,38,38,38,41,41,41,41,41,41,41,41,41,41,41,41,41,41,42,42,39,39,39,39,39,39,39,39,40,40,1,1,1,3,3,33,33,4,31,32,32,28,28,30,30,30,2,2,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,27,27,7,7,25,25,25,44,44,22,22,23,23,24,24,24,8,21,21,21,21,9,9,9,9,9,9,26,20,19,19,18,13,17,15,11,14,10,12,16,0];
const ARITY = [1,2,2,2,1,5,3,3,3,3,3,1,1,1,3,3,5,3,3,1,5,7,7,7,7,6,10,10,1,8,8,8,8,7,3,8,4,4,7,9,6,6,1,7,3,1,1,1,1,2,3,3,3,1,1,3,1,3,1,2,3,2,4,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,3,1,1,1,1,3,1,2,2,3,1,1,1,1,1,1,1,1,1,1,1,2,2,1,3,3,1,1,1,4,1,1,1,1,1,1,1,1,1,2];
const GOTO = [{"29":2,"37":9,"38":1,"39":7,"40":14},{},{},{"5":18,"6":46,"7":19,"8":24,"9":26,"10":35,"11":32,"12":36,"13":30,"14":33,"15":31,"16":37,"17":34,"18":29,"19":28,"20":38,"21":25,"22":21,"24":23,"25":20,"26":27},{"2":72,"3":75,"28":70,"30":71},{"2":72,"3":75,"28":78,"30":71,"34":77},{},{},{},{},{},{},{},{},{},{"39":89,"40":14},{"33":90},{},{},{},{},{"24":92},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{"44":96},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{"5":101,"6":46,"7":19,"8":24,"9":26,"10":35,"11":32,"12":36,"13":30,"14":33,"15":31,"16":37,"17":34,"18":29,"19":28,"20":38,"21":25,"22":21,"24":23,"25":20,"26":27,"27":100},{},{},{},{"2":104,"3":75},{"43":106},{"4":120},{},{},{},{},{"5":124,"6":46,"7":19,"8":24,"9":26,"10":35,"11":32,"12":36,"13":30,"14":33,"15":31,"16":37,"17":34,"18":29,"19":28,"20":38,"21":25,"22":21,"24":23,"25":20,"26":27},{"1":125,"3":128},{"1":133,"3":131,"41":130,"42":134},{},{},{"3":143,"41":142,"42":134},{"39":144,"40":14},{"33":145},{},{},{},{},{},{},{"22":151,"23":150,"24":153},{"22":151,"23":154,"24":153},{},{},{},{},{},{},{"2":72,"3":75,"30":159},{"2":160,"3":75},{},{"6":161,"31":162},{},{"5":164,"6":46,"7":19,"8":24,"9":26,"10":35,"11":32,"12":36,"13":30,"14":33,"15":31,"16":37,"17":34,"18":29,"19":28,"20":38,"21":25,"22":21,"24":23,"25":20,"26":27,"31":165},{"5":166,"6":46,"7":19,"8":24,"9":26,"10":35,"11":32,"12":36,"13":30,"14":33,"15":31,"16":37,"17":34,"18":29,"19":28,"20":38,"21":25,"22":21,"24":23,"25":20,"26":27,"31":167},{"5":168,"6":46,"7":19,"8":24,"9":26,"10":35,"11":32,"12":36,"13":30,"14":33,"15":31,"16":37,"17":34,"18":29,"19":28,"20":38,"21":25,"22":21,"24":23,"25":20,"26":27,"31":169},{"5":170,"6":46,"7":19,"8":24,"9":26,"10":35,"11":32,"12":36,"13":30,"14":33,"15":31,"16":37,"17":34,"18":29,"19":28,"20":38,"21":25,"22":21,"24":23,"25":20,"26":27,"31":171},{"5":172,"6":46,"7":19,"8":24,"9":26,"10":35,"11":32,"12":36,"13":30,"14":33,"15":31,"16":37,"17":34,"18":29,"19":28,"20":38,"21":25,"22":21,"24":23,"25":20,"26":27,"31":173},{"5":174,"6":46,"7":19,"8":24,"9":26,"10":35,"11":32,"12":36,"13":30,"14":33,"15":31,"16":37,"17":34,"18":29,"19":28,"20":38,"21":25,"22":21,"24":23,"25":20,"26":27,"31":175},{"5":176,"6":46,"7":19,"8":24,"9":26,"10":35,"11":32,"12":36,"13":30,"14":33,"15":31,"16":37,"17":34,"18":29,"19":28,"20":38,"21":25,"22":21,"24":23,"25":20,"26":27,"31":177},{"5":178,"6":46,"7":19,"8":24,"9":26,"10":35,"11":32,"12":36,"13":30,"14":33,"15":31,"16":37,"17":34,"18":29,"19":28,"20":38,"21":25,"22":21,"24":23,"25":20,"26":27,"31":179},{"5":180,"6":46,"7":19,"8":24,"9":26,"10":35,"11":32,"12":36,"13":30,"14":33,"15":31,"16":37,"17":34,"18":29,"19":28,"20":38,"21":25,"22":21,"24":23,"25":20,"26":27,"31":181},{"5":182,"6":46,"7":19,"8":24,"9":26,"10":35,"11":32,"12":36,"13":30,"14":33,"15":31,"16":37,"17":34,"18":29,"19":28,"20":38,"21":25,"22":21,"24":23,"25":20,"26":27,"31":183},{"5":184,"6":46,"7":19,"8":24,"9":26,"10":35,"11":32,"12":36,"13":30,"14":33,"15":31,"16":37,"17":34,"18":29,"19":28,"20":38,"21":25,"22":21,"24":23,"25":20,"26":27,"31":185},{"5":186,"6":46,"7":19,"8":24,"9":26,"10":35,"11":32,"12":36,"13":30,"14":33,"15":31,"16":37,"17":34,"18":29,"19":28,"20":38,"21":25,"22":21,"24":23,"25":20,"26":27,"31":187},{"2":72,"3":75,"28":188,"30":71},{},{},{"35":190,"36":192},{"35":196,"36":192},{},{},{},{},{"4":120},{},{},{"4":120},{"3":143,"41":207,"42":134},{},{},{"24":209},{"9":210},{"24":211},{"9":212},{"9":213},{"26":214},{},{},{"4":120},{},{},{"3":143,"41":217,"42":134},{},{"31":219},{},{},{"24":92},{},{},{},{},{},{},{"5":222,"6":46,"7":19,"8":24,"9":26,"10":35,"11":32,"12":36,"13":30,"14":33,"15":31,"16":37,"17":34,"18":29,"19":28,"20":38,"21":25,"22":21,"24":23,"25":20,"26":27},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{"5":224,"6":46,"7":19,"8":24,"9":26,"10":35,"11":32,"12":36,"13":30,"14":33,"15":31,"16":37,"17":34,"18":29,"19":28,"20":38,"21":25,"22":21,"24":23,"25":20,"26":27},{},{},{},{},{},{},{},{"38":228,"39":7,"40":14},{"31":229},{"31":230},{"31":231},{"31":232},{},{"31":234},{"31":235},{"1":236,"3":128},{},{},{"33":238},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{"36":248},{"36":250},{"2":72,"3":75,"28":251,"30":71},{},{},{},{},{},{},{"24":257},{"24":258},{},{},{},{"24":261},{"22":151,"23":262,"24":153},{"24":263},{"22":151,"23":264,"24":153},{},{},{"2":72,"3":75,"28":267,"30":71},{},{"3":143,"41":269,"42":134},{},{},{},{},{},{},{},{},{"3":143,"41":274,"42":134},{},{},{"2":72,"3":75,"28":277,"30":71},{},{},{},{},{},{},{"31":285},{},{},{},{"3":143,"41":287,"42":134},{"3":143,"41":288,"42":134},{"3":143,"41":289,"42":134},{"3":143,"41":290,"42":134},{},{"24":292},{"24":293},{},{"3":143,"41":294,"42":134},{},{},{},{},{"22":151,"23":299,"24":153},{"31":301,"32":300},{},{},{},{},{},{},{},{},{},{},{"39":309,"40":14},{"39":310,"40":14},{"3":143,"41":311,"42":134},{"3":143,"41":312,"42":134},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{"31":321},{"3":143,"41":322,"42":134},{"3":143,"41":323,"42":134},{},{},{},{},{},{},{},{},{}];
const PARSER_ACTION = [{"2":[1,15],"48":[1,3],"51":[1,11],"56":[1,13],"60":[1,6],"62":[1,4],"72":[1,12],"76":[1,8],"80":[1,5],"89":[1,10]},{"12":[2,4],"78":[1,16]},{"12":[0]},{"0":[1,51],"1":[1,65],"8":[1,64],"9":[1,63],"21":[1,61],"22":[1,56],"23":[1,43],"24":[1,22],"25":[1,17],"27":[1,40],"28":[1,42],"29":[1,50],"30":[1,48],"31":[1,60],"32":[1,62],"34":[1,45],"35":[1,47],"36":[1,41],"37":[1,66],"38":[1,39],"39":[1,52],"41":[1,44],"42":[1,49],"44":[1,69],"57":[1,55],"61":[1,68],"67":[1,57],"68":[1,58],"69":[1,59],"76":[1,53],"84":[1,54],"91":[1,67]},{"28":[1,76],"33":[1,74],"74":[1,73]},{"28":[1,76],"33":[1,74],"74":[1,73],"91":[1,79]},{"14":[1,80]},{"16":[1,81]},{"16":[1,82]},{"12":[2,0]},{"53":[1,83]},{"88":[1,84]},{"2":[1,85]},{"2":[1,86]},{"3":[2,42],"16":[2,42],"78":[1,87]},{"2":[1,15],"51":[1,11],"56":[1,13],"72":[1,88],"89":[1,10]},{"33":[1,91]},{"3":[2,147],"6":[2,147],"10":[2,147],"12":[2,147],"16":[2,147],"33":[2,147],"45":[2,147],"47":[2,147],"78":[2,147],"79":[2,147],"93":[2,147],"94":[2,147]},{"12":[2,1]},{"3":[2,90],"6":[2,90],"10":[2,90],"12":[2,90],"16":[2,90],"33":[2,90],"45":[2,90],"47":[2,90],"78":[2,90],"79":[2,90],"93":[2,90],"94":[2,90]},{"3":[2,91],"6":[2,91],"10":[2,91],"12":[2,91],"16":[2,91],"33":[2,91],"45":[2,91],"47":[2,91],"78":[2,91],"79":[2,91],"93":[2,91],"94":[2,91]},{"3":[2,92],"6":[2,92],"8":[1,64],"9":[1,63],"10":[2,92],"12":[2,92],"16":[2,92],"32":[1,62],"33":[2,92],"45":[2,92],"47":[2,92],"78":[2,92],"79":[2,92],"93":[2,92],"94":[2,92]},{"3":[2,93],"6":[2,93],"10":[2,93],"12":[2,93],"16":[2,93],"33":[2,93],"45":[2,93],"47":[2,93],"78":[2,93],"79":[2,93],"93":[2,93],"94":[2,93]},{"3":[2,94],"6":[2,94],"10":[2,94],"12":[2,94],"16":[2,94],"33":[2,94],"40":[1,93],"45":[2,94],"47":[2,94],"78":[2,94],"79":[2,94],"93":[2,94],"94":[2,94]},{"3":[2,95],"6":[2,95],"10":[2,95],"12":[2,95],"16":[2,95],"33":[2,95],"45":[2,95],"47":[2,95],"78":[2,95],"79":[2,95],"93":[2,95],"94":[2,95]},{"3":[2,96],"6":[2,96],"10":[2,96],"12":[2,96],"16":[2,96],"33":[2,96],"45":[2,96],"47":[2,96],"78":[2,96],"79":[2,96],"93":[2,96],"94":[2,96]},{"3":[2,97],"5":[1,94],"6":[2,97],"7":[1,95],"10":[2,97],"12":[2,97],"16":[2,97],"33":[2,97],"45":[2,97],"47":[2,97],"78":[2,97],"79":[2,97],"93":[2,97],"94":[2,97]},{"3":[2,98],"6":[2,98],"10":[2,98],"12":[2,98],"16":[2,98],"33":[2,98],"45":[2,98],"47":[2,98],"78":[2,98],"79":[2,98],"93":[2,98],"94":[2,98]},{"3":[2,99],"6":[2,99],"10":[2,99],"12":[2,99],"16":[2,99],"33":[2,99],"45":[2,99],"47":[2,99],"78":[2,99],"79":[2,99],"93":[2,99],"94":[2,99]},{"3":[2,100],"6":[2,100],"10":[2,100],"12":[2,100],"16":[2,100],"33":[2,100],"45":[2,100],"47":[2,100],"78":[2,100],"79":[2,100],"93":[2,100],"94":[2,100]},{"3":[2,101],"6":[2,101],"10":[2,101],"12":[2,101],"16":[2,101],"33":[2,101],"45":[2,101],"47":[2,101],"78":[2,101],"79":[2,101],"93":[2,101],"94":[2,101]},{"3":[2,102],"6":[2,102],"10":[2,102],"12":[2,102],"16":[2,102],"33":[2,102],"45":[2,102],"47":[2,102],"78":[2,102],"79":[2,102],"93":[2,102],"94":[2,102]},{"3":[2,103],"6":[2,103],"10":[2,103],"12":[2,103],"16":[2,103],"33":[2,103],"45":[2,103],"47":[2,103],"78":[2,103],"79":[2,103],"93":[2,103],"94":[2,103]},{"3":[2,104],"6":[2,104],"10":[2,104],"12":[2,104],"16":[2,104],"33":[2,104],"45":[2,104],"47":[2,104],"78":[2,104],"79":[2,104],"93":[2,104],"94":[2,104]},{"3":[2,105],"6":[2,105],"10":[2,105],"12":[2,105],"16":[2,105],"33":[2,105],"45":[2,105],"47":[2,105],"78":[2,105],"79":[2,105],"93":[2,105],"94":[2,105]},{"3":[2,106],"6":[2,106],"10":[2,106],"12":[2,106],"16":[2,106],"33":[2,106],"45":[2,106],"47":[2,106],"78":[2,106],"79":[2,106],"93":[2,106],"94":[2,106]},{"3":[2,107],"6":[2,107],"10":[2,107],"12":[2,107],"16":[2,107],"33":[2,107],"45":[2,107],"47":[2,107],"78":[2,107],"79":[2,107],"93":[2,107],"94":[2,107]},{"3":[2,108],"6":[2,108],"10":[2,108],"12":[2,108],"16":[2,108],"33":[2,108],"45":[2,108],"47":[2,108],"78":[2,108],"79":[2,108],"93":[2,108],"94":[2,108]},{"3":[2,109],"6":[2,109],"10":[2,109],"12":[2,109],"16":[2,109],"33":[2,109],"45":[2,109],"47":[2,109],"78":[2,109],"79":[2,109],"93":[2,109],"94":[2,109]},{"3":[2,110],"6":[2,110],"10":[2,110],"12":[2,110],"16":[2,110],"33":[2,110],"45":[2,110],"47":[2,110],"78":[2,110],"79":[2,110],"93":[2,110],"94":[2,110]},{"3":[2,140],"6":[2,140],"10":[2,140],"12":[2,140],"16":[2,140],"33":[2,140],"45":[2,140],"47":[2,140],"78":[2,140],"79":[2,140],"93":[2,140],"94":[2,140]},{"3":[2,151],"6":[2,151],"10":[2,151],"12":[2,151],"16":[2,151],"33":[2,151],"45":[2,151],"47":[2,151],"78":[2,151],"79":[2,151],"93":[2,151],"94":[2,151]},{"3":[2,150],"6":[2,150],"10":[2,150],"12":[2,150],"16":[2,150],"33":[2,150],"45":[2,150],"47":[2,150],"78":[2,150],"79":[2,150],"93":[2,150],"94":[2,150]},{"3":[2,149],"6":[2,149],"10":[2,149],"12":[2,149],"16":[2,149],"33":[2,149],"45":[2,149],"47":[2,149],"78":[2,149],"79":[2,149],"93":[2,149],"94":[2,149]},{"3":[2,145],"6":[2,145],"10":[2,145],"12":[2,145],"16":[2,145],"33":[2,145],"45":[2,145],"47":[2,145],"78":[2,145],"79":[2,145],"93":[2,145],"94":[2,145]},{"3":[2,148],"6":[2,148],"10":[2,148],"12":[2,148],"16":[2,148],"33":[2,148],"45":[2,148],"47":[2,148],"78":[2,148],"79":[2,148],"93":[2,148],"94":[2,148]},{"3":[2,89],"6":[2,89],"10":[2,89],"12":[2,89],"16":[2,89],"33":[2,89],"45":[2,89],"47":[2,89],"78":[2,89],"79":[2,89],"93":[2,89],"94":[2,89]},{"3":[2,146],"6":[2,146],"10":[2,146],"12":[2,146],"16":[2,146],"33":[2,146],"45":[2,146],"47":[2,146],"78":[2,146],"79":[2,146],"93":[2,146],"94":[2,146]},{"3":[2,144],"6":[2,144],"10":[2,144],"12":[2,144],"16":[2,144],"33":[2,144],"45":[2,144],"47":[2,144],"78":[2,144],"79":[2,144],"93":[2,144],"94":[2,144]},{"3":[2,143],"6":[2,143],"10":[2,143],"12":[2,143],"16":[2,143],"33":[2,143],"45":[2,143],"47":[2,143],"78":[2,143],"79":[2,143],"93":[2,143],"94":[2,143]},{"3":[2,141],"6":[2,141],"10":[2,141],"12":[2,141],"16":[2,141],"33":[2,141],"45":[2,141],"47":[2,141],"78":[2,141],"79":[2,141],"93":[2,141],"94":[2,141]},{"43":[1,97]},{"3":[2,139],"6":[2,139],"10":[2,139],"12":[2,139],"16":[2,139],"33":[2,139],"45":[2,139],"47":[2,139],"78":[2,139],"79":[2,139],"93":[2,139],"94":[2,139]},{"3":[2,133],"5":[2,133],"6":[2,133],"7":[2,133],"10":[2,133],"12":[2,133],"16":[2,133],"33":[2,133],"45":[2,133],"47":[2,133],"78":[2,133],"79":[2,133],"93":[2,133],"94":[2,133]},{"40":[1,98]},{"40":[1,99]},{"3":[2,136],"5":[2,136],"6":[2,136],"7":[2,136],"10":[2,136],"12":[2,136],"16":[2,136],"33":[2,136],"45":[2,136],"47":[2,136],"78":[2,136],"79":[2,136],"93":[2,136],"94":[2,136]},{"3":[2,129],"6":[2,129],"10":[2,129],"12":[2,129],"16":[2,129],"33":[2,129],"45":[2,129],"47":[2,129],"78":[2,129],"79":[2,129],"93":[2,129],"94":[2,129]},{"3":[2,130],"6":[2,130],"10":[2,130],"12":[2,130],"16":[2,130],"33":[2,130],"45":[2,130],"47":[2,130],"78":[2,130],"79":[2,130],"93":[2,130],"94":[2,130]},{"3":[2,131],"6":[2,131],"10":[2,131],"12":[2,131],"16":[2,131],"33":[2,131],"45":[2,131],"47":[2,131],"78":[2,131],"79":[2,131],"93":[2,131],"94":[2,131]},{"3":[2,132],"6":[2,132],"10":[2,132],"12":[2,132],"16":[2,132],"33":[2,132],"45":[2,132],"47":[2,132],"78":[2,132],"79":[2,132],"93":[2,132],"94":[2,132]},{"3":[2,128],"6":[2,128],"10":[2,128],"12":[2,128],"16":[2,128],"33":[2,128],"45":[2,128],"47":[2,128],"78":[2,128],"79":[2,128],"93":[2,128],"94":[2,128]},{"3":[2,125],"6":[2,125],"10":[2,125],"12":[2,125],"16":[2,125],"33":[2,125],"40":[2,125],"45":[2,125],"47":[2,125],"77":[2,125],"78":[2,125],"79":[2,125],"93":[2,125],"94":[2,125]},{"3":[2,126],"6":[2,126],"10":[2,126],"12":[2,126],"16":[2,126],"33":[2,126],"40":[2,126],"45":[2,126],"47":[2,126],"77":[2,126],"78":[2,126],"79":[2,126],"93":[2,126],"94":[2,126]},{"3":[2,127],"6":[2,127],"10":[2,127],"12":[2,127],"16":[2,127],"33":[2,127],"40":[2,127],"45":[2,127],"47":[2,127],"77":[2,127],"78":[2,127],"79":[2,127],"93":[2,127],"94":[2,127]},{"3":[2,116],"6":[2,116],"10":[2,116],"12":[2,116],"16":[2,116],"33":[2,116],"45":[2,116],"47":[2,116],"78":[2,116],"79":[2,116],"93":[2,116],"94":[2,116]},{"3":[2,117],"6":[2,117],"10":[2,117],"12":[2,117],"16":[2,117],"33":[2,117],"45":[2,117],"47":[2,117],"78":[2,117],"79":[2,117],"93":[2,117],"94":[2,117]},{"3":[2,114],"6":[2,114],"10":[2,114],"12":[2,114],"16":[2,114],"33":[2,114],"45":[2,114],"47":[2,114],"78":[2,114],"79":[2,114],"93":[2,114],"94":[2,114]},{"3":[2,115],"6":[2,115],"10":[2,115],"12":[2,115],"16":[2,115],"33":[2,115],"45":[2,115],"47":[2,115],"78":[2,115],"79":[2,115],"93":[2,115],"94":[2,115]},{"0":[1,51],"1":[1,65],"8":[1,64],"9":[1,63],"21":[1,61],"22":[1,56],"23":[1,43],"24":[1,22],"25":[1,17],"27":[1,40],"28":[1,42],"29":[1,50],"30":[1,48],"31":[1,60],"32":[1,62],"34":[1,45],"35":[1,47],"36":[1,41],"37":[1,66],"38":[1,39],"39":[1,52],"41":[1,44],"42":[1,49],"44":[1,69],"57":[1,55],"61":[1,68],"67":[1,57],"68":[1,58],"69":[1,59],"76":[1,53],"84":[1,54],"91":[1,67]},{"12":[2,2],"47":[1,102]},{"3":[2,56],"10":[2,56],"12":[2,56],"16":[2,56],"47":[2,56],"79":[1,103],"94":[2,56]},{"3":[2,58],"10":[2,58],"12":[2,58],"16":[2,58],"47":[2,58],"79":[2,58],"94":[2,58]},{"28":[1,76],"33":[1,74]},{"11":[1,110],"13":[1,108],"15":[1,118],"17":[1,111],"18":[1,109],"19":[1,107],"54":[1,117],"58":[1,114],"64":[1,105],"81":[1,115],"85":[1,113],"86":[1,116],"95":[1,112]},{"33":[1,121],"93":[1,119]},{"3":[2,48],"12":[2,48],"16":[2,48],"33":[2,48],"78":[2,48],"93":[2,48]},{"12":[2,3]},{"10":[1,122],"47":[1,102]},{"10":[1,123]},{"0":[1,51],"1":[1,65],"8":[1,64],"9":[1,63],"21":[1,61],"22":[1,56],"23":[1,43],"24":[1,22],"25":[1,17],"27":[1,40],"28":[1,42],"29":[1,50],"30":[1,48],"31":[1,60],"32":[1,62],"34":[1,45],"35":[1,47],"36":[1,41],"37":[1,66],"38":[1,39],"39":[1,52],"41":[1,44],"42":[1,49],"44":[1,69],"57":[1,55],"61":[1,68],"67":[1,57],"68":[1,58],"69":[1,59],"76":[1,53],"84":[1,54],"91":[1,67]},{"28":[1,76],"75":[1,126],"82":[1,127]},{"2":[1,132],"28":[1,76],"46":[1,129],"63":[1,138],"75":[1,126],"82":[1,127],"83":[1,137],"90":[1,136],"92":[1,135]},{"14":[1,139]},{"14":[1,140]},{"2":[1,132],"28":[1,76],"46":[1,141],"63":[1,138],"83":[1,137],"90":[1,136],"92":[1,135]},{"2":[1,15],"51":[1,11],"56":[1,13],"72":[1,88],"89":[1,10]},{"33":[1,91]},{"2":[1,146]},{"3":[1,147]},{"12":[2,18],"78":[2,18]},{"14":[1,148]},{"40":[1,149]},{"3":[2,121],"5":[2,121],"6":[2,121],"7":[2,121],"8":[2,121],"9":[2,121],"10":[2,121],"12":[2,121],"16":[2,121],"32":[2,121],"33":[2,121],"45":[2,121],"47":[2,121],"77":[2,121],"78":[2,121],"79":[2,121],"93":[2,121],"94":[2,121]},{"8":[1,64],"9":[1,63],"24":[1,152],"32":[1,62]},{"8":[1,64],"9":[1,63],"24":[1,152],"32":[1,62]},{"0":[1,155],"43":[1,156]},{"0":[2,119],"43":[2,119]},{"3":[2,134],"5":[2,134],"6":[2,134],"7":[2,134],"10":[2,134],"12":[2,134],"16":[2,134],"33":[2,134],"45":[2,134],"47":[2,134],"78":[2,134],"79":[2,134],"93":[2,134],"94":[2,134]},{"3":[2,135],"5":[2,135],"6":[2,135],"7":[2,135],"10":[2,135],"12":[2,135],"16":[2,135],"33":[2,135],"45":[2,135],"47":[2,135],"78":[2,135],"79":[2,135],"93":[2,135],"94":[2,135]},{"6":[1,158],"45":[1,157]},{"6":[2,112],"45":[2,112]},{"28":[1,76],"33":[1,74],"74":[1,73]},{"28":[1,76],"33":[1,74]},{"3":[2,59],"10":[2,59],"12":[2,59],"16":[2,59],"47":[2,59],"79":[2,59],"94":[2,59]},{"33":[1,163],"44":[1,69]},{"3":[2,61],"10":[2,61],"12":[2,61],"16":[2,61],"47":[2,61],"79":[2,61],"94":[2,61]},{"0":[1,51],"1":[1,65],"8":[1,64],"9":[1,63],"21":[1,61],"22":[1,56],"23":[1,43],"24":[1,22],"25":[1,17],"27":[1,40],"28":[1,42],"29":[1,50],"30":[1,48],"31":[1,60],"32":[1,62],"33":[1,163],"34":[1,45],"35":[1,47],"36":[1,41],"37":[1,66],"38":[1,39],"39":[1,52],"41":[1,44],"42":[1,49],"44":[1,69],"57":[1,55],"61":[1,68],"67":[1,57],"68":[1,58],"69":[1,59],"76":[1,53],"84":[1,54],"91":[1,67]},{"0":[1,51],"1":[1,65],"8":[1,64],"9":[1,63],"21":[1,61],"22":[1,56],"23":[1,43],"24":[1,22],"25":[1,17],"27":[1,40],"28":[1,42],"29":[1,50],"30":[1,48],"31":[1,60],"32":[1,62],"33":[1,163],"34":[1,45],"35":[1,47],"36":[1,41],"37":[1,66],"38":[1,39],"39":[1,52],"41":[1,44],"42":[1,49],"44":[1,69],"57":[1,55],"61":[1,68],"67":[1,57],"68":[1,58],"69":[1,59],"76":[1,53],"84":[1,54],"91":[1,67]},{"0":[1,51],"1":[1,65],"8":[1,64],"9":[1,63],"21":[1,61],"22":[1,56],"23":[1,43],"24":[1,22],"25":[1,17],"27":[1,40],"28":[1,42],"29":[1,50],"30":[1,48],"31":[1,60],"32":[1,62],"33":[1,163],"34":[1,45],"35":[1,47],"36":[1,41],"37":[1,66],"38":[1,39],"39":[1,52],"41":[1,44],"42":[1,49],"44":[1,69],"57":[1,55],"61":[1,68],"67":[1,57],"68":[1,58],"69":[1,59],"76":[1,53],"84":[1,54],"91":[1,67]},{"0":[1,51],"1":[1,65],"8":[1,64],"9":[1,63],"21":[1,61],"22":[1,56],"23":[1,43],"24":[1,22],"25":[1,17],"27":[1,40],"28":[1,42],"29":[1,50],"30":[1,48],"31":[1,60],"32":[1,62],"33":[1,163],"34":[1,45],"35":[1,47],"36":[1,41],"37":[1,66],"38":[1,39],"39":[1,52],"41":[1,44],"42":[1,49],"44":[1,69],"57":[1,55],"61":[1,68],"67":[1,57],"68":[1,58],"69":[1,59],"76":[1,53],"84":[1,54],"91":[1,67]},{"0":[1,51],"1":[1,65],"8":[1,64],"9":[1,63],"21":[1,61],"22":[1,56],"23":[1,43],"24":[1,22],"25":[1,17],"27":[1,40],"28":[1,42],"29":[1,50],"30":[1,48],"31":[1,60],"32":[1,62],"33":[1,163],"34":[1,45],"35":[1,47],"36":[1,41],"37":[1,66],"38":[1,39],"39":[1,52],"41":[1,44],"42":[1,49],"44":[1,69],"57":[1,55],"61":[1,68],"67":[1,57],"68":[1,58],"69":[1,59],"76":[1,53],"84":[1,54],"91":[1,67]},{"0":[1,51],"1":[1,65],"8":[1,64],"9":[1,63],"21":[1,61],"22":[1,56],"23":[1,43],"24":[1,22],"25":[1,17],"27":[1,40],"28":[1,42],"29":[1,50],"30":[1,48],"31":[1,60],"32":[1,62],"33":[1,163],"34":[1,45],"35":[1,47],"36":[1,41],"37":[1,66],"38":[1,39],"39":[1,52],"41":[1,44],"42":[1,49],"44":[1,69],"57":[1,55],"61":[1,68],"67":[1,57],"68":[1,58],"69":[1,59],"76":[1,53],"84":[1,54],"91":[1,67]},{"0":[1,51],"1":[1,65],"8":[1,64],"9":[1,63],"21":[1,61],"22":[1,56],"23":[1,43],"24":[1,22],"25":[1,17],"27":[1,40],"28":[1,42],"29":[1,50],"30":[1,48],"31":[1,60],"32":[1,62],"33":[1,163],"34":[1,45],"35":[1,47],"36":[1,41],"37":[1,66],"38":[1,39],"39":[1,52],"41":[1,44],"42":[1,49],"44":[1,69],"57":[1,55],"61":[1,68],"67":[1,57],"68":[1,58],"69":[1,59],"76":[1,53],"84":[1,54],"91":[1,67]},{"0":[1,51],"1":[1,65],"8":[1,64],"9":[1,63],"21":[1,61],"22":[1,56],"23":[1,43],"24":[1,22],"25":[1,17],"27":[1,40],"28":[1,42],"29":[1,50],"30":[1,48],"31":[1,60],"32":[1,62],"33":[1,163],"34":[1,45],"35":[1,47],"36":[1,41],"37":[1,66],"38":[1,39],"39":[1,52],"41":[1,44],"42":[1,49],"44":[1,69],"57":[1,55],"61":[1,68],"67":[1,57],"68":[1,58],"69":[1,59],"76":[1,53],"84":[1,54],"91":[1,67]},{"0":[1,51],"1":[1,65],"8":[1,64],"9":[1,63],"21":[1,61],"22":[1,56],"23":[1,43],"24":[1,22],"25":[1,17],"27":[1,40],"28":[1,42],"29":[1,50],"30":[1,48],"31":[1,60],"32":[1,62],"33":[1,163],"34":[1,45],"35":[1,47],"36":[1,41],"37":[1,66],"38":[1,39],"39":[1,52],"41":[1,44],"42":[1,49],"44":[1,69],"57":[1,55],"61":[1,68],"67":[1,57],"68":[1,58],"69":[1,59],"76":[1,53],"84":[1,54],"91":[1,67]},{"0":[1,51],"1":[1,65],"8":[1,64],"9":[1,63],"21":[1,61],"22":[1,56],"23":[1,43],"24":[1,22],"25":[1,17],"27":[1,40],"28":[1,42],"29":[1,50],"30":[1,48],"31":[1,60],"32":[1,62],"33":[1,163],"34":[1,45],"35":[1,47],"36":[1,41],"37":[1,66],"38":[1,39],"39":[1,52],"41":[1,44],"42":[1,49],"44":[1,69],"57":[1,55],"61":[1,68],"67":[1,57],"68":[1,58],"69":[1,59],"76":[1,53],"84":[1,54],"91":[1,67]},{"0":[1,51],"1":[1,65],"8":[1,64],"9":[1,63],"21":[1,61],"22":[1,56],"23":[1,43],"24":[1,22],"25":[1,17],"27":[1,40],"28":[1,42],"29":[1,50],"30":[1,48],"31":[1,60],"32":[1,62],"33":[1,163],"34":[1,45],"35":[1,47],"36":[1,41],"37":[1,66],"38":[1,39],"39":[1,52],"41":[1,44],"42":[1,49],"44":[1,69],"57":[1,55],"61":[1,68],"67":[1,57],"68":[1,58],"69":[1,59],"76":[1,53],"84":[1,54],"91":[1,67]},{"0":[1,51],"1":[1,65],"8":[1,64],"9":[1,63],"21":[1,61],"22":[1,56],"23":[1,43],"24":[1,22],"25":[1,17],"27":[1,40],"28":[1,42],"29":[1,50],"30":[1,48],"31":[1,60],"32":[1,62],"33":[1,163],"34":[1,45],"35":[1,47],"36":[1,41],"37":[1,66],"38":[1,39],"39":[1,52],"41":[1,44],"42":[1,49],"44":[1,69],"57":[1,55],"61":[1,68],"67":[1,57],"68":[1,58],"69":[1,59],"76":[1,53],"84":[1,54],"91":[1,67]},{"28":[1,76],"33":[1,74],"74":[1,73]},{"3":[2,49],"12":[2,49],"16":[2,49],"33":[2,49],"78":[2,49],"93":[2,49]},{"14":[1,189]},{"4":[1,193],"20":[1,194],"28":[1,195],"76":[1,191]},{"4":[1,193],"20":[1,194],"28":[1,195],"76":[1,191]},{"10":[1,197]},{"12":[2,15],"78":[2,15]},{"12":[2,45],"78":[2,45]},{"12":[2,46],"78":[2,46]},{"12":[2,47],"33":[1,121],"78":[2,47]},{"49":[1,204],"50":[1,203],"52":[1,201],"55":[1,202],"70":[1,200],"71":[1,199],"87":[1,198]},{"16":[1,205]},{"3":[2,19],"12":[2,47],"16":[2,19],"33":[1,121],"78":[2,47]},{"2":[1,132],"28":[1,76],"46":[1,206],"63":[1,138],"83":[1,137],"90":[1,136],"92":[1,135]},{"12":[2,17],"78":[2,17]},{"3":[2,28],"16":[2,28],"78":[1,208]},{"8":[1,64],"9":[1,63],"32":[1,62]},{"22":[1,56],"57":[1,55],"76":[1,53],"84":[1,54]},{"8":[1,64],"9":[1,63],"32":[1,62]},{"22":[1,56],"57":[1,55],"76":[1,53],"84":[1,54]},{"22":[1,56],"57":[1,55],"76":[1,53],"84":[1,54]},{"39":[1,52]},{"49":[1,204],"50":[1,203],"52":[1,201],"55":[1,202],"70":[1,200],"71":[1,199],"87":[1,198]},{"3":[1,215]},{"3":[2,19],"16":[2,19],"33":[1,121]},{"3":[1,216]},{"3":[2,44],"16":[2,44],"78":[2,44]},{"2":[1,132],"28":[1,76],"46":[1,141],"63":[1,138],"83":[1,137],"90":[1,136],"92":[1,135]},{"66":[1,218]},{"33":[1,163],"59":[1,220]},{"3":[2,122],"5":[2,122],"6":[2,122],"7":[2,122],"8":[2,122],"9":[2,122],"10":[2,122],"12":[2,122],"16":[2,122],"32":[2,122],"33":[2,122],"45":[2,122],"47":[2,122],"77":[2,122],"78":[2,122],"79":[2,122],"93":[2,122],"94":[2,122]},{"3":[2,137],"5":[2,137],"6":[2,137],"7":[2,137],"10":[2,137],"12":[2,137],"16":[2,137],"33":[2,137],"45":[2,137],"47":[2,137],"78":[2,137],"79":[2,137],"93":[2,137],"94":[2,137]},{"3":[2,123],"5":[2,123],"6":[2,123],"7":[2,123],"8":[1,64],"9":[1,63],"10":[2,123],"12":[2,123],"16":[2,123],"32":[1,62],"33":[2,123],"45":[2,123],"47":[2,123],"77":[2,123],"78":[2,123],"79":[2,123],"93":[2,123],"94":[2,123]},{"3":[2,124],"5":[2,124],"6":[2,124],"7":[2,124],"10":[2,124],"12":[2,124],"16":[2,124],"33":[2,124],"45":[2,124],"47":[2,124],"77":[2,124],"78":[2,124],"79":[2,124],"93":[2,124],"94":[2,124]},{"40":[1,93]},{"3":[2,138],"5":[2,138],"6":[2,138],"7":[2,138],"10":[2,138],"12":[2,138],"16":[2,138],"33":[2,138],"45":[2,138],"47":[2,138],"78":[2,138],"79":[2,138],"93":[2,138],"94":[2,138]},{"3":[2,118],"6":[2,118],"10":[2,118],"12":[2,118],"16":[2,118],"26":[1,221],"33":[2,118],"45":[2,118],"47":[2,118],"78":[2,118],"79":[2,118],"93":[2,118],"94":[2,118]},{"0":[2,120],"43":[2,120]},{"3":[2,111],"6":[2,111],"10":[2,111],"12":[2,111],"16":[2,111],"33":[2,111],"45":[2,111],"47":[2,111],"78":[2,111],"79":[2,111],"93":[2,111],"94":[2,111]},{"0":[1,51],"1":[1,65],"8":[1,64],"9":[1,63],"21":[1,61],"22":[1,56],"23":[1,43],"24":[1,22],"25":[1,17],"27":[1,40],"28":[1,42],"29":[1,50],"30":[1,48],"31":[1,60],"32":[1,62],"34":[1,45],"35":[1,47],"36":[1,41],"37":[1,66],"38":[1,39],"39":[1,52],"41":[1,44],"42":[1,49],"44":[1,69],"57":[1,55],"61":[1,68],"67":[1,57],"68":[1,58],"69":[1,59],"76":[1,53],"84":[1,54],"91":[1,67]},{"3":[2,57],"10":[2,57],"12":[2,57],"16":[2,57],"47":[2,57],"79":[1,103],"94":[2,57]},{"3":[2,60],"10":[2,60],"12":[2,60],"16":[2,60],"47":[2,60],"79":[2,60],"94":[2,60]},{"3":[2,75],"10":[2,75],"12":[2,75],"16":[2,75],"47":[2,75],"79":[2,75],"94":[2,75]},{"3":[2,88],"10":[2,88],"12":[2,88],"16":[2,88],"47":[2,88],"79":[2,88],"94":[2,88]},{"3":[2,53],"6":[2,53],"8":[2,53],"9":[2,53],"10":[2,53],"12":[2,53],"16":[2,53],"32":[2,53],"45":[2,53],"47":[2,53],"77":[2,53],"78":[2,53],"79":[2,53],"94":[2,53]},{"3":[2,64],"10":[2,64],"12":[2,64],"16":[2,64],"47":[2,64],"79":[2,64],"94":[2,64]},{"3":[2,77],"10":[2,77],"12":[2,77],"16":[2,77],"47":[2,77],"79":[2,77],"94":[2,77]},{"3":[2,65],"10":[2,65],"12":[2,65],"16":[2,65],"47":[2,65],"79":[2,65],"94":[2,65]},{"3":[2,78],"10":[2,78],"12":[2,78],"16":[2,78],"47":[2,78],"79":[2,78],"94":[2,78]},{"3":[2,66],"10":[2,66],"12":[2,66],"16":[2,66],"47":[2,66],"79":[2,66],"94":[2,66]},{"3":[2,79],"10":[2,79],"12":[2,79],"16":[2,79],"47":[2,79],"79":[2,79],"94":[2,79]},{"3":[2,67],"10":[2,67],"12":[2,67],"16":[2,67],"47":[2,67],"79":[2,67],"94":[2,67]},{"3":[2,80],"10":[2,80],"12":[2,80],"16":[2,80],"47":[2,80],"79":[2,80],"94":[2,80]},{"3":[2,68],"10":[2,68],"12":[2,68],"16":[2,68],"47":[2,68],"79":[2,68],"94":[2,68]},{"3":[2,81],"10":[2,81],"12":[2,81],"16":[2,81],"47":[2,81],"79":[2,81],"94":[2,81]},{"3":[2,69],"10":[2,69],"12":[2,69],"16":[2,69],"47":[2,69],"79":[2,69],"94":[2,69]},{"3":[2,82],"10":[2,82],"12":[2,82],"16":[2,82],"47":[2,82],"79":[2,82],"94":[2,82]},{"3":[2,70],"10":[2,70],"12":[2,70],"16":[2,70],"47":[2,70],"79":[2,70],"94":[2,70]},{"3":[2,83],"10":[2,83],"12":[2,83],"16":[2,83],"47":[2,83],"79":[2,83],"94":[2,83]},{"3":[2,71],"10":[2,71],"12":[2,71],"16":[2,71],"47":[2,71],"79":[2,71],"94":[2,71]},{"3":[2,84],"10":[2,84],"12":[2,84],"16":[2,84],"47":[2,84],"79":[2,84],"94":[2,84]},{"3":[2,72],"10":[2,72],"12":[2,72],"16":[2,72],"47":[2,72],"79":[2,72],"94":[2,72]},{"3":[2,85],"10":[2,85],"12":[2,85],"16":[2,85],"47":[2,85],"79":[2,85],"94":[2,85]},{"3":[2,73],"10":[2,73],"12":[2,73],"16":[2,73],"47":[2,73],"79":[2,73],"94":[2,73]},{"3":[2,86],"10":[2,86],"12":[2,86],"16":[2,86],"47":[2,86],"79":[2,86],"94":[2,86]},{"3":[2,74],"10":[2,74],"12":[2,74],"16":[2,74],"47":[2,74],"79":[2,74],"94":[2,74]},{"3":[2,87],"10":[2,87],"12":[2,87],"16":[2,87],"47":[2,87],"79":[2,87],"94":[2,87]},{"3":[2,63],"10":[2,63],"12":[2,63],"16":[2,63],"47":[2,63],"79":[2,63],"94":[2,63]},{"3":[2,76],"10":[2,76],"12":[2,76],"16":[2,76],"47":[2,76],"79":[2,76],"94":[2,76]},{"47":[1,102],"94":[1,223]},{"0":[1,51],"1":[1,65],"8":[1,64],"9":[1,63],"21":[1,61],"22":[1,56],"23":[1,43],"24":[1,22],"25":[1,17],"27":[1,40],"28":[1,42],"29":[1,50],"30":[1,48],"31":[1,60],"32":[1,62],"34":[1,45],"35":[1,47],"36":[1,41],"37":[1,66],"38":[1,39],"39":[1,52],"41":[1,44],"42":[1,49],"44":[1,69],"57":[1,55],"61":[1,68],"67":[1,57],"68":[1,58],"69":[1,59],"76":[1,53],"84":[1,54],"91":[1,67]},{"12":[2,7]},{"16":[1,225]},{"16":[1,226]},{"12":[2,11],"16":[2,11]},{"12":[2,12],"16":[2,12]},{"12":[2,13],"16":[2,13],"62":[1,227]},{"12":[2,6]},{"2":[1,15],"51":[1,11],"56":[1,13],"72":[1,12],"76":[1,8],"89":[1,10]},{"33":[1,163]},{"33":[1,163]},{"33":[1,163]},{"33":[1,163]},{"77":[1,233]},{"33":[1,163]},{"33":[1,163]},{"28":[1,76],"75":[1,126],"82":[1,127]},{"49":[1,204],"50":[1,203],"52":[1,201],"55":[1,202],"70":[1,200],"71":[1,199],"87":[1,198]},{"3":[1,237]},{"33":[1,91]},{"6":[1,239]},{"5":[1,94],"6":[1,240],"7":[1,95]},{"6":[1,241]},{"5":[1,94],"6":[1,242],"7":[1,95]},{"5":[1,94],"6":[1,243],"7":[1,95]},{"3":[2,36],"16":[2,36]},{"3":[2,37],"16":[2,37],"78":[1,244]},{"78":[1,245]},{"3":[1,246]},{"2":[1,247]},{"3":[2,50],"12":[2,50],"16":[2,50],"78":[2,50]},{"3":[2,51],"12":[2,51],"16":[2,51],"78":[2,51]},{"3":[2,142],"6":[2,142],"10":[2,142],"12":[2,142],"16":[2,142],"33":[2,142],"45":[2,142],"47":[2,142],"78":[2,142],"79":[2,142],"93":[2,142],"94":[2,142]},{"6":[2,113],"45":[2,113]},{"3":[2,62],"10":[2,62],"12":[2,62],"16":[2,62],"47":[2,62],"79":[2,62],"94":[2,62]},{"3":[2,52],"12":[2,52],"16":[2,52],"33":[2,52],"78":[2,52],"93":[2,52]},{"4":[1,193],"20":[1,194],"28":[1,195]},{"4":[1,193],"20":[1,194],"28":[1,195],"75":[1,249]},{"28":[1,76],"33":[1,74],"74":[1,73]},{"12":[2,5],"78":[1,16]},{"77":[1,252]},{"77":[1,253]},{"77":[1,254]},{"77":[1,255]},{"2":[1,256]},{"8":[1,64],"9":[1,63],"32":[1,62]},{"8":[1,64],"9":[1,63],"32":[1,62]},{"12":[2,16],"78":[2,16]},{"62":[1,259],"66":[1,260]},{"3":[2,34],"16":[2,34],"78":[2,34]},{"8":[1,64],"9":[1,63],"32":[1,62]},{"8":[1,64],"9":[1,63],"24":[1,152],"32":[1,62]},{"8":[1,64],"9":[1,63],"32":[1,62]},{"8":[1,64],"9":[1,63],"24":[1,152],"32":[1,62]},{"65":[1,265]},{"73":[1,266]},{"28":[1,76],"33":[1,74],"74":[1,73],"91":[1,268]},{"3":[2,37],"16":[2,37],"78":[1,244]},{"2":[1,132],"28":[1,76],"46":[1,206],"63":[1,138],"83":[1,137],"90":[1,136],"92":[1,135]},{"12":[2,8]},{"12":[2,9]},{"12":[2,10]},{"12":[2,14],"16":[2,14],"47":[1,102]},{"2":[1,270]},{"2":[1,271]},{"2":[1,272]},{"2":[1,273]},{"2":[1,132],"28":[1,76],"46":[1,206],"63":[1,138],"83":[1,137],"90":[1,136],"92":[1,135]},{"6":[1,275]},{"6":[1,276]},{"28":[1,76],"33":[1,74],"74":[1,73]},{"2":[1,278]},{"77":[1,279]},{"77":[1,280]},{"77":[1,281]},{"77":[1,282]},{"14":[1,283]},{"33":[1,163],"44":[1,284]},{"3":[2,40],"16":[2,40],"47":[1,102]},{"3":[2,41],"16":[2,41]},{"3":[1,286]},{"2":[1,132],"28":[1,76],"46":[1,206],"63":[1,138],"83":[1,137],"90":[1,136],"92":[1,135]},{"2":[1,132],"28":[1,76],"46":[1,206],"63":[1,138],"83":[1,137],"90":[1,136],"92":[1,135]},{"2":[1,132],"28":[1,76],"46":[1,206],"63":[1,138],"83":[1,137],"90":[1,136],"92":[1,135]},{"2":[1,132],"28":[1,76],"46":[1,206],"63":[1,138],"83":[1,137],"90":[1,136],"92":[1,135]},{"3":[1,291]},{"8":[1,64],"9":[1,63],"32":[1,62]},{"8":[1,64],"9":[1,63],"32":[1,62]},{"3":[2,20],"16":[2,20],"47":[1,102]},{"2":[1,132],"28":[1,76],"46":[1,206],"63":[1,138],"83":[1,137],"90":[1,136],"92":[1,135]},{"2":[1,295]},{"2":[1,296]},{"2":[1,297]},{"2":[1,298]},{"8":[1,64],"9":[1,63],"24":[1,152],"32":[1,62]},{"33":[1,163]},{"3":[2,38],"16":[2,38]},{"3":[2,43],"16":[2,43],"78":[2,43]},{"3":[1,302]},{"3":[1,303]},{"3":[1,304]},{"3":[1,305]},{"3":[2,25],"16":[2,25]},{"77":[1,306]},{"77":[1,307]},{"3":[1,308]},{"2":[1,15],"51":[1,11],"56":[1,13],"72":[1,88],"89":[1,10]},{"2":[1,15],"51":[1,11],"56":[1,13],"72":[1,88],"89":[1,10]},{"2":[1,132],"28":[1,76],"46":[1,206],"63":[1,138],"83":[1,137],"90":[1,136],"92":[1,135]},{"2":[1,132],"28":[1,76],"46":[1,206],"63":[1,138],"83":[1,137],"90":[1,136],"92":[1,135]},{"3":[2,35],"16":[2,35]},{"6":[1,314],"45":[1,313]},{"6":[2,54],"45":[2,54]},{"3":[2,23],"16":[2,23]},{"3":[2,21],"16":[2,21]},{"3":[2,22],"16":[2,22]},{"3":[2,24],"16":[2,24]},{"2":[1,315]},{"2":[1,316]},{"3":[2,33],"16":[2,33],"78":[2,33]},{"3":[1,317]},{"3":[1,318]},{"3":[1,319]},{"3":[1,320]},{"3":[2,39],"16":[2,39]},{"33":[1,163]},{"2":[1,132],"28":[1,76],"46":[1,206],"63":[1,138],"83":[1,137],"90":[1,136],"92":[1,135]},{"2":[1,132],"28":[1,76],"46":[1,206],"63":[1,138],"83":[1,137],"90":[1,136],"92":[1,135]},{"3":[2,29],"16":[2,29]},{"3":[2,30],"16":[2,30]},{"3":[2,31],"16":[2,31]},{"3":[2,32],"16":[2,32]},{"6":[2,55],"45":[2,55]},{"3":[1,324]},{"3":[1,325]},{"3":[2,26],"16":[2,26]},{"3":[2,27],"16":[2,27]}];
const SEMANTIC_ACTION = [
((x) => x),
((_, constant) => constant),
((_, filter) => filter),
((_, policy) => policy),
((rule) => new Ast.Program([], [], [rule], null)),
((_1, _2, user, _3, rule) => new Ast.Program([], [], [rule], new Ast.Value.Entity(user.value, 'tt:username', null))),
((_1, _2, policy) => policy),
((user, _, policy) => policy.set({ principal: user })),
((_1, _2, action) => new Ast.PermissionRule(Ast.BooleanExpression.True, Ast.PermissionFunction.Builtin, action)),
((query, _1, _2) => new Ast.PermissionRule(Ast.BooleanExpression.True, query, Ast.PermissionFunction.Builtin)),
((query, _1, action) => new Ast.PermissionRule(Ast.BooleanExpression.True, query, action)),
((_) => Ast.PermissionFunction.Star),
((klass) => new Ast.PermissionFunction.ClassStar(klass.value)),
((fn) => new Ast.PermissionFunction.Specified(fn.value.kind, fn.value.channel, Ast.BooleanExpression.True, null)),
((fn, _, filter) => new Ast.PermissionFunction.Specified(fn.value.kind, fn.value.channel, filter, null)),
((stream, _, action) => new Ast.Statement.Rule(stream, [action])),
((_1, _2, table, _3, action) => new Ast.Statement.Command(table, [action])),
((_1, _2, action) => new Ast.Statement.Command(null, [action])),
((rule, _, pp) => {
                           rule.actions[0].in_params.push(pp);
                           return rule;
                       }),
((get) => Ast.Table.Invocation(get, null)),
((_1, table, _2, _3, filter) => new Ast.Table.Filter(table, filter, null)),
((_1, op, field, _2, _3, table, _4) => new Ast.Table.Aggregation(table, field.name, op, null, null)),
((_1, op, field, _2, _3, table, _4) => new Ast.Table.Aggregation(table, field.name, op, null, null)),
((_1, op, field, _2, _3, table, _4) => new Ast.Table.Aggregation(table, field.name, op, null, null)),
((_1, op, field, _2, _3, table, _4) => new Ast.Table.Aggregation(table, field.name, op, null, null)),
((_1, op, _2, _3, table, _4) => new Ast.Table.Aggregation(table, '*', op, null, null)),
((_1, op, field, base, _2, limit, _3, _4, table, _5) => new Ast.Table.ArgMinMax(table, field.name, op, null, null)),
((_1, op, field, base, _2, limit, _3, _4, table, _5) => new Ast.Table.ArgMinMax(table, field.name, op, null, null)),
((x) => x),
((_1, base, _2, delta, _3, _4, stream, _5) => new Ast.Table.Window(base, delta, stream, null)),
((_1, base, _2, delta, _3, _4, stream, _5) => new Ast.Table.TimeSeries(base, delta, stream, null)),
((_1, base, _2, delta, _3, _4, table, _5) => new Ast.Table.Sequence(base, delta, table, null)),
((_1, base, _2, delta, _3, _4, table, _5) => new Ast.Table.History(base, delta, table, null)),
((_1, t1, _2, _3, _4, t2, _5) => new Ast.Table.Join(t1, t2, [], null)),
((join, _, pp) => {
                           join.in_params.push(pp);
                           return join;
                       }),
((_1, _2, _3, base, _4, _5, _6, interval) => new Ast.Stream.Timer(base, interval, null)),
((_1, _2, _3, time) => new Ast.Stream.AtTimer(time, null)),
((monitor, _1, table, _2) => new Ast.Stream.Monitor(table, null, null)),
((monitor, _1, table, _2, _3, _4, pname) => new Ast.Stream.Monitor(table, [pname.name], null)),
((monitor, _1, table, _2, _3, _4, _5, pnames, _6) => new Ast.Stream.Monitor(table, pnames.map((p) => p.name), null)),
((_1, _2, stream, _3, _4, filter) => new Ast.Stream.EdgeFilter(stream, filter, null)),
((_1, _2, stream, _3, _4, filter) => new Ast.Stream.EdgeFilter(stream, Ast.BooleanExpression.True, null)),
((x) => x),
((_1, s1, _2, _3, _4, t2, _5) => new Ast.Stream.Join(s1, t2, [], null)),
((join, _, pp) => {
                           join.in_params.push(pp);
                           return join;
                       }),
(() => Generate.notifyAction()),
(() => Generate.notifyAction('return')),
((x) => x),
((fn) => new Ast.Invocation(new Ast.Selector.Device(fn.value.kind, null, null), fn.value.channel, [], null)),
((inv, ip) => {
                           inv.in_params.push(ip);
                           return inv;
                       }),
((pname, _1, out_param) => new Ast.InputParam(pname.value, out_param)),
((pname, _1, _2) => new Ast.InputParam(pname.value, new Ast.Value.Event(null))),
((pname, _1, v) => new Ast.InputParam(pname.value, v)),
((pname) => new Ast.Value.VarRef(pname.value)),
((pname) => [pname]),
((list, _, pname) => list.concat(pname)),
((x) => x),
((f1, _, f2) => new Ast.BooleanExpression.And([f1, f2])),
((x) => x),
((_, f) => new Ast.BooleanExpression.Not(f)),
((f1, _, f2) => new Ast.BooleanExpression.Or([f1, f2])),
((pname, [op, v]) => new Ast.BooleanExpression.Atom(pname.value, op, v)),
((fn, _1, filter, _3) => new Ast.BooleanExpression.External(fn.selector, fn.channel, fn.in_params, filter, fn.schema)),
((op, v) => [op, v]),
((op, v) => [op, v]),
((op, v) => [op, v]),
((op, v) => [op, v]),
((op, v) => [op, v]),
((op, v) => [op, v]),
((op, v) => [op, v]),
((op, v) => [op, v]),
((op, v) => [op, v]),
((op, v) => [op, v]),
((op, v) => [op, v]),
((op, v) => [op, v]),
((op, v) => [op, v]),
((op, v) => [op, v]),
((op, v) => [op, v]),
((op, v) => [op, v]),
((op, v) => [op, v]),
((op, v) => [op, v]),
((op, v) => [op, v]),
((op, v) => [op, v]),
((op, v) => [op, v]),
((op, v) => [op, v]),
((op, v) => [op, v]),
((op, v) => [op, v]),
((op, v) => [op, v]),
((op, v) => [op, v]),
((x) => x),
((x) => x),
((x) => x),
((x) => x),
((tok) => new Ast.Value.Measure(tok.value.value, tok.value.unit)),
((x) => x),
((x) => x),
((x) => x),
((x) => x),
((x) => x),
((x) => x),
((x) => x),
((x) => x),
((x) => x),
((x) => x),
((x) => x),
((x) => x),
((x) => x),
((x) => x),
((x) => x),
((x) => x),
((slot) => slot.value === undefined ? Ast.Value.Undefined(true) : slot.value),
((_1, values, _2) => new Ast.Value.Array(values)),
((v) => [v]),
((array, _, v) => {
                                   array.push(v);
                                   return array;
                               }),
(() => new Ast.Value.Boolean(true)),
(() => new Ast.Value.Boolean(false)),
((str) => new Ast.Value.String('')),
((str) => new Ast.Value.String(str.value)),
((_1, str, _2) => new Ast.Value.String(str)),
((word) => word.value),
((list, word) => list + ' ' + word.value),
((num, unit) => new Ast.Value.Measure(num.value, unit.value)),
((v1, num, unit) => {
                              if (v1.isCompoundMeasure) {
                                  v1.value.push(new Ast.Value.Measure(num.value, unit.value));
                                  return v1;
                              } else {
                                  return new Ast.Value.CompoundMeasure([v1, new Ast.Value.Measure(num.value, unit.value)]);
                              }
                          }),
((x) => x),
((tok) => new Ast.Value.Measure(tok.value.value, tok.value.unit)),
((num) => new Ast.Value.Number(num.value)),
(() => new Ast.Value.Number(1)),
(() => new Ast.Value.Number(0)),
((tok) => new Ast.Value.Currency(tok.value.value, tok.value.unit)),
((tag) => new Ast.Value.Location(new Ast.Location.Relative(tag.substr('location:'.length)))),
((tag) => new Ast.Value.Location(new Ast.Location.Relative(tag.substr('location:'.length)))),
((tag) => new Ast.Value.Location(new Ast.Location.Relative(tag.substr('location:'.length)))),
((loc) => new Ast.Value.Location(new Ast.Location.Absolute(loc.value.latitude, loc.value.longitude, loc.value.display||null))),
((loc) => new Ast.Value.Date(null, '+', null)),
((edge, unit) => new Ast.Value.Date(new Ast.DateEdge(edge, unit.value), '+', null)),
((edge, unit) => new Ast.Value.Date(new Ast.DateEdge(edge, unit.value), '+', null)),
((abs) => new Ast.Value.Date(parseDate(abs.value), '+', null)),
((date, op, offset) => new Ast.Value.Date(date.value, op, offset)),
((date, op, offset) => new Ast.Value.Date(date.value, op, offset)),
((time) => new Ast.Value.Time(time.value.hour, time.value.minute, time.value.second||0)),
((venum) => new Ast.Value.Enum(venum.value)),
((entity) => new Ast.Value.Entity(entity.value.value, entity.value.type, entity.value.display)),
((_1, str, _2, type) => {
                                    if (type.value === 'tt:hashtag' || type.value === 'tt:username')
                                        return new Ast.Value.Entity(str, type.value, null);
                                    else
                                        return new Ast.Value.Entity(null, type.value, str);
                                    }),
((entity) => new Ast.Value.Entity(entity.value, 'tt:username', null)),
((entity) => new Ast.Value.Entity(entity.value, 'tt:hashtag', null)),
((entity) => new Ast.Value.Entity(entity.value, 'tt:url', null)),
((entity) => new Ast.Value.Entity(entity.value, 'tt:phone_number', null)),
((entity) => new Ast.Value.Entity(entity.value, 'tt:email_address', null)),
((entity) => new Ast.Value.Entity(entity.value, 'tt:path_name', null)),
((entity) => new Ast.Value.Entity(entity.value, 'tt:device', null)),
((entity) => new Ast.Value.Entity(entity.kind + ':' + entity.device, 'tt:function', null)),
((entity) => new Ast.Value.Entity(entity.value, 'tt:picture', null)),
((x, _) => x),
];
module.exports = require('./sr_parser')(TERMINAL_IDS, RULE_NON_TERMINALS, ARITY, GOTO, PARSER_ACTION, SEMANTIC_ACTION);

},{"./ast":44,"./date_utils":49,"./generate":54,"./sr_parser":64}],59:[function(require,module,exports){
// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2017 The Board of Trustees of the Leland Stanford Junior University
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
//
// See COPYING for details
"use strict";

const adt = require('adt');
const util = require('util');

const Ast = require('./ast');
const Type = require('./type');
const NNOutputParser = require('./nn_output_parser');
const { parseDate } = require('./date_utils');

class TokenWrapper {
    constructor(token, value) {
        this.token = token;
        this.value = value;
    }

    toString() {
        return this.token;
    }
}

class SequenceLexer {
    constructor(sequence, entities) {
        this._sequence = sequence;
        if (!Array.isArray(sequence))
            this._sequence = Array.from(sequence);

        if (typeof entities !== 'function') {
            this._entities = (next) => {
                if (!(next in entities)) {
                    if (next.startsWith('SLOT_'))
                        return undefined;
                    throw new SyntaxError('Invalid entity ' + next + ', have ' + Object.keys(entities));
                }
                return entities[next];
            };
        } else {
            this._entities = entities;
        }

        this._i = 0;
        this._lastfunction = null;
        this._lastparam = null;
        this._instring = false;
    }

    next() {
        if (this._i >= this._sequence.length)
            return { done: true };

        let next = this._sequence[this._i++];
        if (next === '"') {
            this._instring = !this._instring;
        } else if (this._instring) {
            next = new TokenWrapper('WORD', next);
        } else if (/^[A-Z]/.test(next)) {
            // check if we have a unit next, to pass to the entity retriever
            let unit = null;
            // note that this._i has already been increased
            if (this._i < this._sequence.length && this._sequence[this._i].startsWith('unit:'))
                unit = this._sequence[this._i].substring('unit:'.length);

            // entity
            const entity = this._entities(next, this._lastparam, this._lastfunction, unit);
            const entityType = next.substring(0, next.lastIndexOf('_'));
            if (entityType.startsWith('GENERIC_ENTITY_')) {
                next = new TokenWrapper('GENERIC_ENTITY', {
                    value: entity.value,
                    display: entity.display,
                    type: entityType.substring('GENERIC_ENTITY_'.length)
                });
            } else {
                next = new TokenWrapper(entityType, entity);
            }
        } else if (next.startsWith('@')) {
            this._lastfunction = next;
            let lastPeriod = next.lastIndexOf('.');
            let kind = next.substring(1, lastPeriod);
            let channel = next.substring(lastPeriod+1);
            if (!kind || !channel)
                throw new Error('Invalid function ' + next);
            if (channel === '*')
                next = new TokenWrapper('CLASS_STAR', kind);
            else
                next = new TokenWrapper('FUNCTION', { kind, channel });
        } else if (next.startsWith('enum:')) {
            next = new TokenWrapper('ENUM', next.substring('enum:'.length));
        } else if (next.startsWith('param:')) {
            let [,paramname,] = next.split(':');
            this._lastparam = paramname;
            next = new TokenWrapper('PARAM_NAME', paramname);
        } else if (next.startsWith('unit:')) {
            next = new TokenWrapper('UNIT', next.substring('unit:'.length));
        } else if (next.startsWith('device:')) {
            next = new TokenWrapper('DEVICE', next.substring('device:'.length));
        } else if (next.startsWith('^^')) {
            next = new TokenWrapper('ENTITY_TYPE', next.substring('^^'.length));
        }
        return { done: false, value: next };
    }
}


function fromNN(sequence, entities) {
    let parser = new NNOutputParser();
    return parser.parse({
        [Symbol.iterator]() {
            return new SequenceLexer(sequence, entities);
        }
    });
}


// A lazy functional list
const List = adt.data(function() {
    return {
        Nil: null,
        Cons: {
            head: adt.any,
            tail: adt.only(this)
        },
        Snoc: {
            head: adt.only(this),
            tail: adt.any
        },
        Concat: {
            first: adt.only(this),
            second: adt.only(this)
        }
    };
});
List.prototype.flatten = function(into) {
    if (this.isNil)
        return into;
    if (this.isCons) {
        into.push(this.head);
        return this.tail.flatten(into);
    } else if (this.isSnoc) {
        this.head.flatten(into);
        into.push(this.tail);
        return into;
    } else if (this.isConcat) {
        this.first.flatten(into);
        return this.second.flatten(into);
    } else {
        throw new TypeError();
    }
};
List.prototype.getFirst = function() {
    if (this.isNil)
        return null;
    if (this.isCons)
        return this.head;
    if (this.isSnoc)
        return this.head.getFirst();
    if (this.isConcat)
        return this.first.getFirst();
    throw new TypeError();
};
List.concat = function(...lists) {
    let result = List.Nil;
    for (let i = lists.length-1; i >= 0; i--) {
        if (lists[i] instanceof List)
            result = List.Concat(lists[i], result);
        else
            result = List.Cons(lists[i], result);
    }
    return result;
};
List.singleton = function(el) {
    return List.Cons(el, List.Nil);
};

class UnsynthesizableError extends Error {
    constructor(what) {
        super(what + ' cannot be synthesized');
    }
}

function unescape(symbol) {
    return symbol.replace(/_([0-9a-fA-Z]{2}|_)/g, (match, ch) => {
        if (ch === '_') return ch;
        return String.fromCharCode(parseInt(ch, 16));
    });
}

function constantToNN(constant) {
    let measure = /__const_NUMBER_([0-9]+)__([a-z0-9A-Z]+)/.exec(constant);
    if (measure !== null)
        return List.concat('NUMBER_' + measure[1], 'unit:' + measure[2]);

    return List.singleton(unescape(constant.substring('__const_'.length)));
}

function filterToCNF(filter) {
    filter = (function pushDownNegations(expr) {
        if (expr.isNot) {
            if (expr.expr.isAtom || expr.expr.isExternal)
                return expr;
            if (expr.expr.isAnd)
                return Ast.BooleanExpression.Or(expr.expr.operands.map(pushDownNegations));
            if (expr.expr.isOr)
                return Ast.BooleanExpression.And(expr.expr.operands.map(pushDownNegations));
            if (expr.expr.isTrue)
                return Ast.BooleanExpression.False;
            if (expr.expr.isFalse)
                return Ast.BooleanExpression.True;
            throw new TypeError();
        } else if (expr.isAnd) {
            return Ast.BooleanExpression.And(expr.operands.map(pushDownNegations));
        } else if (expr.isOr) {
            return Ast.BooleanExpression.Or(expr.operands.map(pushDownNegations));
        } else {
            return expr;
        }
    })(filter);

    filter = filter.optimize();
    if (filter.isTrue || filter.isFalse)
        return filter;

    let clauses = [];
    let ands;
    if (!filter.isAnd)
        ands = [filter];
    else
        ands = filter.operands;

    for (let and of ands) {
        let currentClause = [];

        let ors;
        if (and.isOr)
            ors = and.operands;
        else
            ors = [and];

        for (let or of ors) {
            if (or.isNot || or.isAtom || or.isExternal) {
                currentClause.push(or);
                continue;
            }
            if (or.isOr) { // flatten
                ors.push(...or.operands);
                continue;
            }
            if (or.isAnd)
                throw new Error('TODO');
        }
        clauses.push(Ast.BooleanExpression.Or(currentClause));
    }
    return Ast.BooleanExpression.And(clauses);
}

class ToNNConverter {
    constructor(sentence, entities) {
        if (typeof sentence === 'string')
            sentence = sentence.split(' ');
        this.sentence = sentence;
        this.entities = entities;
    }

    findEntityFromSentence(entityType, value, display) {
        let entityString = entityType.startsWith('GENERIC_ENTITY_') ? display : value;
        if (entityType === 'QUOTED_STRING' || entityType === 'HASHTAG' || entityType === 'USERNAME' ||
            (entityType.startsWith('GENERIC_ENTITY_') && value === null && display)) {

            let entityTokens = entityString.split(' ');
            for (let i = 0; i <= this.sentence.length-entityTokens.length; i++) {
                let found = true;
                for (let j = 0; j < entityTokens.length; j++) {
                    if (entityTokens[j] !== this.sentence[i+j]) {
                        found = false;
                        break;
                    }
                }
                if (found) {
                    if (entityType === 'QUOTED_STRING')
                        return List.concat('"', entityString, '"');
                    else if (entityType === 'HASHTAG')
                        return List.concat('"', entityString, '"', '^^tt:hashtag');
                    else if (entityType === 'USERNAME')
                        return List.concat('"', entityString, '"', '^^tt:username');
                    else
                        return List.concat('"', entityString, '"', '^^' + entityType.substring('GENERIC_ENTITY_'.length));
                }
            }
        }
        throw new Error('Cannot find entity ' + entityString + ' of type ' + entityType + ', have ' + util.inspect(this.entities));
    }

    findEntity(entityType, value, display, entities, { ignoreNotFound = false, ignoreMultiple = true } = {}) {
        let candidates = [];

        for (let what in entities) {
            if (what === '$used')
                continue;
            if (!what.startsWith(entityType + '_'))
                continue;

            if (entities[what] === value)
                candidates.push(what);
            if (entityType.startsWith('GENERIC_ENTITY_') && entities[what].value === value)
                candidates.push(what);

            switch (entityType) {
            case 'DURATION':
                if (entities[what].value === value.value &&
                    entities[what].unit === value.unit)
                    candidates.push(what);
                break;
            case 'CURRENCY':
                if (entities[what].value === value.value &&
                    entities[what].unit === value.code)
                    candidates.push(what);
                break;
            case 'TIME':
                if (entities[what].hour === value.hour &&
                    entities[what].minute === value.minute &&
                    (entities[what].second || 0) === value.second)
                    candidates.push(what);
                break;
            case 'DATE':
                if (!(entities[what] instanceof Date))
                    entities[what] = parseDate(entities[what]);
                if (+entities[what] === +value)
                    candidates.push(what);
                break;
            case 'LOCATION':
                if (Math.abs(entities[what].latitude - value.lat) < 0.01 &&
                    Math.abs(entities[what].longitude - value.lon) < 0.01)
                    candidates.push(what);
                break;
            }
        }

        if (!ignoreMultiple && candidates.length > 1)
            throw new Error('Ambiguous entity ' + value + ' of type ' + entityType);

        if (ignoreNotFound && candidates.length === 0)
            return null;
        if (!ignoreMultiple)
            return candidates[0];

        if (candidates.length === 0) {
            // uh oh we don't have the entity we want
            // see if we have an used pile, and try there for an unambiguous one

            let reuse = this.findEntity(entityType, value, display, entities.$used || {}, { ignoreMultiple: false, ignoreNotFound: true });
            if (reuse !== null)
                return reuse;
            else if (entityType === 'GENERIC_ENTITY_tt:country' && value === 'uk')
                return this.findEntity(entityType, 'gb', display, entities);
            else
                return this.findEntityFromSentence(entityType, value, display);
        } else {
            if (!entities.$used)
                Object.defineProperty(entities, '$used', { value: {}, writable: true, enumerable: false });

            // move the first entity (in sentence order) from this pile to the
            candidates.sort();
            let result = candidates.shift();
            entities.$used[result] = entities[result];
            delete entities[result];
            return result;
        }
    }

    valueToNN(value, schema) {
        if (value.isArray) {
            let list = this.valueToNN(value.value[0]);
            for (let i = 1; i < value.value.length; i++)
                list = List.concat(list, ',', this.valueToNN(value.value[i]));
            return List.concat('[', list, ']');
        } else if (value.isVarRef) {
            if (value.name === null || value.name === 'null')
                throw new TypeError('???');
            if (value.name.startsWith('__const'))
                return constantToNN(value.name);
            else
                return `param:${value.name}:${schema.out[value.name]}`;
        } else if (value.isUndefined) {
            throw new UnsynthesizableError('undefined value');
        } else if (value.isBoolean) {
            return value.value ? 'true' : 'false';
        } else if (value.isMeasure) {
            if (value.value === 0)
                return List.concat('0', 'unit:' + value.unit);
            if (value.value === 1)
                return List.concat('1', 'unit:' + value.unit);
            if (value.getType().unit === 'ms') {
                let duration = this.findEntity('DURATION', value, null, this.entities, { ignoreNotFound: true });
                if (duration !== null)
                    return List.concat(duration);
            }
            return List.concat(this.findEntity('NUMBER', value.value, null, this.entities), 'unit:' + value.unit);
        } else if (value.isString) {
            if (value.value === '')
                return '""';
            return this.findEntity('QUOTED_STRING', value.value, null, this.entities);
        } else if (value.isCompoundMeasure) {
            let list = this.valueToNN(value.value[0]);
            for (let i = 1; i < value.value.length; i++)
                list = List.Concat(list, this.valueToNN(value.value[i]));
            return list;
        } else if (value.isNumber) {
            if (value.value === 0)
                return '0';
            if (value.value === 1)
                return '1';
            return this.findEntity('NUMBER', value.value, null, this.entities);
        } else if (value.isCurrency) {
            return this.findEntity('CURRENCY', value, null, this.entities);
        } else if (value.isLocation) {
            if (value.value.isRelative)
                return 'location:' + value.value.relativeTag;
            else
                return this.findEntity('LOCATION', value.value, null, this.entities);
        } else if (value.isDate) {
            let base;
            if (value.value === null)
                base = 'now';
            else if (value.value instanceof Ast.DateEdge)
                base = List.concat(value.value.edge, 'unit:' + value.value.unit);
            else
                base = this.findEntity('DATE', value.value, null, this.entities);
            let offset;
            if (value.offset === null)
                offset = List.Nil;
            else
                offset = List.Cons(value.operator, this.valueToNN(value.offset));
            return List.concat(base, offset);
        } else if (value.isTime) {
            return this.findEntity('TIME', value, null, this.entities);
        } else if (value.isEntity) {
            switch (value.type) {
            case 'tt:function':
            case 'tt:picture':
                throw new UnsynthesizableError('Constant of entity type ' + value.type);
            case 'tt:device':
                return 'device:' + value.value;
            case 'tt:username':
            case 'tt:contact_name':
                return this.findEntity('USERNAME', value.value, null, this.entities);
            case 'tt:hashtag':
                return this.findEntity('HASHTAG', value.value, null, this.entities);
            case 'tt:url':
                return this.findEntity('URL', value.value, null, this.entities);
            case 'tt:phone_number':
                return this.findEntity('PHONE_NUMBER', value.value, null, this.entities);
            case 'tt:email_address':
                return this.findEntity('EMAIL_ADDRESS', value.value, null, this.entities);
            case 'tt:path_name':
                return this.findEntity('PATH_NAME', value.value, null, this.entities);
            default:
                return this.findEntity('GENERIC_ENTITY_' + value.type, value.value, value.display, this.entities);
            }
        } else if (value.isEnum) {
            return 'enum:' + value.value;
        } else if (value.isEvent) {
            if (value.name === null)
                return 'event';
            else if (value.name === 'null')
                throw new TypeError('???');
            else
                throw new UnsynthesizableError('$event.* other than $event');
        } else {
            throw new TypeError('Unexpected value ' + value);
        }
    }

    cnfFilterToNN(filter, schema) {
        let result = List.Nil;

        let andclauses = [];
        for (let and of filter.operands) {
            let andclause = List.Nil;
            for (let or of and.operands) {
                let negate = or.isNot;
                if (negate)
                    or = or.expr;
                let orclause;
                if (or.isAtom) {
                    orclause = List.concat(`param:${or.name}:${schema.out[or.name] || schema.inReq[or.name] || schema.inOpt[or.name]}`, or.operator, this.valueToNN(or.value, schema));
                } else {
                    orclause = List.concat(`@${or.selector.kind}.${or.channel}`);
                    for (let inParam of or.in_params) {
                        let ptype = or.schema.inReq[inParam.name] || or.schema.inOpt[inParam.name];
                        orclause = List.concat(orclause, `param:${inParam.name}:${ptype}`, '=', this.valueToNN(inParam.value));
                    }
                    orclause = List.concat(orclause, '{');
                    let subfilter = filterToCNF(or.filter);
                    if (subfilter.isFalse)
                        throw new UnsynthesizableError('Always false filters');
                    if (subfilter.isTrue)
                        orclause = List.concat(orclause, 'true', '}', ')');
                    else
                        orclause = List.concat(orclause, this.cnfFilterToNN(subfilter, or.schema), '}');
                }
                if (negate)
                    orclause = List.Cons('not', orclause);
                if (andclause === List.Nil)
                    andclause = orclause;
                else
                    andclause = List.concat(andclause, 'or', orclause);
            }
            andclauses.push(andclause);
        }
        andclauses.sort((a, b) => {
            let afirst = a.getFirst();
            let bfirst = b.getFirst();
            if (afirst < bfirst)
                return -1;
            else if (afirst > bfirst)
                return 1;
            return 0;
        });

        for (let andclause of andclauses) {
            if (result === List.Nil)
                result = andclause;
            else
                result = List.concat(result, 'and', andclause);
        }
        return result;
    }

    streamToNN(stream) {
        if (stream.isVarRef) {
            throw new UnsynthesizableError('Stream macros');
        } else if (stream.isTimer) {
            return List.concat('timer',
                'base', '=', this.valueToNN(stream.base), ',',
                'interval', '=', this.valueToNN(stream.interval));
        } else if (stream.isAtTimer) {
            return List.concat('attimer', 'time', '=', this.valueToNN(stream.time));
        } else if (stream.isMonitor) {
            const monitor = List.concat('monitor', '(', this.tableToNN(stream.table), ')');

            if (stream.args === null) {
                return monitor;
            } else if (stream.args.length > 1) {
                let list = `param:${stream.args[0]}:${stream.schema.out[stream.args[0]]}`;
                for (let i = 1; i < stream.args.length; i++)
                    list = List.concat(list, ',', `param:${stream.args[i]}:${stream.schema.out[stream.args[i]]}`);
                return List.concat(monitor, 'on', 'new', '[', list, ']');
            } else {
                return List.concat(monitor, 'on', 'new', `param:${stream.args[0]}:${stream.schema.out[stream.args[0]]}`);
            }
        } else if (stream.isEdgeNew) {
            throw new UnsynthesizableError('EdgeNew expressions');
        } else if (stream.isEdgeFilter) {
            let optimized = filterToCNF(stream.filter);
            if (optimized.isFalse)
                throw new UnsynthesizableError('Always false filters');
            if (optimized.isTrue)
                return List.concat('edge', '(', this.streamToNN(stream.stream), ')', 'on', 'true');
            else
                return List.concat('edge', '(', this.streamToNN(stream.stream), ')', 'on', this.cnfFilterToNN(optimized, stream.schema));
        } else if (stream.isFilter) {
            throw new UnsynthesizableError('Stream filters');
            /*let optimized = filterToCNF(stream.filter);
            if (optimized.isFalse)
                throw new UnsynthesizableError('Always false filters');
            if (optimized.isTrue)
                return streamToNN(stream.stream, entities);
            return List.concat('(', streamToNN(stream.stream, entities), ')',
                'filter', cnfFilterToNN(optimized, entities));*/
        } else if (stream.isProjection) {
            throw new UnsynthesizableError('Projection expressions');
        } else if (stream.isCompute) {
            throw new UnsynthesizableError('Compute expressions');
        } else if (stream.isAlias) {
            throw new UnsynthesizableError('Alias expressions');
        } else if (stream.isJoin) {
            let param_passing = List.Nil;
            stream.in_params.sort((p1, p2) => {
                if (p1.name < p2.name)
                    return -1;
                if (p1.name > p2.name)
                    return 1;
                return 0;
            });

            for (let inParam of stream.in_params) {
                let ptype = stream.table.schema.inReq[inParam.name] || stream.table.schema.inOpt[inParam.name];
                param_passing = List.concat(param_passing, 'on', `param:${inParam.name}:${ptype}`,
                    '=', this.valueToNN(inParam.value, stream.stream.schema));
            }
            return List.concat('(', this.streamToNN(stream.stream), ')',
                'join', '(', this.tableToNN(stream.table), ')', param_passing);
        } else {
            throw new TypeError();
        }
    }

    tableToNN(table) {
        if (table.isVarRef) {
            throw new UnsynthesizableError('Table macros');
        } else if (table.isInvocation) {
            let principal = null;
            if (table.invocation.selector.principal !== null)
                principal = this.valueToNN(table.invocation.selector.principal, null);

            let params = List.Nil;
            table.invocation.in_params.sort((p1, p2) => {
                if (p1.name < p2.name)
                    return -1;
                if (p1.name > p2.name)
                    return 1;
                return 0;
            });
            for (let inParam of table.invocation.in_params) {
                if (inParam.value.isUndefined && inParam.value.local)
                    continue;

                let ptype = table.invocation.schema.inReq[inParam.name] || table.invocation.schema.inOpt[inParam.name];
                // explicitly pass null to valueToNN because there should be no parameter passing at this level
                params = List.concat(params, `param:${inParam.name}:${ptype}`, '=', this.valueToNN(inParam.value, null));
            }

            let fn = `@${table.invocation.selector.kind}.${table.invocation.channel}`;
            if (principal)
                return List.concat(fn, 'of', principal, params);
            else
                return List.concat(fn, params);
        } else if (table.isFilter) {
            let optimized = filterToCNF(table.filter);
            if (optimized.isFalse)
                throw new UnsynthesizableError('Always false filters');
            if (optimized.isTrue)
                return this.tableToNN(table.table);
            return List.concat('(', this.tableToNN(table.table), ')',
                'filter', this.cnfFilterToNN(optimized, table.schema));
        } else if (table.isProjection) {
            throw new UnsynthesizableError('Projection expressions');
        } else if (table.isCompute) {
            throw new UnsynthesizableError('Compute expressions');
        } else if (table.isAlias) {
            throw new UnsynthesizableError('Alias expressions');
        } else if (table.isAggregation) {
            if (table.alias)
                throw new UnsynthesizableError('Aggregation alias');
            if (table.field === '*' && table.operator === 'count') {
                return List.concat('aggregate', 'count', 'of', '(',
                    this.tableToNN(table.table), ')');
            } else {
                return List.concat('aggregate', table.operator, 'param:' + table.field,
                    'of', '(', this.tableToNN(table.table), ')');
            }
        } else if (table.isArgMinMax) {
            return List.concat('aggregate', table.operator, 'param:' + table.field,
                this.valueToNN(table.base), ',', this.valueToNN(table.limit),
                'of', '(', this.tableToNN(table.table), ')');
        } else if (table.isJoin) {
            let param_passing = List.Nil;
            table.in_params.sort((p1, p2) => {
                if (p1.name < p2.name)
                    return -1;
                if (p1.name > p2.name)
                    return 1;
                return 0;
            });
            for (let inParam of table.in_params) {
                let ptype = table.rhs.schema.inReq[inParam.name] || table.rhs.schema.inOpt[inParam.name];

                param_passing = List.concat(param_passing, 'on', `param:${inParam.name}:${ptype}`,
                    '=', this.valueToNN(inParam.value, table.lhs.schema));
            }
            return List.concat('(', this.tableToNN(table.lhs), ')',
                'join', '(', this.tableToNN(table.rhs), ')', param_passing);
        } else if (table.isWindow) {
            return List.concat('window', this.valueToNN(table.base), ',',
                this.valueToNN(table.delta), 'of',
                '(', this.streamToNN(table.stream), ')');
        } else if (table.isTimeSeries) {
            return List.concat('timeseries', this.valueToNN(table.base), ',',
                this.valueToNN(table.delta), 'of',
                '(', this.streamToNN(table.stream), ')');
        } else if (table.isHistory) {
            return List.concat('history', this.valueToNN(table.base), ',',
                this.valueToNN(table.delta), 'of',
                '(', this.streamToNN(table.stream), ')');
        } else if (table.isSequence) {
            return List.concat('sequence', this.valueToNN(table.base), ',',
                this.valueToNN(table.delta), 'of',
                '(', this.streamToNN(table.stream), ')');
        } else {
            throw new TypeError();
        }
    }

    actionToNN(action, outschema) {
        if (action.selector.isBuiltin)
            return action.channel;

        let principal = null;
        if (action.selector.principal !== null)
            principal = this.valueToNN(action.selector.principal, null);

        let const_param = List.Nil;
        let param_passing = List.Nil;

        action.in_params.sort((p1, p2) => {
            if (p1.name < p2.name)
                return -1;
            if (p1.name > p2.name)
                return 1;
            return 0;
        });
        for (let inParam of action.in_params) {
            if (inParam.value.isUndefined && inParam.value.local)
                continue;
            let ptype = action.schema.inReq[inParam.name] || action.schema.inOpt[inParam.name];

            if ((inParam.value.isVarRef && !inParam.value.name.startsWith('__const')) || inParam.value.isEvent) {
                param_passing = List.concat(param_passing, 'on', `param:${inParam.name}:${ptype}`, '=',
                    this.valueToNN(inParam.value, outschema));
            } else {
                const_param = List.concat(const_param, `param:${inParam.name}:${ptype}`, '=', this.valueToNN(inParam.value));
            }
        }

        const fn = `@${action.selector.kind}.${action.channel}`;
        if (principal)
            return List.concat(fn, 'of', principal, const_param, param_passing);
        else
            return List.concat(fn, const_param, param_passing);
    }

    ruleToNN(rule) {
        if (rule.actions.length !== 1)
            throw new UnsynthesizableError('Rules with more than one action');
        return List.concat(this.streamToNN(rule.stream), '=>',
            this.actionToNN(rule.actions[0], rule.stream.schema));
    }
    commandToNN(command) {
        if (command.actions.length !== 1)
            throw new UnsynthesizableError('Rules with more than one action');
        if (command.table === null)
            return List.concat('now', '=>', this.actionToNN(command.actions[0], null));
        return List.concat('now', '=>', this.tableToNN(command.table),
            '=>', this.actionToNN(command.actions[0], command.table.schema));
    }

    permissionFunctionToNN(fn, ifbuiltin) {
        if (fn.isBuiltin)
            return ifbuiltin;
        if (fn.isStar)
            return '*';
        if (fn.isClassStar)
            return `@${fn.kind}.*`;

        let filter = filterToCNF(fn.filter);
        if (filter.isFalse)
            throw new UnsynthesizableError('Always false filters');
        if (filter.isTrue)
            return List.concat(`@${fn.kind}.${fn.channel}`);
        else
            return List.concat(`@${fn.kind}.${fn.channel}`, 'filter', this.cnfFilterToNN(filter, fn.schema));
    }

    permissionRuleToNN(rule) {
        let principal;
        let filter = filterToCNF(rule.principal);
        if (filter.isFalse)
            throw new UnsynthesizableError('Always false filters');
        if (filter.isTrue)
            principal = 'true';
        else
            principal = this.cnfFilterToNN(filter, { out: { source: Type.Entity('tt:contact') }, inReq: {}, inOpt: {} });
        let first = this.permissionFunctionToNN(rule.query, 'now');
        let second = this.permissionFunctionToNN(rule.action, 'notify');

        const sequence = List.concat('policy', principal, ':', first, '=>', second);
        return sequence.flatten([]);
    }

    programToNN(program) {
        if (program.classes.length !== 0 ||
            program.declarations.length !== 0 ||
            program.rules.length !== 1)
            throw new UnsynthesizableError('Programs with declarations or multiple rules');

        let principal = null;
        if (program.principal)
            principal = this.valueToNN(program.principal);
        let sequence;
        if (program.rules[0].isRule)
            sequence = this.ruleToNN(program.rules[0]);
        else
            sequence = this.commandToNN(program.rules[0]);
        if (program.principal)
            sequence = List.concat('executor', '=', principal, ':', sequence);

        // do something
        return sequence.flatten([]);
    }

    toNN(program) {
        if (program instanceof Ast.Program)
            return this.programToNN(program);
        else if (program instanceof Ast.PermissionRule)
            return this.permissionRuleToNN(program);
        else
            throw new TypeError();
    }
}

function toNN(program, sentence, entities) {
    // for backward compatibility with the old API
    if (!entities) {
        entities = sentence;
        sentence = '';
    }

    let converter = new ToNNConverter(sentence, entities);
    return converter.toNN(program);
}

module.exports = {
    fromNN,
    toNN,
    UnsynthesizableError
};
},{"./ast":44,"./date_utils":49,"./nn_output_parser":58,"./type":65,"adt":7,"util":73}],60:[function(require,module,exports){
// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Almond
//
// Copyright 2016 The Board of Trustees of the Leland Stanford Junior University
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
//
// See COPYING for details
"use strict";

const assert = require('assert');
const Ast = require('./ast');

const { isUnaryStreamToStreamOp,
        isUnaryTableToTableOp,
        isUnaryStreamToTableOp } = require('./utils');

function flattenAnd(expr) {
    let flattened = [];
    if (expr.isAnd) {
        for (let op of expr.operands) {
            let operands = flattenAnd(op);
            operands.forEach((op) => assert(op instanceof Ast.BooleanExpression));
            for (let subop of operands)
                flattened.push(subop);
        }
    } else {
        flattened.push(expr);
    }
    return flattened;
}

function flattenOr(expr) {
    let flattened = [];
    if (expr.isOr) {
        for (let op of expr.operands) {
            let operands = flattenOr(op);
            operands.forEach((op) => assert(op instanceof Ast.BooleanExpression));
            for (let subop of operands)
                flattened.push(subop);
        }
    } else {
        flattened.push(expr);
    }
    return flattened;
}

function optimizeFilter(expr) {
    if (expr.isTrue || expr.isFalse)
        return expr;
    if (expr.isAnd) {
        let operands = flattenAnd(expr).map((o) => optimizeFilter(o)).filter((o) => !o.isTrue);
        operands.forEach((op) => assert(op instanceof Ast.BooleanExpression));
        for (let o of operands) {
            if (o.isFalse)
                return Ast.BooleanExpression.False;
        }
        if (operands.length === 0)
            return Ast.BooleanExpression.True;
        if (operands.length === 1)
            return operands[0];
        return Ast.BooleanExpression.And(operands);
    }
    if (expr.isOr) {
        let operands = flattenOr(expr).map((o) => optimizeFilter(o)).filter((o) => !o.isFalse);
        operands.forEach((op) => assert(op instanceof Ast.BooleanExpression));
        for (let o of operands) {
            if (o.isTrue)
                return Ast.BooleanExpression.True;
        }
        if (operands.length === 0)
            return Ast.BooleanExpression.False;
        if (operands.length === 1)
            return operands[0];
        return Ast.BooleanExpression.Or(operands);
    }
    if (expr.isNot) {
        let subexpr = optimizeFilter(expr.expr);
        if (subexpr.isTrue)
            return Ast.BooleanExpression.False;
        if (subexpr.isFalse)
            return Ast.BooleanExpression.True;
        return Ast.BooleanExpression.Not(subexpr);
    }
    if (expr.isExternal) {
        let subfilter = optimizeFilter(expr.filter);
        if (subfilter.isFalse)
            return Ast.BooleanExpression.False;
        // NOTE: it does not hold that if subfilter is True
        // the whole expression is true, because the invocation
        // might return no results!
        return new Ast.BooleanExpression.External(expr.selector, expr.channel, expr.in_params, subfilter, expr.schema);
    }

    let lhs = expr.name;
    let rhs = expr.value;
    let op = expr.operator;
    if (rhs.isVarRef && rhs.name === lhs) {
        // x = x , x =~ x , x >= x, x <= x
        if (op === '==' || op === '=~' || op === '>=' || op === '<=')
            return Ast.BooleanExpression.True;
    }
    return expr;
}

function optimizeStream(stream) {
    if (stream.isVarRef || stream.isTimer || stream.isAtTimer)
        return stream;

    if (stream.isMonitor) {
        let table = optimizeTable(stream.table);
        if (!table)
            return null;
        stream.table = table;
        return stream;
    }

    if (stream.isFilter) {
        stream.filter = optimizeFilter(stream.filter);
        // handle constant filters
        if (stream.filter.isTrue)
            return optimizeStream(stream.stream);
        if (stream.filter.isFalse)
            return null;
        // compress filter of filter
        if (stream.stream.isFilter) {
            stream.filter = optimizeFilter(Ast.BooleanExpression.And([stream.filter, stream.stream.filter]));
            stream.stream = stream.stream.stream;
            return optimizeStream(stream);
        }

        // switch filter of monitor to monitor of filter
        if (stream.stream.isMonitor) {
            let newstream = new Ast.Stream.Monitor(
                new Ast.Table.Filter(stream.stream.table, stream.filter, stream.stream.table.schema),
                stream.stream.args,
                stream.stream.schema
            );
            return optimizeStream(newstream);
        }

        // switch filter of project to project of filter
        if (stream.stream.isProjection) {
            return optimizeStream(new Ast.Stream.Projection(
                new Ast.Stream.Filter(stream.stream.stream, stream.filter, stream.stream.stream.schema),
                stream.stream.args,
                stream.stream.schema
            ));
        }
    } else if (stream.isEdgeNew) {
        // collapse edge new of monitor or edge new of edge new
        if (stream.stream.isMonitor || stream.stream.isEdgeNew)
            return optimizeStream(stream.stream);
    } else if (stream.isEdgeFilter) {
        stream.filter = optimizeFilter(stream.filter);
        // handle constant filters
        // we don't optimize the isTrue case here: "edge on true" means only once
        if (stream.filter.isFalse)
            return null;
    }

    if (isUnaryStreamToStreamOp(stream)) {
        let inner = optimizeStream(stream.stream);
        if (!inner)
            return null;
        stream.stream = inner;
        return stream;
    }

    if (stream.isJoin) {
        let lhs = optimizeStream(stream.stream);
        if (!lhs)
            return null;
        let rhs = optimizeTable(stream.table);
        if (!rhs)
            return null;
        stream.stream = lhs;
        stream.table = rhs;
        return stream;
    }

    return stream;
}

function optimizeTable(table) {
    if (table.isVarRef || table.isInvocation)
        return table;

    if (table.isFilter) {
        table.filter = optimizeFilter(table.filter);
        // handle constant filters
        if (table.filter.isTrue)
            return optimizeTable(table.table);
        if (table.filter.isFalse)
            return null;
        // compress filter of filter
        if (table.table.isFilter) {
            table.filter = optimizeFilter(Ast.BooleanExpression.And([table.filter, table.table.filter]));
            table.table = table.table.table;
            return optimizeTable(table);
        }

        // switch filter of project to project of filter
        if (table.table.isProjection) {
            return optimizeTable(new Ast.Table.Projection(
                new Ast.Table.Filter(table.table.table, table.filter, table.table.table.schema),
                table.table.args,
                table.table.schema
            ));
        }
    }

    if (isUnaryTableToTableOp(table)) {
        let inner = optimizeTable(table.table);
        if (!inner)
            return null;
        table.table = inner;
        return table;
    }
    if (isUnaryStreamToTableOp(table)) {
        let inner = optimizeStream(table.stream);
        if (!inner)
            return null;
        table.stream = inner;
        return table;
    }

    if (table.isJoin) {
        let lhs = optimizeTable(table.lhs);
        if (!lhs)
            return null;
        let rhs = optimizeTable(table.rhs);
        if (!rhs)
            return null;
        table.lhs = lhs;
        table.rhs = rhs;
        return table;
    }

    return table;
}

function optimizeRule(rule) {
    if (rule.stream) {
        rule.stream = optimizeStream(rule.stream);
        if (!rule.stream)
            return null;
    } else if (rule.table) {
        rule.table = optimizeTable(rule.table);
        if (!rule.table)
            return null;
    }
    if (!rule.actions.length)
        return null;
    return rule;
}

function optimizeProgram(program) {
    let rules = [];
    program.rules.forEach((rule) => {
        let newrule = optimizeRule(rule);
        if (newrule)
            rules.push(newrule);
    });
    program.rules = rules;
    if (program.rules.length === 0 && program.declarations.length === 0)
        return null;
    else
        return program;
}

module.exports = {
    optimizeProgram,
    optimizeFilter
};

},{"./ast":44,"./utils":68,"assert":8}],61:[function(require,module,exports){
// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2017 The Board of Trustees of the Leland Stanford Junior University
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
//
// See COPYING for details
"use strict";

const assert = require('assert');
const smt = require('smtlib');

const Ast = require('./ast');
const Type = require('./type');
const Builtin = require('./builtin');

function arrayEquals(a, b) {
    if (a === null && b === null)
        return true;
    if (a === null || b === null)
        return false;
    if (a.length !== b.length)
        return false;

    for (var i = 0; i < a.length; i++) {
        if (a[i] !== b[i])
            return false;
    }

    return true;
}

function isGroupMember(principal, group, groupmap) {
    return (groupmap.get(principal) || []).indexOf(group) >= 0;
}

// Reduces a program and a set of Allowed rules into one call to the SMT, and invokes
// the SMT solver
class SmtReduction {
    constructor(SolverClass) {
        this._solver = new SolverClass();

        this._declarations = [];
        this._declarations.push(smt.DeclareSort('ResultId'));
        this._declarations.push(smt.DeclareDatatype('Location',
            ['loc.home', 'loc.work', 'loc.current_location',
             ['loc.absolute', '(loc.lat Real)', '(loc.lon Real)']]));
        this._entityTypes = new Set;
        let contactType = this._declareEntityType(Type.Entity('tt:contact'));
        let contactGroupType = this._declareEntityType(Type.Entity('tt:contact_group'));
        this._declarations.push(smt.DeclareFun('Entity_tt_contact.getGroups', [contactType], smt.SetType(contactGroupType)));

        this._currencies = new Set;
        this._enumtypes = [];

        this._fnparams = new Map;

        this._constants = new Map;

        this._classes = {};
        this._functions = new Set;
        this._asserts = [];

        this._filteridx = 0;
        this._filtermap = [];
        this._filterrevmap = new Map;

        this._externalfnidx = 0;
        this._uf = new Map;
    }

    _add(stmt) {
        this._solver.add(stmt);
    }

    _declare(stmt) {
        this._declarations.push(stmt);
    }

    _addEverything() {
        for (let [name, t] of this._enumtypes)
            this._add(smt.DeclareDatatype(name, t.entries.map((e) => name + '.' + e)));
        for (let decl of this._declarations)
            this._add(decl);
        for (let [name, t] of this._constants.entries())
            this._add(smt.DeclareFun(name, [], t));
        for (let assert of this._asserts)
            this._solver.assert(assert);
    }

    _makeEnumType(type) {
        for (let [name, enumType] of this._enumtypes) {
            if (arrayEquals(type.entries, enumType.entries))
                return name;
        }
        let name = 'Enum_' + this._enumtypes.length;
        this._enumtypes.push([name, type]);
        return name;
    }

    _declareEntityType(type) {
        let entityType = type.type;
        let smtType = 'Entity_' + entityType.replace(/[^A-Za-z0-9_]/g, '_');
        if (this._entityTypes.has(entityType))
            return smtType;

        this._entityTypes.add(entityType);
        this._declarations.push(smt.DeclareDatatype(smtType,
            [['mk.' + smtType, '(' + smtType + '.get String)']]));
        return smtType;
    }

    _getEntityValue(value, type) {
        this._declareEntityType(type);
        let entityType = type.type;
        let smtType = 'Entity_' + entityType.replace(/[^A-Za-z0-9_]/g, '_');
        return new smt.SExpr(smtType + '.get', value);
    }

    _typeToSmtType(type) {
        if (type.isArray)
            return smt.SetType(this._typeToSmtType(type.elem));
        if (type.isNumber || type.isMeasure)
            return 'Real';
        if (type.isBoolean)
            return 'Bool';
        if (type.isString)
            return 'String';
        if (type.isLocation)
            return 'Location';
        if (type.isTime || type.isDate)
            return 'Int';
        if (type.isEntity)
            return this._declareEntityType(type);
        if (type.isEnum)
            return this._makeEnumType(type);

        throw new TypeError('Unsupported type ' + type);
    }

    _numberToSmt(v) {
        if (v >= 0)
            return String(v);
        else
            return new smt.SExpr('-', -v);
    }

    _locToSmtValue(loc) {
        if (loc.isRelative)
            return 'loc.' + loc.relativeTag;

        return new smt.SExpr('loc.absolute', this._numberToSmt(loc.lat),
            this._numberToSmt(loc.lon));
    }

    _encodeEntityValue(ev) {
        return ev.replace(/[^A-Za-z0-9]/g, (c) =>
            '_' + c.charCodeAt(0).toString(16).toUpperCase());
    }

    _entityToSmtValue(entityValue, entityType) {
        let smtType = this._declareEntityType(Type.Entity(entityType));
        return new smt.SExpr('mk.' + smtType, smt.StringLiteral(entityValue));
    }

    _enumToSmtValue(enumerant, type) {
        let typename = this._makeEnumType(type);
        return typename + '.' + enumerant;
    }

    _currencyToSmt(v) {
        let code = v.code.toLowerCase();
        if (!this._currencies.has(code)) {
            this._declare(smt.DeclareFun('Currency_' + code, ['Real'], 'Real'));
            this._currencies.add(code);
        }

        return smt.Predicate('Currency_' + code, this._numberToSmt(v.value));
    }

    _valueToSmtValue(v, type) {
        if (v.isVarRef)
            throw new TypeError('Unexpected var ref in filter');
        if (v.isUndefined)
            throw new TypeError('Unexpected undefined TT value');
        if (v.isBoolean)
            return v.value ? 'true' : 'false';
        if (v.isString)
            return smt.StringLiteral(v.value);
        if (v.isCurrency)
            return this._currencyToSmt(v);
        if (v.isNumber || v.isMeasure)
            return this._numberToSmt(v.toJS()); // toJS() normalizes the measurement
        if (v.isLocation)
            return this._locToSmtValue(v.value);
        if (v.isEntity)
            return this._entityToSmtValue(v.value, v.type);
        if (v.isEnum)
            return this._enumToSmtValue(v.value, type);
        if (v.isTime)
            return String(v.hour * 3600 + v.minute * 60);
        if (v.isDate)
            return String(v.toJS().getTime()); // TODO handle relative dates correctly
        throw new TypeError('Unsupported value ' + v);
    }

    addGroups(principal, groups) {
        let lhs = smt.Predicate('Entity_tt_contact.getGroups', this._valueToSmtValue(principal, Type.Entity('tt:contact')));
        let contactGroupType = this._declareEntityType(Type.Entity('tt:contact_group'));

        let rhs;
        if (groups.length === 0) {
            rhs = new smt.SExpr('as', 'emptyset', smt.SetType(contactGroupType));
        } else if (groups.length === 1) {
            rhs = new smt.SExpr('singleton', this._valueToSmtValue(groups[0], Type.Entity('tt:contact_group')));
        } else {
            rhs = new smt.SExpr('insert',
                ...groups.slice(1).map((g) => this._valueToSmtValue(g, Type.Entity('tt:contact_group'))),
                new smt.SExpr('singleton', this._valueToSmtValue(groups[0], Type.Entity('tt:contact_group'))));
        }

        this._asserts.push(smt.Eq(lhs, rhs));
    }

    _getVarName(prefix, type) {
        let idx = 0;
        let vname = 'prog_' + prefix + '_' + idx;
        while (this._constants.has(vname))
            vname = 'prog_' + prefix + '_' + (++idx);
        this._constants.set(vname, this._typeToSmtType(type));
        return vname;
    }

    _filterToSmt(operator, param, paramType, value, valueType) {
        if (valueType.isEnum)
            valueType = paramType;
        if (operator !== 'group_member' && !valueType.equals(paramType)) {
            if (valueType.isEntity)
                value = this._getEntityValue(value, valueType);
            if (paramType.isEntity)
                param = this._getEntityValue(param, paramType);
        }

        switch (operator) {
        case '==':
            return smt.Eq(param, value);
        case '!=':
            return smt.NEq(param, value);
        case '>=':
            return smt.GEq(param, value);
        case '<=':
            return smt.LEq(param, value);
        case '>':
            return smt.GT(param, value);
        case '<':
            return smt.LT(param, value);
        case '=~':
            return smt.Predicate('str.contains', param, value);
        case '~=':
            return smt.Predicate('str.contains', value, param);
        case 'starts_with':
            return smt.Predicate('str.prefixof', value, param);
        case 'prefix_of':
            return smt.Predicate('str.prefixof', param, value);
        case 'ends_with':
            return smt.Predicate('str.suffixof', value, param);
        case 'suffix_of':
            return smt.Predicate('str.suffixof', param, value);
        case 'contains': // value is the element, param is the array
            return smt.Predicate('member', value, param);
        case 'in_array': // flip version of contains
            return smt.Predicate('member', param, value);
        case 'group_member': // value is the group, param is the principal
            return smt.Predicate('member', value, smt.Predicate('Entity_tt_contact.getGroups', param));
        case 'has_member': // flip version of group_member
            return smt.Predicate('member', param, smt.Predicate('Entity_tt_contact.getGroups', value));
        default:
            throw new TypeError('Unsupported operator ' + operator);
        }
    }

    _addGetPredicate(ast, scope, scopeType) {
        let [signature, ufvar] = this._declareUninterpretedFunction(ast.selector.kind, ast.channel, ast.schema);
        let extfnvar = this._declareFunction(ast.selector.kind, ast.channel, 'pred_' + this._externalfnidx ++,  ast.schema, ast.in_params);

        if (ast.schema.is_list)
            this._declare(smt.DeclareFun(extfnvar + '__resultId', [], 'ResultId'));

        let in_passed = {};
        for (let inParam of ast.in_params) {
            let ptype = ast.schema.inReq[inParam.name] || ast.schema.inOpt[inParam.name];
            if (inParam.value.isVarRef) {
                if (!scope[inParam.value.name] || !scopeType[inParam.value.name])
                    throw new TypeError('Invalid input parameter value ' + inParam.value.name);
                in_passed[inParam.name] = scope[inParam.value.name];
            } else {
                in_passed[inParam.name] = this._valueToSmtValue(inParam.value, ptype);
            }
        }
        let inargs = [];
        for (let name of signature) {
            if (name === '__resultId')
                inargs.push(extfnvar + '__resultId');
            else
                inargs.push(in_passed[name] || ufvar + '_' + name + '_null');
        }

        let subscope = {};
        Object.assign(subscope, scope);
        let subscopeType = {};
        Object.assign(subscopeType, scopeType);
        for (let name in ast.schema.out) {
            let predname = ufvar + '_' + name;
            this._asserts.push(smt.Eq('param_' + extfnvar + '_' + name, smt.Predicate(predname, ...inargs)));
            subscope[name] = 'param_' + extfnvar + '_' + name;
            subscopeType[name] = scopeType;
        }
        let anyresult = 'anyresult_' + extfnvar;
        this._constants.set(anyresult, 'Bool');
        this._asserts.push(smt.Eq(anyresult, smt.Predicate(ufvar + '_anyresult', ...inargs)));
        this._addInputParams(extfnvar, ast, scope, scopeType, []);
        return smt.And(anyresult, this._processFilter(ast.filter, subscope, subscopeType));
    }

    _processFilter(ast, scope, scopeType) {
        assert(scopeType);
        if (ast.isTrue)
            return 'true';
        if (ast.isFalse)
            return 'false';
        if (ast.isAnd && ast.operands.length === 0)
            return 'true';
        if (ast.isOr && ast.operands.length === 0)
            return 'false';
        if (ast.isAnd)
            return smt.And(...ast.operands.map((o) => this._processFilter(o, scope, scopeType)));
        if (ast.isOr)
            return smt.Or(...ast.operands.map((o) => this._processFilter(o, scope, scopeType)));
        if (ast.isNot)
            return smt.Not(this._processFilter(ast.expr, scope, scopeType));
        if (ast.isExternal) {
            return this._addGetPredicate(ast, scope, scopeType);
        } else {
            let filter = ast;
            let pname = scope[filter.name];
            let ptype = scopeType[filter.name];
            if (!ptype)
                throw new TypeError('Invalid filter left-hand-side ' + filter.name);
            if (filter.operator === 'contains')
                ptype = ptype.elem;
            if (filter.value.isUndefined)
                throw new TypeError('Invalid filter right hand side (should be slot filled)');
            if (filter.value.isVarRef) {
                if (!scope[filter.value.name] || !scopeType[filter.value.name])
                    throw new TypeError('Invalid filter right-hand-side ' + filter.value.name);
                return this._filterToSmt(filter.operator, pname, ptype,
                    scope[filter.value.name], scopeType[filter.value.name]);
            } else {
                return this._filterToSmt(filter.operator, pname, ptype,
                    this._valueToSmtValue(filter.value, ptype), filter.value.getType());
            }
        }
    }

    _processPermissionFilter(ast, ufvar, schema, scope, scopeType) {
        if (ast.isTrue)
            return 'true';
        if (ast.isFalse)
            return 'false';
        if (ast.isAnd && ast.operands.length === 0)
            return 'true';
        if (ast.isOr && ast.operands.length === 0)
            return 'false';
        if (ast.isAnd)
            return smt.And(...ast.operands.map((o) => this._processPermissionFilter(o, ufvar, schema, scope, scopeType)));
        if (ast.isOr)
            return smt.Or(...ast.operands.map((o) => this._processPermissionFilter(o, ufvar, schema, scope, scopeType)));
        if (ast.isNot)
            return smt.Not(this._processPermissionFilter(ast.expr, ufvar, schema, scope, scopeType));
        if (ast.isExternal) {
            return this._addGetPredicate(ast, {}, {});
        } else {
            let filter = ast;
            let ptype = schema.out[filter.name] || schema.inReq[filter.name] || schema.inOpt[filter.name];
            if (!ptype)
                throw new TypeError('Invalid filter left-hand-side ' + filter.name);
            if (filter.operator === 'contains')
                ptype = ptype.elem;
            if (filter.value.isUndefined)
                throw new TypeError('Invalid filter right hand side (should be slot filled)');
            let values = [];

            //console.error(String(ast));
            //console.log(this._fnparams);
            for (let pname of (this._fnparams.get(ufvar + ':' + filter.name) || [])) {
                if (filter.value.isVarRef) {
                    let rhs = scope[filter.value.name];
                    let rhsType = scopeType[filter.value.name];
                    for (let rhsname of (this._fnparams.get(rhs) || []))
                        values.push(this._filterToSmt(filter.operator, pname, ptype, rhsname, rhsType));
                } else {
                    values.push(this._filterToSmt(filter.operator, pname, ptype,
                        this._valueToSmtValue(filter.value, ptype), filter.value.getType()));
                }
            }
            if (values.length === 1)
                return values[0];
            if (values.length === 0)
                throw new Error('what');
            return smt.And(...values);
        }
    }

    _declareUninterpretedFunction(kind, fn, def) {
        let cleanKind = kind.replace(/[^A-Za-z0-9_]/g, '_');
        let ufvar = 'uf_' + cleanKind + '_' + fn;
        if (this._uf.has(ufvar))
            return [this._uf.get(ufvar), ufvar];

        let signames = [];
        let sigtypes = [];
        if (def.is_list) {
            signames.push('__resultId');
            sigtypes.push('ResultId');
        }

        for (let arg of def.args) {
            let type = def.inReq[arg] || def.inOpt[arg];
            if (!type || type.isAny)
                continue;
            signames.push(arg);
            sigtypes.push(this._typeToSmtType(type));
            if (def.inOpt[arg])
                this._declare(smt.DeclareFun(ufvar + '_' + arg + '_null', [], this._typeToSmtType(type)));
        }
        this._uf.set(ufvar, signames);

        for (let arg of def.args) {
            let type = def.out[arg];
            if (!type || type.isAny)
                continue;
            let p = ufvar + '_' + arg;
            this._declare(smt.DeclareFun(p, sigtypes, this._typeToSmtType(type)));
        }
        this._declare(smt.DeclareFun(ufvar + '_anyresult', sigtypes, 'Bool'));
        return [signames, ufvar];
    }

    _declareFunction(kind, fn, suffix, def) {
        kind = kind.replace(/[^A-Za-z0-9_]/g, '_');
        let fnvar = suffix;//kind + '_' + fn + '_' + suffix;
        if (this._functions.has(fnvar))
            return fnvar;

        let ufvar = 'uf_' + kind + '_' + fn;
        this._functions.add(fnvar);

        for (let arg of def.args) {
            let p = 'param_' + fnvar + '_' + arg;
            let type = def.inReq[arg] || def.inOpt[arg] || def.out[arg];
            if (type.isAny)
                continue;
            if (def.out[arg] && type.isTime)
                this._asserts.push(smt.And(smt.GEq(p, 0), smt.LEq(p, 86400)));
            this._declare(smt.DeclareFun(p, [], this._typeToSmtType(type)));
            this._addParam(ufvar, arg, p);
        }
        return fnvar;
    }

    _addParam(ufvar, param, value) {
        let key = ufvar + ':' + param;
        if (!this._fnparams.has(key))
            this._fnparams.set(key, []);
        this._fnparams.get(key).push(value);
    }

    _addInputParams(fnvar, prim, scope, scopeType, extraInParams) {
        let in_passed = {};
        assert(Array.isArray(extraInParams));
        for (let inParam of prim.in_params.concat(extraInParams)) {
            let pname = 'param_' + fnvar + '_' + inParam.name;
            let ptype = prim.schema.inReq[inParam.name] || prim.schema.inOpt[inParam.name];
            if (inParam.value.isUndefined)
                continue;
            if (inParam.value.isVarRef) {
                if (!scope[inParam.value.name] || !scopeType[inParam.value.name])
                    throw new TypeError('Invalid input parameter value ' + inParam.value.name);
                in_passed[inParam.name] = scope[inParam.value.name];
                this._asserts.push(this._filterToSmt('==', pname, ptype, scope[inParam.value.name], scopeType[inParam.value.name]));
            } else {
                in_passed[inParam.name] = this._valueToSmtValue(inParam.value, ptype);
                this._asserts.push(this._filterToSmt('==', pname, ptype,
                    this._valueToSmtValue(inParam.value, ptype), inParam.value.getType()));
            }
        }
        return in_passed;
    }

    _addGet(prim, scope, scopeType, extraInParams) {
        let [signature, ufvar] = this._declareUninterpretedFunction(prim.selector.kind, prim.channel, prim.schema);
        let fnvar = this._declareFunction(prim.selector.kind, prim.channel, 'get_' + this._externalfnidx ++,  prim.schema, prim.in_params);
        if (prim.schema.is_list)
            this._declare(smt.DeclareFun(fnvar + '__resultId', [], 'ResultId'));

        let in_passed = this._addInputParams(fnvar, prim, scope, scopeType, extraInParams);

        let inargs = [];
        for (let name of signature) {
            if (name === '__resultId') {
                assert(prim.schema.is_list);
                inargs.push(fnvar + '__resultId');
            } else {
                inargs.push(in_passed[name] || ufvar + '_' + name + '_null');
            }
        }
        for (let name in prim.schema.out) {
            let predname = ufvar + '_' + name;
            this._asserts.push(smt.Eq('param_' + fnvar + '_' + name, smt.Predicate(predname, ...inargs)));
            scope[name] = 'param_' + fnvar + '_' + name;
            scopeType[name] = prim.schema.out[name];
        }
    }

    _addAction(fn, prefix, scope, scopeType) {
        let fnvar = this._declareFunction(fn.selector.kind, fn.channel, prefix, fn.schema);
        this._addInputParams(fnvar, fn, scope, scopeType, []);
    }

    _addStream(stream, scope, scopeType) {
        if (stream.isTimer || stream.isAtTimer)
            return;
        if (stream.isMonitor) {
            this._addTable(stream.table, scope, scopeType, []);
            return;
        }
        if (stream.isEdgeNew) {
            this._addStream(stream.stream, scope, scopeType);
            return;
        }
        if (stream.isFilter || stream.isEdgeFilter) {
            this._addStream(stream.stream, scope, scopeType);
            this._asserts.push(this._processFilter(stream.filter, scope, scopeType));
            return;
        }
        if (stream.isJoin) {
            this._addStream(stream.stream, scope, scopeType);
            this._addTable(stream.table, scope, scopeType, stream.in_params);
            return;
        }
        if (stream.isProjection) {
            this._addStream(stream.stream, scope, scopeType);
            for (let name in scope) {
                if (stream.args.indexOf(name) < 0) {
                    delete scope[name];
                    delete scopeType[name];
                }
            }
            return;
        }

        throw new TypeError(`Unimplemented stream ${stream}`);
    }

    _addTable(table, scope, scopeType, extraInParams) {
        if (table.isInvocation) {
            this._addGet(table.invocation, scope, scopeType, extraInParams);
            return;
        }
        if (table.isFilter) {
            this._addTable(table.table, scope, scopeType, extraInParams);
            this._asserts.push(this._processFilter(table.filter, scope, scopeType));
            return;
        }
        if (table.isJoin) {
            this._addTable(table.lhs, scope, scopeType, extraInParams);
            this._addTable(table.rhs, scope, scopeType, extraInParams.concat(table.in_params));
            return;
        }
        if (table.isProjection) {
            this._addTable(table.table, scope, scopeType, extraInParams);
            for (let name in scope) {
                if (table.args.indexOf(name) < 0) {
                    delete scope[name];
                    delete scopeType[name];
                }
            }
            return;
        }

        throw new TypeError(`Unimplemented table ${table}`);
    }

    addRule(principal, program, rule) {
        for (let classdef of program.classes)
            this._classes[classdef.name] = classdef;

        let scope = {};
        let scopeType = {};
        if (rule.stream)
            this._addStream(rule.stream, scope, scopeType);
        else if (rule.table)
            this._addTable(rule.table, scope, scopeType, []);
        rule.actions.forEach((action, i) => {
            if (action.selector.isDevice && !isRemoteSend(action))
                this._addAction(action, 'a_' + i, scope, scopeType);
        });
    }

    _addPermissionFunction(fn, scope, scopeType) {
        let kind = fn.kind.replace(/[^A-Za-z0-9_]/g, '_');
        let ufvar = 'uf_' + kind + '_' + fn.channel;

        let ands = [];
        let filter = this._processPermissionFilter(fn.filter, ufvar, fn.schema, scope, scopeType);
        let name = this._filteridx++;
        this._filtermap[name] = fn.filter;
        this._filterrevmap.set(fn.filter, name);
        this._constants.set('filter_' + name, 'Bool');
        this._asserts.push(smt.Eq('filter_' + name, filter));
        ands.push('filter_' + name);

        for (let arg in fn.schema.out) {
            scope[arg] = ufvar + ':' + arg;
            scopeType[arg] = fn.schema.out[arg];
        }

        if (ands.length > 1)
            return smt.And(...ands);
        else
            return ands[0];
    }

    addPermission(permissionRule) {
        let ands = [];
        let scope = {};
        let scopeType = {};

        if (permissionRule.query.isSpecified)
            ands.push(this._addPermissionFunction(permissionRule.query, scope, scopeType));
        if (permissionRule.action.isSpecified)
            ands.push(this._addPermissionFunction(permissionRule.action, scope, scopeType));
        if (ands.length > 1)
            return smt.And(...ands);
        if (ands.length === 1)
            return ands[0];
        return 'true';
    }

    addAssert(v) {
        this._asserts.push(v);
    }

    checkSatisfiable(enableAssignments = false) {
        if (enableAssignments)
            this._solver.enableAssignments();
        this._addEverything();
        //this._solver.dump();
        return this._solver.checkSat().then(([sat, assignment, constants, unsatCore]) => {
            //console.log('CVC4 result: ', sat);
            this._assignment = assignment;
            this._assignedConstants = constants;
            this._unsatCore = unsatCore;
            return sat;
        });
    }

    getFilterName(filter) {
        let name = this._filterrevmap.get(filter);
        assert(typeof name === 'number');
        return 'filter_' + name;
    }

    isFilterTrue(filter) {
        if (!this._assignment) // unsat
            throw new Error('Not satifisiable');
        return this._assignment[this.getFilterName(filter)];
    }

    clone() {
        let self = new SmtReduction(this._solver.constructor);
        self._declarations = this._declarations;
        self._constants = this._constants;
        self._classes = this._classes;
        self._functions = this._functions;
        // make a copy of the array
        self._asserts = this._asserts.slice();

        self._filteridx = this._filteridx;
        self._filtermap = this._filtermap;
        self._filterrevmap = this._filterrevmap;

        return self;
    }
}

// Verifies that a program is allowed, with the help of an SMT solver

function promiseLoop(array, fn) {
    return (function loop(i) {
        if (i === array.length)
            return Promise.resolve();
        return Promise.resolve(fn(array[i], i)).then(() => loop(i+1));
    })(0);
}

const PARALLEL_DO_ALL = false;
function promiseDoAll(array, fn) {
    if (PARALLEL_DO_ALL)
        return Promise.all(array.map(fn));
    else
        return promiseLoop(array, fn);

}

function flipOperator(op) {
    switch (op) {
    case '==':
    case '!=':
        return op;
    case '<':
        return '>';
    case '<=':
        return '>=';
    case '>':
        return '<';
    case '>=':
        return '>=';
    case 'contains':
        return 'in_array';
    case 'in_array':
        return 'contains';
    case '=~':
        return '~=';
    case '~=':
        return '=~';
    case 'group_member':
        return 'has_member';
    case 'has_member':
        return 'group_member';
    case 'starts_with':
        return 'prefix_of';
    case 'prefix_of':
        return 'starts_with';
    case 'ends_with':
        return 'suffix_of';
    case 'suffix_of':
        return 'ends_with';
    default:
        throw new TypeError('invalid operator ' + op);
    }
}

const OP_FUNCTIONS = {
    '>': (a, b) => a > b,
    '<': (a, b) => a < b,
    '>=': (a, b) => a >= b,
    '<=': (a, b) => a <= b,
    '!': (a) => !a
};

function evaluateOp(builtinOp, arg1, arg2) {
    if (builtinOp.op)
        return OP_FUNCTIONS[builtinOp.op](arg1, arg2);
    else if (builtinOp.flip)
        return Builtin[builtinOp.fn](arg2, arg1);
    else
        return Builtin[builtinOp.fn](arg1, arg2);
}

function isRemoteSend(fn) {
    return (fn.selector.kind === 'org.thingpedia.builtin.thingengine.remote' || fn.selector.kind.startsWith('__dyn_')) &&
        fn.channel === 'send';
}

class RuleTransformer {
    constructor(SolverClass, principal, program, rule, permissiondb, groupmap) {
        this._SolverClass = SolverClass;
        this._groupmap = groupmap;

        this._principal = principal;
        this._program = program;
        this._classes = [];
        for (let classdef of program.classes)
            this._classes[classdef.name] = classdef;

        this._rule = rule;
        this._primKey = Array.from(rule.iteratePrimitives());

        this._relevantPermissions = this._computeRelevantPermissions(permissiondb);
        //console.log('Found ' + this._relevantPermissions.length + ' relevant permissions');
        //for (let permission of this._relevantPermissions)
        //    console.log(Ast.prettyprintPermissionRule(permission));

        this._newrule = null;
    }

    _addAllGroups(reduction) {
        for (let [principal, groups] of this._groupmap.entries()) {
            reduction.addGroups(Ast.Value.Entity(principal, 'tt:contact', null),
                groups.map((g) => Ast.Value.Entity(g, 'tt:contact_group', null)));
        }
    }

    _isFunctionPermissionRelevant(rulefn, programfn) {
        if (rulefn === Ast.PermissionFunction.Star)
            return true;
        if (programfn.selector.isBuiltin || isRemoteSend(programfn))
            return rulefn === Ast.PermissionFunction.Builtin;
        let kind = programfn.selector.kind;
        if (kind in this._classes)
            kind = this._classes[kind].extends;
        if (rulefn.isClassStar)
            return kind === rulefn.kind;
        if (rulefn.isSpecified)
            return kind === rulefn.kind && programfn.channel === rulefn.channel;
        return false;
    }

    _isPermissionRelevantForFunctions(rule) {
        if (!this._rule.stream && !this._rule.table &&
            !(rule.query.isBuiltin || rule.query.isStar))
            return false;

        for (let [primType, prim] of this._primKey) {
            if (primType === 'table') {
                if (!this._isFunctionPermissionRelevant(rule.query, prim))
                    return false;
            } else {
                if (!this._isFunctionPermissionRelevant(rule.action, prim))
                    return false;
            }
        }
        //console.log(Ast.prettyprintPermissionRule(rule) + ' is relevant');
        return true;
    }

    _hasGroup(principal, group) {
        if (group.value === 'tt:everyone')
            return true;
        return (this._groupmap.get(principal.value) || []).indexOf(group.value) >= 0;
    }

    _computeRelevantPermissions(permissiondb) {
        let ret = [];
        for (let rule of permissiondb) {
            if (!rule.principal.isTrue) {
                let inParamMap = {
                    source: this._principal
                };
                let simplified = this._partiallyEvalFilter(rule.principal, inParamMap, {}).optimize();
                if (simplified.isFalse)
                    continue;
                if (!simplified.isTrue)
                    throw new Error('Predicate on source is not either true or false?');
            }

            if (this._isPermissionRelevantForFunctions(rule))
                ret.push(rule);
        }
        return ret;
    }

    _addProgram(reduction, permissiondb = undefined) {
        reduction.addRule(this._principal, this._program, this._rule, permissiondb);
    }

    _isPermissionApplicable(permission) {
        // if we only have one permission, and we checked that the program was conditionally
        // allowed, skip the call and say yes
        if (this._relevantPermissions.length === 1) {
            console.error('Hit OPT 0');
            return Promise.resolve(true);
        }
        let filters = [];
        if (permission.query.isSpecified && !permission.query.filter.isTrue)
            filters.push(permission.query.filter);
        if (permission.action.isSpecified && !permission.action.filter.isTrue)
            filters.push(permission.action.filter);
        if (filters.every((f) => this._firstReduction.isFilterTrue(f))) {
            // we got lucky! the main reduction found a case where the filters
            // are all true
            // skip the call and say yes
            console.error('Hit OPT 1');
            return Promise.resolve(true);
        }
        if (filters.every((f) => this._secondReduction.isFilterTrue(f))) {
            // same thing, but with the second reduction
            console.error('Hit OPT 1');
            return Promise.resolve(true);
        }

        let reduction = new SmtReduction(this._SolverClass);
        this._addAllGroups(reduction);
        this._addProgram(reduction);
        reduction.addAssert(reduction.addPermission(permission));
        //console.log('Checking that permission ' + prettyprintPermissionRule(permission) + ' is applicable');
        return reduction.checkSatisfiable();
    }

    _isFilterImplied(permission, permissionFunction, check) {
        if (!permissionFunction.isSpecified)
            return Promise.resolve(true);
        let filter = permissionFunction.filter;
        if (filter.isTrue)
            return Promise.resolve(true);
        if (filter.isFalse)
            return Promise.resolve(false);
        if (!this._firstReduction.isFilterTrue(filter)) {
            // we got lucky! the main reduction found a case where this filter
            // is false
            // skip the call and say no
            console.error('Hit OPT 2');
            return Promise.resolve(false);
        }
        if (!this._secondReduction.isFilterTrue(filter)) {
            // same thing, but with the second reduction
            console.error('Hit OPT 2');
            return Promise.resolve(false);
        }

        let reduction = new SmtReduction(this._SolverClass);
        this._addAllGroups(reduction);
        this._addProgram(reduction);
        reduction.addPermission(permission);
        check(reduction);
        //console.log('Checking that filter ' + filter + ' in permission ' + prettyprintPermissionRule(permission) + ' is valid');
        return reduction.checkSatisfiable().then((r) => !r);
    }

    _partiallyEvalFilter(expr, inParamMap, previousPrimitiveDef) {
        const groupmap = this._groupmap;

        return (function recursiveHelper(expr) {
            if (expr.isTrue || expr.isFalse)
                return expr;
            if (expr.isOr)
                return Ast.BooleanExpression.Or(expr.operands.map(recursiveHelper));
            if (expr.isAnd)
                return Ast.BooleanExpression.And(expr.operands.map(recursiveHelper));
            if (expr.isNot)
                return Ast.BooleanExpression.Not(recursiveHelper(expr.expr));
            if (expr.isExternal) // external predicates don't refer to the inputs or outputs of the function so we're good
                return expr;

            let filter = expr;
            // the filter comes from tne Allowed() rule, it should not have anything funky
            assert(!filter.value.isUndefined);

            if (!inParamMap[filter.name])
                return expr;
            let lhs = inParamMap[filter.name];
            let rhs = filter.value;
            assert(!rhs.isVarRef);
            if (rhs.isVarRef && inParamMap[rhs.name])
                rhs = inParamMap[rhs.name];
            if (rhs.isVarRef && previousPrimitiveDef[rhs.name])
                rhs = Ast.Value.VarRef(rhs.name);
            if (lhs.isUndefined)
                throw new Error('Unexpected $undefined');
            if (lhs.isVarRef) {
                if (previousPrimitiveDef[lhs.name])
                    return new Ast.BooleanExpression.Atom(lhs.name, filter.operator, rhs);
                else
                    return new Ast.BooleanExpression.Atom(lhs.name, filter.operator, rhs);
            } else {
                if ((lhs.isLocation && lhs.value.isRelative) ||
                    (rhs.isLocation && rhs.value.isRelative))
                    return expr;
                if (rhs.isVarRef)
                    return new Ast.BooleanExpression.Atom(Ast.Filter(rhs.name, flipOperator(filter.operator), lhs));
                let jslhs = lhs.toJS();
                let jsrhs = rhs.toJS();
                let result;
                if (filter.operator === 'group_member')
                    result = isGroupMember(jslhs, jsrhs, groupmap);
                else
                    result = evaluateOp(Builtin.BinaryOps[filter.operator], jslhs, jsrhs);
                if (result === true)
                    return Ast.BooleanExpression.True;
                else if (result === false)
                    return Ast.BooleanExpression.False;
                else
                    throw new TypeError('Partially evaluated filter is not boolean?');
            }
        })(expr);
    }

    _adjust() {
        let newfilter = [];

        return promiseDoAll(this._relevantPermissions, (permission) => this._isPermissionApplicable(permission).then((isApplicable) => {
            if (!isApplicable) {
                //console.log('Not applicable');
                return Promise.resolve();
            }

            let querypredicate;

            return this._isFilterImplied(permission, permission.query, (reduction) => {
                reduction.addAssert(smt.Not(reduction.getFilterName(permission.query.filter)));
            }).then((isQueryValid) => {
                //console.log('isQueryValid ' + isQueryValid);
                if (isQueryValid) {
                    querypredicate = Ast.BooleanExpression.True;
                    return;
                }

                let inParamMap = {};
                if (this._newrule.stream) {
                    for (let [,in_param,,] of this._newrule.stream.iterateSlots({})) {
                        if (!(in_param instanceof Ast.InputParam))
                            continue;
                        if (in_param.name in inParamMap)
                            inParamMap[in_param.name] = undefined;
                        else
                            inParamMap[in_param.name] = in_param.value;
                    }
                } else if (this._newrule.table) {
                    for (let [,in_param,,] of this._newrule.table.iterateSlots({})) {
                        if (!(in_param instanceof Ast.InputParam))
                            continue;
                        if (in_param.name in inParamMap)
                            inParamMap[in_param.name] = undefined;
                        else
                            inParamMap[in_param.name] = in_param.value;
                    }
                } else {
                    throw new Error('how did we get here?');
                }

                querypredicate = this._partiallyEvalFilter(permission.query.filter, inParamMap, {});
            }).then(() => this._isFilterImplied(permission, permission.action, (reduction) => {
                if (permission.query.isSpecified)
                    reduction.addAssert(reduction.getFilterName(permission.query.filter));
                reduction.addAssert(smt.Not(reduction.getFilterName(permission.action.filter)));
            })).then((isActionValid) => {
                //console.log('isActionValid ' + isActionValid);
                if (isActionValid)
                    return;

                for (let action of this._rule.actions) {
                    let inParamMap = {};
                    for (let inParam of action.in_params)
                        inParamMap[inParam.name] = inParam.value;

                    let previousPrimitiveDef = this._rule.stream ? this._rule.stream.schema : this._rule.table.schema;
                    querypredicate = Ast.BooleanExpression.And([
                        querypredicate, this._partiallyEvalFilter(permission.action.filter, inParamMap, previousPrimitiveDef.out)]);
                }
            }).then(() => {
                newfilter.push(querypredicate);
            });
        })).then(() => {
            let queryfilter = Ast.BooleanExpression.Or(newfilter).optimize();
            if (queryfilter.isFalse)
                return null;
            if (this._newrule.stream)
                this._newrule.stream = new Ast.Stream.Filter(this._newrule.stream, queryfilter, this._newrule.stream.schema);
            else if (this._newrule.table)
                this._newrule.table = new Ast.Table.Filter(this._newrule.table, queryfilter, this._newrule.table.schema);
            else if (!queryfilter.isTrue)
                return null;

            return this._newrule;
        });
    }

    transform() {
        if (this._relevantPermissions.length === 0)
            return Promise.resolve(null);
        return Promise.resolve().then(() => {
            let satReduction = new SmtReduction(this._SolverClass);
            this._addAllGroups(satReduction);
            this._addProgram(satReduction);
            return satReduction.checkSatisfiable();
        }).then((isSatisfiable) => {
            if (!isSatisfiable) {
                //console.log('Rule not satifisiable');
                //console.log(Ast.prettyprint(this._program, true));
                return null;
            }

            this._firstReduction = new SmtReduction(this._SolverClass);
            this._addAllGroups(this._firstReduction);
            this._addProgram(this._firstReduction);
            let ors = [];
            for (let permission of this._relevantPermissions)
                ors.push(this._firstReduction.addPermission(permission));
            this._firstReduction.addAssert(smt.Not(smt.Or(...ors)));
            return this._firstReduction.checkSatisfiable(true).then((isSatisfiable) => {
                if (!isSatisfiable)
                    return this._rule.clone();

                this._secondReduction = new SmtReduction(this._SolverClass);
                this._addAllGroups(this._secondReduction);
                this._addProgram(this._secondReduction);
                let ors = [];
                for (let permission of this._relevantPermissions)
                    ors.push(this._secondReduction.addPermission(permission));
                this._secondReduction.addAssert(smt.Or(...ors));
                return this._secondReduction.checkSatisfiable(true).then((isSatisfiable) => {
                    if (!isSatisfiable)
                        return null;

                    this._newrule = this._rule.clone();
                    return this._adjust();
                });
            });
        });
    }
}

module.exports = class PermissionChecker {
    constructor(SolverClass, schemaRetriever, groupDelegate) {
        this._SolverClass = SolverClass;
        this._schemaRetriever = schemaRetriever;
        this._groupDelegate = groupDelegate;
        this._permissiondb = new Set;
        this._principals = new Set;

        this._principal = null;
        // maps a principal to its array of groups, as returned by the group delegate
        this._groupmap = new Map;
        this._program = null;

        this._newprogram = null;
    }

    _collectPrincipals(program, into) {
        for (let [, slot,,] of program.iterateSlots()) {
            if (slot instanceof Ast.Selector) {
                if (slot.isDevice && slot.principal && slot.principal.isEntity)
                    into.add(slot.principal.value);
            } else if (slot.value.isEntity && slot.value.type === 'tt:contact') {
-               into.add(slot.value.value);
            }
        }
    }

    _setProgram(principal, program) {
        this._principal = principal;
        return program.typecheck(this._schemaRetriever).then(() => {
            this._program = program;

            this._principals.add(principal.value);
            let programPrincipals = new Set(this._principals);
            this._collectPrincipals(program, programPrincipals);

            return Promise.all(Array.from(programPrincipals).map((principal) => this._groupDelegate.getGroups(principal).then((groups) => {
                this._groupmap.set(principal, groups);
            })));
        });
    }

    check(principal, program) {
        return this._setProgram(principal, program).then(() => {
            let newrules = [];
            return promiseDoAll(program.rules, (rule) => {
                let transformer = new RuleTransformer(this._SolverClass, principal, program, rule, this._permissiondb, this._groupmap);
                return transformer.transform().then((newrule) => {
                    if (newrule !== null)
                        newrules.push(newrule);
                });
            }).then(() => {
                if (newrules.length === 0)
                    return null;
                return (new Ast.Program(program.classes, program.declarations, newrules, null)).optimize();
            });
        });
    }

    allowed(permissionRule) {
        return permissionRule.typecheck(this._schemaRetriever).then(() => {
            this._permissiondb.add(permissionRule);
            this._collectPrincipals(permissionRule, this._principals);
        });
    }

    disallowed(permissionRule) {
        this._permissiondb.delete(permissionRule);
    }
};
},{"./ast":44,"./builtin":46,"./type":65,"assert":8,"smtlib":38}],62:[function(require,module,exports){
// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2015-2016 The Board of Trustees of the Leland Stanford Junior University
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
//
// See COPYING for details
"use strict";

const { stringEscape } = require('./escaping');

function prettyprintType(ast) {
    if (ast.isTuple)
        return '(' + ast.schema.map(prettyprintType).join(', ') + ')';
    else if (ast.isArray)
        return 'Array(' + prettyprintType(ast.elem) + ')';
    else
        return ast.toString();
}

function prettyprintLocation(ast) {
    if (ast.isAbsolute && ast.display)
        return 'makeLocation(' + ast.lat + ', ' + ast.lon + ', ' + stringEscape(ast.display) + ')';
    else if (ast.isAbsolute)
        return 'makeLocation(' + ast.lat + ', ' + ast.lon + ')';
    else
        return '$context.location.' + ast.relativeTag;
}

function prettyprintDate(value, operator, offset) {
    let base;
    if (value === null)
        base = 'makeDate()';
    else if (value.isDateEdge)
        base = `${value.edge}(${value.unit})`;
    else
        base = `makeDate(${value.getTime()})`;
    return base + (offset ? ` ${operator} ${prettyprintValue(offset)}` : '');
}

function prettyprintValue(ast) {
    if (ast.isVarRef)
        return ast.name;
    else if (ast.isUndefined)
        return '$undefined' + (ast.local ? '' : '.remote');
    else if (ast.isArray)
        return `[${ast.value.map(prettyprintValue).join(', ')}]`;
    else if (ast.isBoolean)
        return String(ast.value);
    else if (ast.isString)
        return stringEscape(ast.value);
    else if (ast.isEnum)
        return `enum(${ast.value})`;
    else if (ast.isMeasure)
        return String(ast.value) + ast.unit;
    else if (ast.isCompoundMeasure && ast.value.length > 1)
        return `(${ast.value.map(prettyprintValue).join(' + ')})`;
    else if (ast.isCompoundMeasure)
        return prettyprintValue(ast.value[0]);
    else if (ast.isNumber)
        return String(ast.value);
    else if (ast.isCurrency)
        return `makeCurrency(${ast.value}, ${ast.code})`;
    else if (ast.isLocation)
        return prettyprintLocation(ast.value);
    else if (ast.isDate)
        return prettyprintDate(ast.value, ast.operator, ast.offset);
    else if (ast.isTime)
        return `makeTime(${ast.hour}, ${ast.minute})`;
    else if (ast.isEntity)
        return (ast.value !== null ? stringEscape(ast.value) : 'null') + '^^' + ast.type + (ast.display ? '(' + stringEscape(ast.display) + ')' : '');
    else if (ast.isEvent)
        return '$event' + (ast.name ? '.' + ast.name : '');
    else
        throw new TypeError('Invalid value type ' + ast); // the other Value forms don't have literals
}

function prettyprintSelector(ast) {
    if (ast.isBuiltin)
        return '';

    if (ast.id)
        return `@${ast.kind}(id=${stringEscape(ast.id)})`;
    return `@${ast.kind}`;
}

function prettyprintInputParam(ast) {
    return ast.name + '=' + prettyprintValue(ast.value);
}

const INFIX_FILTERS = new Set(['>=', '<=', '>', '<', '=~', '~=', '==']);

function prettyprintExternalFilter(ast) {
    return `${prettyprintSelector(ast.selector)}.${ast.channel}(${ast.in_params.map(prettyprintInputParam).join(', ')}) { ${prettyprintFilterExpression(ast.filter)} }`;
}

function prettyprintFilterExpression(ast) {
    if (ast.isTrue || (ast.isAnd && ast.operands.length === 0))
        return 'true';
    if (ast.isFalse || (ast.isOr && ast.operands.length === 0))
        return 'false';
    if (ast.isNot)
        return `!(${prettyprintFilterExpression(ast.expr)})`;
    if (ast.isAnd)
        return `(${ast.operands.map(prettyprintFilterExpression).join(' && ')})`;
    if (ast.isOr)
        return `(${ast.operands.map(prettyprintFilterExpression).join(' || ')})`;
    if (ast.isExternal)
        return prettyprintExternalFilter(ast);

    if (INFIX_FILTERS.has(ast.operator))
        return `${ast.name} ${ast.operator} ${prettyprintValue(ast.value)}`;

    return `${ast.operator}(${ast.name}, ${prettyprintValue(ast.value)})`;
}

function prettyprintInvocation(ast) {
    if (!ast.selector)
        throw new Error('Invalid invocation ' + ast);
    if (ast.selector.isBuiltin)
        return ast.channel;
    return `${prettyprintSelector(ast.selector)}.${ast.channel}(${ast.in_params.map(prettyprintInputParam).join(', ')})`;
}

function prettyprintActionList(actions) {
    if (actions.length === 1)
        return prettyprintInvocation(actions[0]);
    else
        return `{\n${actions.map((a) => '        ' + prettyprintInvocation(a) + ';\n').join('')} }`;
}

function prettyprintRule(ast) {
    if (ast.isRule)
        return `    ${prettyprintStream(ast.stream)} => ${prettyprintActionList(ast.actions)};\n`;
    else if (ast.table === null)
        return `    now => ${prettyprintActionList(ast.actions)};\n`;
    else
        return `    now => ${prettyprintTable(ast.table)} => ${prettyprintActionList(ast.actions)};\n`;
}

const INFIX_OPERATORS = new Set(['+', '-', '/', '*', '%', '**']);
function prettyprintScalarExpression(expr) {
    if (expr.isPrimary)
        return prettyprintValue(expr.value);
    else if (expr.isDerived && INFIX_OPERATORS.has(expr.op))
        return `(${prettyprintScalarExpression(expr.operands[0])} ${expr.op} ${prettyprintScalarExpression(expr.operands[1])})`;
    else if (expr.isDerived)
        return `${expr.op}(${expr.operands.map(prettyprintScalarExpression).join(', ')})`;
    else
        throw new TypeError();
}

function prettyprintVarRef(ast) {
    return `${ast.name}(${ast.in_params.map(prettyprintInputParam).join(', ')})`;
}

function prettyprintTable(table) {
    if (table.isVarRef)
        return prettyprintVarRef(table);
    else if (table.isInvocation)
        return prettyprintInvocation(table.invocation);
    else if (table.isFilter)
        return `(${prettyprintTable(table.table)}), ${prettyprintFilterExpression(table.filter)}`;
    else if (table.isProjection)
        return `[${table.args.join(', ')}] of (${prettyprintTable(table.table)})`;
    else if (table.isAlias)
        return `(${prettyprintTable(table.table)}) as ${table.name}`;
    else if (table.isCompute)
        return `compute ${prettyprintScalarExpression(table.expression)} ${table.alias !== null ? `as ${table.alias} ` : ''}of (${prettyprintTable(table.table)})`; //` <- GtkSourceView bug
    else if (table.isAggregation && table.operator === 'count' && table.field === '*')
        return `aggregate count ${table.alias !== null ? `as ${table.alias} ` : ''}of ${prettyprintTable(table.table)}`; //` <- GtkSourceView bug
    else if (table.isAggregation)
        return `aggregate ${table.operator} ${table.field} ${table.alias !== null ? `as ${table.alias} ` : ''}of ${prettyprintTable(table.table)}`; //` <- GtkSourceView bug
    else if (table.isArgMinMax)
        return `aggregate ${table.operator} ${prettyprintValue(table.base)}, ${prettyprintValue(table.limit)} ${table.field} of ${prettyprintTable(table.table)}`;
    else if (table.isJoin && table.in_params.length > 0)
        return `(${prettyprintTable(table.lhs)} join ${prettyprintTable(table.rhs)} on (${table.in_params.map(prettyprintInputParam).join(', ')}))`;
    else if (table.isJoin)
        return `(${prettyprintTable(table.lhs)} join ${prettyprintTable(table.rhs)})`;
    else if (table.isWindow)
        return `window ${prettyprintValue(table.base)}, ${prettyprintValue(table.delta)} of ${prettyprintStream(table.stream)}`;
    else if (table.isTimeSeries)
        return `timeseries ${prettyprintValue(table.base)}, ${prettyprintValue(table.delta)} of ${prettyprintStream(table.stream)}`;
    else if (table.isSequence)
        return `sequence ${prettyprintValue(table.base)}, ${prettyprintValue(table.delta)} of ${prettyprintTable(table.table)}`;
    else if (table.isHistory)
        return `history ${prettyprintValue(table.base)}, ${prettyprintValue(table.delta)} of ${prettyprintTable(table.table)}`;
    else
        throw new TypeError();
}

function prettyprintStream(stream) {
    if (stream.isVarRef)
        return prettyprintVarRef(stream);
    else if (stream.isTimer)
        return `timer(base=${prettyprintValue(stream.base)}, interval=${prettyprintValue(stream.interval)})`;
    else if (stream.isAtTimer)
        return `attimer(time=${prettyprintValue(stream.time)})`;
    else if (stream.isMonitor)
        return `monitor (${prettyprintTable(stream.table)})` + ((stream.args && stream.args.length) ? ` on new [${stream.args.join(', ')}]` : '');
    else if (stream.isEdgeNew)
        return `edge (${prettyprintStream(stream.stream)}) on new`;
    else if (stream.isEdgeFilter)
        return `edge (${prettyprintStream(stream.stream)}) on ${prettyprintFilterExpression(stream.filter)}`;
    else if (stream.isFilter)
        return `${prettyprintStream(stream.stream)}, ${prettyprintFilterExpression(stream.filter)}`;
    else if (stream.isProjection)
        return `[${stream.args.join(', ')}] of (${prettyprintStream(stream.stream)})`;
    else if (stream.isCompute)
        return `compute ${prettyprintScalarExpression(stream.expression)} ${stream.alias !== null ? `as ${stream.alias} ` : ''}of (${prettyprintStream(stream.stream)})`; //` <- GtkSourceView bug
    else if (stream.isAlias)
        return `(${prettyprintStream(stream.stream)}) as ${stream.name}`;
    else if (stream.isJoin && stream.in_params.length > 0)
        return `(${prettyprintStream(stream.stream)} join ${prettyprintTable(stream.table)} on (${stream.in_params.map(prettyprintInputParam).join(', ')}))`;
    else if (stream.isJoin)
        return `(${prettyprintStream(stream.stream)} join ${prettyprintTable(stream.table)})`;
    else
        throw new TypeError();
}

function prettyprintDeclaration(decl) {
    let args = Object.keys(decl.args);
    let types = args.map((a) => decl.args[a]);

    let arg_decl = args.length > 0 ? `\\(${args.map((a, i) => a + ' :' + prettyprintType(types[i])).join(', ')}) -> ` : '';

    let value;
    switch (decl.type) {
    case 'stream':
        value = prettyprintStream(decl.value);
        break;
    case 'table':
        value = prettyprintTable(decl.value);
        break;
    case 'action':
        value = prettyprintInvocation(decl.value);
        break;
    default:
        throw new TypeError();
    }

    return `    let ${decl.type} ${decl.name} := ${arg_decl}${value};\n`;
}

function prettyprintArgDef(fndef, argname) {
    if (fndef.inReq[argname])
        return 'in req ' + argname + ' : ' + fndef.inReq[argname];
    else if (fndef.inOpt[argname])
        return 'in opt ' + argname + ' : ' + fndef.inOpt[argname];
    else
        return 'out ' + argname + ' : ' + fndef.out[argname];
}

function prettyprintFunctionDef(prefix, ast) {
    return function(name) {
        return '        ' + prefix + ' ' + name + ' (' + ast[name].args.map((argname) => prettyprintArgDef(ast[name], argname)).join(', ') + ');\n';
    };
}

function prettyprintClassDef(ast) {
    return '    class @' + ast.name + ' extends @' + ast.extends + ' {\n' +
        Object.keys(ast.queries).map(prettyprintFunctionDef('query', ast.queries)) +
        Object.keys(ast.actions).map(prettyprintFunctionDef('action', ast.actions)) + '    }\n';
}

function prettyprintProgram(ast, short) {
    let prefix;
    if (ast.principal !== null)
        prefix = 'executor = ' + prettyprintValue(ast.principal) + ' : ';
    else
        prefix = '';

    if (short && ast.classes.length === 0 && ast.declarations.length === 0 && ast.rules.length === 1)
        return prefix + prettyprintRule(ast.rules[0]).trim();
    if (short && ast.classes.length === 0 && ast.declarations.length === 1 && ast.rules.length === 0)
        return prefix + prettyprintDeclaration(ast.declarations[0]).trim();

    return prefix + '{\n' +
            ast.classes.map(prettyprintClassDef).join('') +
            ast.declarations.map(prettyprintDeclaration).join('') +
            ast.rules.map(prettyprintRule).join('') + '}';
}

function prettyprint(ast, short) {
    if (ast.isProgram)
        return prettyprintProgram(ast, short);
    else
        return prettyprintPermissionRule(ast, short);
}

function prettyprintPermissionFunction(fn) {
    if (fn.isStar)
        return '*';
    if (fn.isClassStar)
        return `@${fn.kind}.*`;

    if (fn.filter.isTrue)
        return `@${fn.kind}.${fn.channel}`;
    else
        return `@${fn.kind}.${fn.channel}, ${prettyprintFilterExpression(fn.filter)}`;
}

function prettyprintPermissionRule(allowed) {
    return `${prettyprintFilterExpression(allowed.principal)} : ${allowed.query.isBuiltin ? 'now' : prettyprintPermissionFunction(allowed.query)} => ${allowed.action.isBuiltin ? 'notify' : prettyprintPermissionFunction(allowed.action)};`;
}

module.exports = {
    prettyprint
};

},{"./escaping":51}],63:[function(require,module,exports){
// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2015 The Board of Trustees of the Leland Stanford Junior University
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
//
// See COPYING for details
"use strict";

const Type = require('./type');

class DummyMemoryClient {
    constructor() {
        this._tables = new Map;
    }

    getSchema(table) {
        return Promise.resolve(this._tables.get(table) || null);
    }

    createTable(table, args, types) {
        this._tables.set(table, { args: args, types: types });
        return Promise.resolve();
    }
}

module.exports = class SchemaRetriever {
    constructor(tpClient, mClient, silent) {
        this._schemaRequest = null;
        this._pendingSchemaRequests = [];
        this._metaRequest = null;
        this._pendingMetaRequests = [];
        this._cache = new Map;
        this._metaCache = new Map;
        this._manifestCache = new Map;

        this._thingpediaClient = tpClient;
        this._memoryClient = mClient || new DummyMemoryClient();
        this._silent = !!silent;
    }

    removeFromCache(kind) {
        this._cache.delete(kind);
        this._metaCache.delete(kind);
        this._manifestCache.delete(kind);
    }
    clearCache() {
        this._cache.clear();
        this._metaCache.clear();
        this._manifestCache.clear();
    }

    injectManifest(kind, manifest) {
        let schema = {};
        for (let what of ['queries', 'actions']) {
            schema[what] = {};
            for (let name in manifest[what]) {
                let block = manifest[what][name];
                let ret = {
                    kind_type: 'primary',
                    args: [],
                    types: [],
                    is_input: [],
                    required: [],
                    is_list: !!block.is_list,
                    is_monitorable: ('poll_interval' in block ?
                        block.poll_interval >= 0 : !!block.is_monitorable)
                };
                for (let arg of block.args) {
                    ret.args.push(arg.name);
                    ret.types.push(Type.fromString(arg.type));
                    ret.is_input.push(arg.is_input);
                    ret.required.push(arg.required);
                }
                schema[what][name] = ret;
            }
        }
        this._cache.set(kind, schema);
        this._manifestCache.set(kind, manifest);
    }

    _getManifest(kind) {
        if (this._manifestCache.has(kind))
            return Promise.resolve(this._manifestCache.get(kind));

        let request = this._thingpediaClient.getDeviceCode(kind);
        this._manifestCache.set(kind, request);
        return request;
    }

    getFormatMetadata(kind, query) {
        return this._getManifest(kind).then((manifest) => {
            if (manifest.queries[query])
                return manifest.queries[query].formatted;
            else
                throw new TypeError('Cannot find query ' + query + ' in manifest of ' + kind);
        });
    }

    _ensureSchemaRequest() {
        if (this._schemaRequest !== null)
            return;

        this._schemaRequest = Promise.resolve().then(() => {
            var pending = this._pendingSchemaRequests;
            this._pendingSchemaRequests = [];
            this._schemaRequest = null;
            if (pending.length === 0)
                return {};
            if (!this._silent)
                console.log('Batched schema request for ' + pending);
            return this._thingpediaClient.getSchemas(pending, 2);
        }).then((resolved) => {
            for (var kind in resolved) {
                try {
                    this._parseSchemaTypes(resolved[kind], resolved[kind].triggers);
                    this._parseSchemaTypes(resolved[kind], resolved[kind].actions);
                    this._parseSchemaTypes(resolved[kind], resolved[kind].queries);
                    this._cache.set(kind, resolved[kind]);
                } catch(e) {
                    resolved[kind] = e;
                }
            }
            return resolved;
        });
    }

    _parseSchemaTypes(schema, channels) {
        for (var name in channels) {
            channels[name].kind_type = schema.kind_type;
            channels[name].types = channels[name].types.map(Type.fromString);
        }
    }

    _parseMetaTypes(schema, channels) {
        for (var name in channels) {
            channels[name].kind_type = schema.kind_type;
            channels[name].schema = channels[name].schema.map(Type.fromString);
            channels[name].types = channels[name].schema;
        }
    }

    getFullSchema(kind) {
        if (typeof kind !== 'string')
            throw new TypeError();
        if (this._cache.has(kind))
            return Promise.resolve(this._cache.get(kind));

        if (this._pendingSchemaRequests.indexOf(kind) < 0)
            this._pendingSchemaRequests.push(kind);
        this._ensureSchemaRequest();
        return this._schemaRequest.then((everything) => {
            if (kind in everything) {
                if (everything[kind] instanceof Error)
                    throw everything[kind];
                else
                    return everything[kind];
            } else {
                throw new TypeError('Invalid kind ' + kind);
            }
        });
    }

    _ensureMetaRequest() {
        if (this._metaRequest !== null)
            return;

        this._metaRequest = Promise.resolve().then(() => {
            var pending = this._pendingMetaRequests;
            this._pendingMetaRequests = [];
            this._metaRequest = null;
            if (!this._silent)
                console.log('Batched schema-meta request for ' + pending);
            return this._thingpediaClient.getMetas(pending);
        }).then((resolved) => {
            for (var kind in resolved) {
                try {
                    this._parseMetaTypes(resolved[kind], resolved[kind].triggers);
                    this._parseMetaTypes(resolved[kind], resolved[kind].actions);
                    this._parseMetaTypes(resolved[kind], resolved[kind].queries);
                    this._metaCache.set(kind, resolved[kind]);
                } catch(e) {
                    resolved[kind] = e;
                }
            }
            return resolved;
        });
    }

    _where(where) {
        switch (where) {
            case 'query': return 'queries';
            case 'action': return 'actions';
            case 'trigger': return 'triggers';
            default: return where;
        }
    }

    getFullMeta(kind) {
        if (typeof kind !== 'string')
            throw new TypeError();
        if (this._metaCache.has(kind))
            return Promise.resolve(this._metaCache.get(kind));

        if (this._pendingMetaRequests.indexOf(kind) < 0)
            this._pendingMetaRequests.push(kind);
        this._ensureMetaRequest();
        return this._metaRequest.then((everything) => {
            if (kind in everything) {
                if (everything[kind] instanceof Error)
                    throw everything[kind];
                else
                    return everything[kind];
            } else {
                throw new TypeError('Invalid kind ' + kind);
            }
        });
    }

    getSchema(kind, where, name) {
        where = this._where(where);
        return this.getFullSchema(kind).then((fullSchema) => {
            if (!(name in fullSchema[where]))
                throw new TypeError("Schema " + kind + " has no " + where + " " + name);
            return fullSchema[where][name].types;
        });
    }

    getSchemaAndNames(kind, where, name) {
        where = this._where(where);
        return this.getFullSchema(kind).then((fullSchema) => {
            if (!(name in fullSchema[where]))
                throw new TypeError("Schema " + kind + " has no " + where + " " + name);
            return fullSchema[where][name];
        });
    }

    getMeta(kind, where, name) {
        where = this._where(where);
        return this.getFullMeta(kind).then((fullSchema) => {
            if (!(name in fullSchema[where]))
                throw new TypeError("Schema " + kind + " has no " + where + " " + name);
            return fullSchema[where][name];
        });
    }

    getMemorySchema(table, getMeta = false) {
        return this._memoryClient.getSchema(table, null);
    }
};
},{"./type":65}],64:[function(require,module,exports){
// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2017 The Board of Trustees of the Leland Stanford Junior University
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
//
// See COPYING for details
"use strict";

// A ShiftReduce parser
// This is the runtime component of tools/generate_parser.js
// (and expects tables generated in the form of tools/generate_parser.js)

const EOF_TOKEN = '<<EOF>>';

function findExpected(actions, terminalIds) {
    let ret = [];
    for (let tokenId in actions) {
        for (let term in terminalIds) {
            if (terminalIds[term] === Number(tokenId)) {
                ret.push(term);
                break;
            }
        }
    }
    return ret;
}

module.exports = function(TERMINAL_IDS, RULE_NON_TERMINALS, ARITY, GOTO, PARSER_ACTION, SEMANTIC_ACTION) {
    return class ShiftReduceParser {
        constructor() {
        }

        get numRules() {
            return RULE_NON_TERMINALS.length;
        }

        _helper(sequence, applySemanticAction) {
            const iterator = sequence[Symbol.iterator]();

            let state = 0;
            let stack = [0];
            let results = [null];
            let output = [];
            let { done, value:nextToken } = iterator.next();

            for(;;) {
                if (done)
                    nextToken = EOF_TOKEN;
                let nextTokenId = TERMINAL_IDS[String(nextToken)];
                if (!(nextTokenId in PARSER_ACTION[state]))
                    throw new SyntaxError("Parse error: unexpected token " + nextToken + " in state " + state + ", expected " + findExpected(PARSER_ACTION[state], TERMINAL_IDS));
                let [action, param] = PARSER_ACTION[state][nextTokenId];

                if (action === 0) // accept
                    return [output, results[1]];

                if (action === 1) { // shift
                    state = param;
                    stack.push(state);
                    results.push(nextToken);
                    ({ done, value:nextToken } = iterator.next());
                } else { // reduce
                    let ruleId = param;
                    output.push(ruleId);
                    let arity = ARITY[ruleId];
                    let args = results.slice(results.length-arity, results.length);
                    stack.length -= arity;
                    results.length -= arity;
                    state = stack[stack.length-1];
                    let lhs = RULE_NON_TERMINALS[ruleId];
                    let nextState = GOTO[state][lhs];
                    state = nextState;
                    stack.push(nextState);
                    if (applySemanticAction) {
                        let action = SEMANTIC_ACTION[ruleId];
                        results.push(action(...args));
                    } else {
                        results.push(null);
                    }
                }
            }
        }

        parse(sequence) {
            let [, ast] = this._helper(sequence, true);
            return ast;
        }

        getReduceSequence(sequence) {
            let [reduces, ] = this._helper(sequence, false);
            return reduces;
        }
    };
};

},{}],65:[function(require,module,exports){
// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2015-2016 The Board of Trustees of the Leland Stanford Junior University
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
//
// See COPYING for details
"use strict";

const adt = require('adt');

const Grammar = require('./grammar');
const { normalizeUnit } = require('./units');

// strictly speaking, Measure and Arrays are not types, they are type constructors
// (kind * -> *)
// isAssignable() has the magic to check types
const Type = adt.data(function() {
    return {
        Any: null, // polymorphic hole
        Boolean: null,
        String: null,
        Number: null,
        Currency: null,
        Entity: { // a typed string (username, hashtag, url, picture...)
            type: adt.only(String), // the entity type, as RDF-style prefix:name
        },
        Measure: {
            // '' means any unit, creating a polymorphic type
            // any other value is a base unit (m for length, C for temperature)
            unit: normalizeUnit,
        },
        Enum: {
            entries: adt.only(Array, null) // of string
        },
        Array: {
            elem: adt.only(this, String),
        },
        Time: null,
        Date: null,
        Location: null,
        Tuple: {
            schema: adt.only(Array),
        },
        Table: null,
        Stream: null
    };
});

module.exports = Type;

module.exports.fromString = function(str) {
    if (str instanceof Type)
        return str;

    return Grammar.parse(str, { startRule: 'type_ref' });
};

function arrayEquals(a, b) {
    if (a === null && b === null)
        return true;
    if (a === null || b === null)
        return false;
    if (a.length !== b.length)
        return false;

    for (var i = 0; i < a.length; i++) {
        if (a[i] !== b[i])
            return false;
    }

    return true;
}

function entitySubType(type, assignableTo) {
    if (type === 'tt:username' || type === 'tt:contact_name') {
        return assignableTo === 'tt:phone_number' ||
            assignableTo === 'tt:email_address' ||
            assignableTo === 'tt:contact';
    }
    if (type === 'tt:contact_group_name')
        return assignableTo === 'tt:contact_group';
    if (type === 'tt:picture_url')
        return assignableTo === 'tt:url';
    return false;
}

module.exports.isAssignable = function isAssignable(type, assignableTo, typeScope = {}, lenient = false) {
    if (typeof assignableTo === 'string') {
        if (typeScope[assignableTo])
            return isAssignable(type, typeScope[assignableTo], typeScope, lenient);
        typeScope[assignableTo] = type;
        return true;
    }
    if (type.equals(assignableTo))
        return true;
    if (type.isAny || assignableTo.isAny)
        return true;
    if (type.isMeasure && assignableTo.isMeasure && assignableTo.unit !== '') {
        if (type.unit === assignableTo.unit)
            return true;
    }
    if (type.isMeasure && assignableTo.isMeasure && assignableTo.unit === '') {
        if (!typeScope['_unit']) {
            typeScope['_unit'] = type.unit;
            return true;
        }
        if (typeScope['_unit'] && typeScope['_unit'] === type.unit)
            return true;
    }
    if (type.isTuple && assignableTo.isTuple) {
        return type.schema.length === assignableTo.schema.length &&
            type.schema.every((t, i) => isAssignable(t, assignableTo.schema[i]));
    }
    if (type.isArray && assignableTo.isArray &&
        typeof assignableTo.elem === 'string') {
        if (typeScope[assignableTo.elem])
            return isAssignable(type.elem, typeScope[assignableTo.elem], typeScope, lenient);
        typeScope[assignableTo.elem] = type.elem;
        return true;
    }
    if (type.isArray && assignableTo.isEntity && assignableTo.type === 'tt:contact_group')
        return isAssignable(type.elem, Type.Entity('tt:contact'), typeScope, lenient);
    if (type.isDate && assignableTo.isTime)
        return true;
    if (type.isEntity && assignableTo.isString)
        return true;
    if (lenient && type.isString && assignableTo.isEntity) {
        //console.log('Using String for ' + assignableTo + ' is deprecated');
        return true;
    }
    if (type.isEnum && assignableTo.isEnum && type.entries === null)
        return true;
    if (type.isEnum && assignableTo.isEnum && arrayEquals(type.entries, assignableTo.entries))
        return true;
    if (type.isEntity && assignableTo.isEntity && entitySubType(type.type, assignableTo.type))
        return true;

    return false;
};

},{"./grammar":55,"./units":67,"adt":7}],66:[function(require,module,exports){
// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2015-2016 The Board of Trustees of the Leland Stanford Junior University
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
//
// See COPYING for details
"use strict";

const assert = require('assert');

const Ast = require('./ast');
const Type = require('./type');
const Utils = require('./utils');
const Builtin = require('./builtin');

const ALLOWED_PRINCIPAL_TYPES = new Set([
    'tt:contact', 'tt:username'
]);

function log(message) {
    let debug = false;
    if (debug) console.log(message);
}

class Scope {
    constructor(scope) {
        this._globalScope = scope ? Object.assign({}, scope._globalScope) : {};
        this._scope = scope? Object.assign({}, scope._scope) : {};
        this._conflicts = scope? new Set(scope._conflicts) : new Set();
        this.$has_event = scope? scope.$has_event : false;
        this._inReq = scope? Object.assign({}, scope._inReq) : {};
        this._lambda_args = scope? Object.assign({}, scope._lambda_args) : {};
    }

    has(name) {
        return name in this._scope;
    }

    hasGlobal(name) {
        return name in this._globalScope;
    }

    hasInReq() {
        return Object.keys(this._inReq).length > 0;
    }

    getSchema(name) {
        if (this.hasGlobal(name))
            return this._globalScope[name];
        return null;
    }

    add(name, type) {
        // HACK FIXME
        //if (this.has(name))
        //    this._conflicts.add(name);
        this._scope[name] = type;
    }

    addGlobal(name, schema) {
        if (this.hasGlobal(name))
            throw new TypeError('Conflict on using ' + name);
        this._globalScope[name] = schema.clone();
    }

    addConflict(name) {
        this._conflicts.add(name);
    }

    popInReq(name, type) {
        this._inReq[name] = type;
    }
    removeInReq(name) {
        delete this._inReq[name];
    }

    clearInReq() {
        this._inReq = {};
    }

    initLambdaArgs(args) {
        this.assign(args);
        for (let name in args)
            this._lambda_args[name] = [];
    }

    isLambdaArg(arg) {
        return arg in this._lambda_args;
    }

    updateLambdaArgs(arg, name) {
        this._lambda_args[arg].push(name);
    }

    remove(name) {
        if (this._conflicts.has(name))
            delete this._conflicts[name];
        delete this._scope[name];
    }

    assign(name_type_pairs) {
        for (let name in name_type_pairs) {
            let type = name_type_pairs[name];
            if (type.isTable || type.isStream)
                this.addGlobal(name, Builtin.emptyFunction);
            else if (type.isFunctionDef)
                this.addGlobal(name, type);
            else
                this.add(name, type);
        }
    }

    merge(scope) {
        for (let name in scope._globalScope)
            this.add(name, scope.get(name));
        for (let name in scope._scope)
            this.add(name, scope.get(name));
        Object.assign(this._inReq, scope._inReq);
    }

    clean(args) {
        this._scope = {};
        this._conflicts = new Set();
        this.$has_event = false;
        this._inReq = {};
        this._lambda_args = {};
        if (args)
            Object.keys(args).forEach((name) => delete this._globalScope[name]);
    }

    prefix(prefix) {
        let new_scope = {};
        for (let name in this._scope)
            new_scope[prefix + '.' + name] = this._scope[name];
        this._scope = new_scope;
    }

    get(name) {
        if (this._conflicts.has(name))
            throw new TypeError('Conflicted field name ' + name + ' after join, cannot be used.');
        return this._globalScope[name] || this._scope[name];
    }

    dump() {
        console.log();
        console.log('Scope:');
        for (let name in this._scope)
            console.log(name  +': ' + this._scope[name]);
    }
}

function ensureSchema(schemas, classes, prim, primType, useMeta) {
    if (prim.schema)
        return Promise.resolve();

    if (prim.isVarRef) {
        return Utils.getMemorySchema(schemas, prim.name, useMeta).then((schema) => {
            if (schema === null)
                throw new TypeError('Cannot find table ' + prim.name + ' in memory');
            prim.schema = schema;
        });
    }
    if (prim.selector.isBuiltin && primType === 'action') {
        if (prim.channel === 'notify')
            prim.schema = Builtin.Actions.notify;
        else if (prim.channel === 'return')
            prim.schema = Builtin.Actions['return'];
        else if (prim.channel === 'save')
            prim.schema = Builtin.Actions['save'];
        else
            throw new TypeError('Invalid builtin action ' + prim.channel);
        return Promise.resolve();
    }
    if (prim.selector.isBuiltin)
        throw new TypeError('Invalid builtin ' + primType + ' ' + prim.channel);

    return Utils.getSchemaForSelector(schemas, prim.selector.kind, prim.channel, primType, useMeta, classes).then((schema) => {
        prim.schema = schema;
    });
}

function typeForValue(value, scope) {
    if (value.isVarRef) {
        let type;
        if (value.name.startsWith('$context.location'))
            type = Type.Location;
         else
            type = scope.get(value.name);

        if (!type)
            throw new TypeError('Variable ' + value.name + ' is not in scope');
        return type;
    }
    if (value.isEvent && value.name !== 'program_id' && !scope.$has_event)
        throw new TypeError('Cannot access $event variables in the trigger');
    return value.getType();
}

function resolveTypeVars(type, typeScope) {
    if (type === 'string')
        return resolveTypeVars(typeScope[type], typeScope);
    if (type.isArray)
        return Type.Array(resolveTypeVars(type.elem, typeScope));
    if (type.isTuple)
        return Type.Tuple(type.schema.map((t) => resolveTypeVars(t, typeScope)));
    if (type.isMeasure && typeScope._unit)
        return Type.Measure(typeScope._unit);
    return type;
}


function typecheckPrincipal(principal) {
    assert(principal.isEntity);
    if (!ALLOWED_PRINCIPAL_TYPES.has(principal.type))
        throw new TypeError(`Invalid principal ${principal}, must be a contact or a group`);
}

function resolveScalarExpressionOps(type_lhs, operator, type_rhs) {
    let op = Builtin.ScalarExpressionOps[operator];
    if (!op)
        throw new TypeError('Invalid operator ' + operator);
    for (let overload of op.types) {
        let typeScope = {};
        if (!Type.isAssignable(type_lhs, overload[0], typeScope, true))
            continue;
        if (!Type.isAssignable(type_rhs, overload[1], typeScope, true))
            continue;

        if (overload[2].isMeasure && typeScope['_unit'])
            return Type.Measure(typeScope['_unit']);
        return overload[2];
    }
    throw new TypeError(`Invalid parameter types ${type_lhs} and ${type_rhs} for ${operator}`);
}

function resolveScalarExpression(ast, schema, scope, schemas, classes, useMeta) {
    log('Type check scalar expression');
    if (ast.isBoolean) {
        typeCheckFilter(ast.value, schema, scope, schemas, classes, useMeta);
        return Type.Boolean;
    }
    if (ast.isPrimary) {
        if (ast.value.isVarRef) {
            let name = ast.value.name;
            let paramType = schema.inReq[name] || schema.inOpt[name] || schema.out[name] || scope.get(name);
            if (!paramType)
                throw new TypeError('Invalid parameter ' + name);
            return paramType;
        }
        return typeForValue(ast.value, scope);
    }
    if (ast.isDerived) {
        let operands = ast.operands.map((o) => resolveScalarExpression(o, schema, scope, schemas, classes, useMeta));
        return resolveScalarExpressionOps(operands[0], ast.op, operands[1]);
    }
    throw new TypeError(`Invalid scalar expression`);
}

function resolveFilterOverload(type_lhs, operator, type_rhs) {
    log('resolve filter overload');
    let op = Builtin.BinaryOps[operator];
    if (!op)
        throw new TypeError('Invalid operator ' + operator);
    if (type_lhs.isEntity && operator === '=~') {
        // using isAssignable will accept the operator (because it casts everything to String)
        // but we don't want that
        throw new TypeError(`Invalid parameter types ${type_lhs} and ${type_rhs} for ${operator}`);
    }
    for (let overload of op.types) {
        let typeScope = {};
        if (!Type.isAssignable(type_lhs, overload[0], typeScope, true))
            continue;
        if (!Type.isAssignable(type_rhs, overload[1], typeScope, true))
            continue;
        if (!Type.isAssignable(overload[2], Type.Boolean, typeScope, true))
            continue;
        return overload;
    }
    throw new TypeError(`Invalid parameter types ${type_lhs} and ${type_rhs} for ${operator}`);
}

function typeCheckFilter(ast, schema, scope, schemas, classes, useMeta) {
    log('Type check filter ...');
    return (function recursiveHelper(ast) {
        if (!ast)
            return Promise.resolve();
        if (ast.isTrue || ast.isFalse)
            return Promise.resolve();
        if (ast.isAnd || ast.isOr)
            return Promise.all(ast.operands.map((op) => recursiveHelper(op)));
        if (ast.isNot)
            return recursiveHelper(ast.expr);

        if (ast.isAtom) {
            let name = ast.name;
            let type_lhs = undefined;
            if (schema)
                type_lhs = schema.inReq[name] || schema.inOpt[name] || schema.out[name];
            if (!type_lhs)
                type_lhs = scope.get(name);
            if (!type_lhs)
                throw new TypeError('Invalid filter parameter ' + name);
            let type_rhs = typeForValue(ast.value, scope);
            ast.overload = resolveFilterOverload(type_lhs, ast.operator, type_rhs);
            if (ast.value.isVarRef && scope.isLambdaArg(ast.value.name))
                scope.updateLambdaArgs(ast.value.name, ast.name);

            return Promise.resolve();
        } else {
            assert(ast.isExternal);
            return ensureSchema(schemas, classes, ast, 'query', useMeta).then(() => {
                typeCheckInputArgs(ast, scope, classes);
                return typeCheckFilter(ast.filter, ast.schema, scope, schemas, classes, useMeta);
            });
        }
    })(ast);
}

function resolveAggregationOverload(ast, operator, field, schema) {
    let fieldType = schema.out[field];
    if (!fieldType)
        throw new TypeError('Invalid aggregation field ' + field);
    let ag = Builtin.Aggregations[operator];
    if (!ag)
        throw new TypeError('Invalid aggregation ' + operator);

    for (let overload of ag.types) {
        let typeScope = {};
        if (!Type.isAssignable(fieldType, overload[0], typeScope, true))
            continue;

        ast.overload = overload.map((t) => resolveTypeVars(t, typeScope));
        return ast.overload[1];
    }

    throw new TypeError('Invalid field type ' + fieldType + ' for ' + operator);
}

function cleanOutput(schema, scope) {
    let num_input = Object.keys(schema.inReq).length + Object.keys(schema.inOpt).length;
    schema.args = schema.args.slice(0, num_input);
    schema.types = schema.types.slice(0, num_input);
    for (let p in schema.index) {
        if (schema.index[p] >= num_input)
            delete schema.index[p];
    }
    for (let p in schema.out)
        scope.remove(p);

    schema.out = {};
}

function addOutput(schema, name, type, scope) {
    schema.args.push(name);
    schema.types.push(type);
    schema.index[name] = Object.keys(schema.index).length;
    schema.out[name] = type;
    scope.add(name, type);
}

function addInput(schema, name, type, required) {
    let num_input = Object.keys(schema.inReq).length + Object.keys(schema.inOpt).length;
    schema.args.splice(num_input, 0, name);
    schema.types.splice(num_input, 0, type);
    schema.index[name] = num_input;
    for (let p in schema.index) {
        if (p in schema.out)
            schema.index[p] = schema.index[p] + 1;
    }
    if (required)
        schema.inReq[name] = type;
    else
        schema.inOpt[name] = type;
}

function pushInReq(schema, scope) {
    if (scope.hasInReq()) {
        for (let name in scope._inReq)
            addInput(schema, name, scope._inReq[name], true);

        scope.clearInReq();
    }
}

function updateLambdaArgs(schema, scope, types) {
    for (let new_name in scope._lambda_args) {
        scope._lambda_args[new_name].forEach((old_name) => {
            if (new_name === old_name)
                return;
            schema.args[schema.index[old_name]] = new_name;
            schema.index[new_name] = schema.index[old_name];
            schema.inReq[new_name] = types[new_name];
            delete schema.index[old_name];
            delete schema.inReq[old_name];
            delete schema.inOpt[old_name];
        });
    }
}

function typeCheckAggregation(ast, scope) {
    let name, type;
    if (ast.field === '*') {
        if (ast.operator !== 'count')
            throw new TypeError('* is not a valid argument to ' + ast.operator);
        type = Type.Number;
        ast.overload = [Type.Any, type];
        name = ast.alias ? ast.alias : 'count';
    } else {
        type = resolveAggregationOverload(ast, ast.operator, ast.field, ast.schema);
        name = ast.alias ? ast.alias : ast.operator;
    }
    cleanOutput(ast.schema, scope);
    addOutput(ast.schema, name, type, scope);
    return Promise.resolve();
}

function typeCheckArgMinMax(ast) {
    let argm = Builtin.ArgMinMax[ast.operator];
    if (!argm)
        throw new TypeError('Invalid aggregation ' + ast.operator);
    let fieldType = ast.schema.out[ast.field];
    if (!fieldType)
        throw new TypeError('Invalid field ' + ast.field);

    if (Builtin.ArgMinMax[ast.operator].types.every((t) => !Type.isAssignable(fieldType, t)))
        throw new TypeError('Invalid ' + ast.operator + ' field ' + ast.field);
    if (!ast.base.isNumber || !ast.limit.isNumber)
        throw new TypeError('Invalid range for ' + ast.operator);
    return Promise.resolve();
}

function typeCheckComputation(ast, scope, schemas, classes, useMeta) {
    let name = ast.alias ? ast.alias : 'result';
    let type = resolveScalarExpression(ast.expression, ast.table.schema, scope, schemas, classes, useMeta);
    cleanOutput(ast.schema, scope);
    addOutput(ast.schema, name, type, scope);
    return Promise.resolve();
}

function typeCheckMonitor(ast) {
    if (ast.args) {
        ast.args.forEach((arg) => {
            if (!(arg in ast.schema.out))
                throw new TypeError('Invalid field name ' + arg);
        });
    }
    return Promise.resolve();
}

function resolveProjection(args, schema, scope) {
    args.forEach((arg) => {
        if (schema.args.indexOf(arg) === -1)
            throw new TypeError('Invalid field name ' + arg);
    });
    schema.args = args;
    schema.types = schema.args.map((arg) => schema.types[schema.index[arg]]);
    schema.index = schema.args.reduce((res, arg, i) => {
        res[arg] = i;
        return res;
    }, {});
    Object.keys(schema.out).forEach((arg) => {
        if (schema.args.indexOf(arg) === -1) {
            delete schema.out[arg];
            scope.remove(arg);
        }
    });
}

function resolveJoin(ast, lhs, rhs) {
    ast.schema = lhs.schema.clone();
    ast.schema.args = ast.schema.args.concat(rhs.schema.args);
    ast.schema.types = ast.schema.types.concat(rhs.schema.types);
    ast.schema.index = rhs.schema.args.reduce((res, arg) => {
        res[arg] = Object.keys(res).length;
        return res;
    }, lhs.schema.index);
    ast.schema.inReq = Object.assign({}, lhs.schema.inReq);
    ast.schema.inOpt = Object.assign({}, lhs.schema.inOpt);
    let in_params = Object.assign({}, ast.schema.inReq, ast.schema.inOpt);
    for (let p in rhs.schema.inReq) {
        if (p in in_params) {
            delete ast.schema.inReq[p];
            delete ast.schema.inOpt[p];
        } else {
            ast.schema.inReq[p] = rhs.schema.inReq[p];
        }
    }
    for (let p in rhs.schema.inOpt) {
        if (p in in_params) {
            delete ast.schema.inReq[p];
            delete ast.schema.inOpt[p];
        } else {
            ast.schema.inOpt[p] = rhs.schema.inOpt[p];
        }
    }
    ast.schema.out = Object.assign(ast.schema.out, rhs.schema.out);
}

function typeCheckInputArgs(ast, scope, classes, isDeclaration = false) {
    let schema = ast.schema;
    if (isDeclaration)
        pushInReq(schema, scope);
    if (!ast.isVarRef && !ast.isJoin) {
        if (ast.selector.kind in classes)
            ast.__effectiveSelector = Ast.Selector.Device(classes[ast.selector.kind].extends, ast.selector.id, ast.selector.principal);
        else
            ast.__effectiveSelector = ast.selector;
    }
    var presentParams = new Set;
    for (let inParam of ast.in_params) {
        let inParamType = schema.inReq[inParam.name] || schema.inOpt[inParam.name];
        if (!inParamType)
            throw new TypeError('Invalid input parameter ' + inParam.name);
        if (inParam.value.isEntity && inParam.value.type === 'tt:username' &&
            inParamType.isEntity && (inParamType.type === 'tt:phone_number' || inParamType.type === 'tt:email_address'))
            inParam.value.type = 'tt:contact_name';
        if (!Type.isAssignable(typeForValue(inParam.value, scope), inParamType, {}, true))
            throw new TypeError('Invalid type for parameter '+ inParam.name);
        if (presentParams.has(inParam.name))
            throw new TypeError('Duplicate input param ' + inParam.name);
        presentParams.add(inParam.name);
        if (inParam.value.isVarRef && scope.isLambdaArg(inParam.value.name))
            scope.updateLambdaArgs(inParam.value.name, inParam.name);
    }
    for (let inParam in schema.inReq) {
        if (!presentParams.has(inParam))
            scope.popInReq(inParam, schema.inReq[inParam]);
    }
}

function typeCheckInput(ast, schemas, scope, classes, useMeta = false, isDeclaration = false) {
    return ensureSchema(schemas, classes, ast, 'query', useMeta).then(() => {
        typeCheckInputArgs(ast, scope, classes, isDeclaration);
        return typeCheckFilter(ast.filter, ast.schema, scope, schemas, classes, useMeta);
    }).then(() => {
        if (ast.aggregation)
            return typeCheckAggregation(ast, scope);
        scope.assign(ast.schema.out);
        return Promise.resolve();
    });
}

function typeCheckOutput(ast, schemas, scope, classes, useMeta = false, isDeclaration = false) {
    log('Type check output ...');
    return ensureSchema(schemas, classes, ast, 'action', useMeta).then(() => {
        return typeCheckInputArgs(ast, scope, classes, isDeclaration);
    });
}

function typeCheckJoinInput(ast, schemas, scope, classes, useMeta) {
    typeCheckInputArgs(ast, scope, classes);
    return Promise.resolve(typeCheckFilter(ast.filter, ast.schema, scope, schemas, classes, useMeta)).then(() => {
        if (ast.aggregation)
            return typeCheckAggregation(ast, scope);
        scope.assign(ast.schema.out);
        return Promise.resolve();
    });
}

function typeCheckTable(ast, schemas, scope, classes, useMeta = false, isDeclaration = false) {
    log('Type check table ...');
    if (ast.isVarRef) {
        log('VarRef');
        if (scope.hasGlobal(ast.name))
            ast.schema = scope.getSchema(ast.name).clone();

        return ensureSchema(schemas, classes, ast, 'query', useMeta).then(() => {
            return typeCheckInput(ast, schemas, scope, classes, useMeta, isDeclaration);
        });
    }
    if (ast.isInvocation) {
        log('Invocation');
        return ensureSchema(schemas, classes, ast.invocation, 'query', useMeta).then(() => {
            ast.schema = ast.invocation.schema.clone();
            return typeCheckInput(ast.invocation, schemas, scope, classes, useMeta, isDeclaration);
        });
    }
    if (ast.isFilter) {
        log('Filter');
        return typeCheckTable(ast.table, schemas, scope, classes, useMeta, isDeclaration).then(() => {
            ast.schema = ast.table.schema.clone();
            return typeCheckFilter(ast.filter, ast.schema, scope, schemas, classes, useMeta);
        });
    }
    if (ast.isProjection) {
        log('Projection');
        return typeCheckTable(ast.table, schemas, scope, classes, useMeta, isDeclaration).then(() => {
            ast.schema = ast.table.schema.clone();
            resolveProjection(ast.args, ast.schema, scope);
            return Promise.resolve();
        });
    }
    if (ast.isAlias) {
        log('Alias');
        return typeCheckTable(ast.table, schemas, scope, classes, useMeta, isDeclaration).then(() => {
            ast.schema = ast.table.schema.clone();
            scope.addGlobal(ast.name, ast.schema);
            scope.prefix(ast.name);
            return Promise.resolve();
        });
    }
    if (ast.isAggregation) {
        log('Aggregation');
        return typeCheckTable(ast.table, schemas, scope, classes, useMeta, isDeclaration).then(() => {
            ast.schema = ast.table.schema.clone();
            return typeCheckAggregation(ast, scope);
        });
    }
    if (ast.isArgMinMax) {
        log('ArgMinMax');
        return typeCheckTable(ast.table, schemas, scope, classes, useMeta, isDeclaration).then(() => {
            ast.schema = ast.table.schema.clone();
            return typeCheckArgMinMax(ast);
        });
    }
    if (ast.isJoin) {
        log('Join');
        let leftscope = new Scope(scope);
        let rightscope = new Scope(scope);
        return Promise.resolve()
            .then(() => typeCheckTable(ast.lhs, schemas, leftscope, classes, useMeta, isDeclaration))
            .then(() => {
                return typeCheckTable(ast.rhs, schemas, rightscope, classes, useMeta, isDeclaration);
            }).then(() => {
                resolveJoin(ast, ast.lhs, ast.rhs);
                leftscope.$has_event = true;
                for (let inParam of ast.in_params)
                    rightscope.removeInReq(inParam.name, leftscope.get(inParam.value.name));
                return typeCheckJoinInput(ast, schemas, leftscope, classes, useMeta);
            }).then(() => {
                scope.merge(leftscope);
                scope.merge(rightscope);
            });
    }
    if (ast.isWindow || ast.isTimeSeries) {
        log('Window or TimeSeries');
        if (ast.isWindow && (!typeForValue(ast.base, scope).isNumber || !typeForValue(ast.delta, scope).isNumber))
            throw new TypeError('Invalid range for window');
        if (ast.isTimeSeries && (!typeForValue(ast.base, scope).isDate
                || !typeForValue(ast.delta, scope).isMeasure
                || typeForValue(ast.delta, scope).unit !== 'ms'))
            throw new TypeError('Invalid time range');
        return typeCheckStream(ast.stream, schemas, scope, classes, useMeta, isDeclaration).then(() => {
            ast.schema = ast.stream.schema.clone();
            return Promise.resolve();
        });
    }
    if (ast.isSequence || ast.isHistory) {
        log('Sequence or History');
        if (ast.isSequence && (!typeForValue(ast.base, scope).isNumber || !typeForValue(ast.delta, scope).isNumber))
            throw new TypeError('Invalid range for window');
        if (ast.isHistory && (!typeForValue(ast.base, scope).isDate
                || !typeForValue(ast.delta, scope).isMeasure
                || typeForValue(ast.delta, scope).unit !== 'ms'))
            throw new TypeError('Invalid time range');
        return typeCheckStream(ast.table, schemas, scope, classes, useMeta, isDeclaration).then(() => {
            ast.schema = ast.table.schema.clone();
            return Promise.resolve();
        });
    }
    if (ast.isCompute) {
        log('Compute');
        return typeCheckTable(ast.table, schemas, scope, classes, useMeta, isDeclaration).then(() => {
            ast.schema = ast.table.schema.clone();
            return typeCheckComputation(ast, scope, schemas, classes, useMeta);
        });
    }
    throw new Error('Not Implemented');
}

function typeCheckStream(ast, schemas, scope, classes, useMeta = false, isDeclaration = false) {
    log('Type check stream ...');
    if (ast.isVarRef) {
        if (scope.hasGlobal(ast.name))
            ast.schema = scope.getSchema(ast.name).clone();

        return ensureSchema(schemas, classes, ast, 'query', useMeta).then(() => {
            return typeCheckInput(ast, schemas, scope, classes, useMeta, isDeclaration);
        });
    }
    if (ast.isTimer || ast.isAtTimer) {
        ast.schema = Builtin.emptyFunction;
        return Promise.resolve();
    }
    if (ast.isMonitor) {
        log('Monitor');
        return typeCheckTable(ast.table, schemas, scope, classes, useMeta, isDeclaration).then(() => {
            ast.schema = ast.table.schema.clone();
            return typeCheckMonitor(ast);
        });
    }
    if (ast.isEdgeNew) {
        return typeCheckStream(ast.stream, schemas, scope, classes, useMeta, isDeclaration).then(() => {
            ast.schema = ast.stream.schema.clone();
            return Promise.resolve();
        });
    }
    if (ast.isEdgeFilter) {
        return typeCheckStream(ast.stream, schemas, scope, classes, useMeta, isDeclaration).then(() => {
            ast.schema = ast.stream.schema.clone();
            return typeCheckFilter(ast.filter, ast.schema, scope, schemas, classes, useMeta);
        });
    }
    if (ast.isFilter) {
        log('Filter');
        return typeCheckStream(ast.stream, schemas, scope, classes, useMeta, isDeclaration).then(() => {
            ast.schema = ast.stream.schema.clone();
            return typeCheckFilter(ast.filter, ast.schema, scope, schemas, classes, useMeta);
        });
    }
    if (ast.isAlias) {
        return typeCheckStream(ast.stream, schemas, scope, classes, useMeta, isDeclaration).then(() => {
            ast.schema = ast.stream.schema.clone();
            scope.addGlobal(ast.name, ast.schema);
            scope.prefix(ast.name);
            return Promise.resolve();
        });
    }
    if (ast.isProjection) {
        log('Projection');
        return typeCheckStream(ast.stream, schemas, scope, classes, useMeta, isDeclaration).then(() => {
            ast.schema = ast.stream.schema.clone();
            resolveProjection(ast.args, ast.schema, scope);
            return Promise.resolve();
        });
    }
    if (ast.isJoin) {
        log('Join');
        let leftscope = new Scope(scope);
        let rightscope = new Scope(scope);
        return Promise.resolve()
            .then(() => typeCheckStream(ast.stream, schemas, leftscope, classes, useMeta, isDeclaration))
            .then(() => {
                return typeCheckTable(ast.table, schemas, rightscope, classes, useMeta, isDeclaration);
            }).then(() => {
                resolveJoin(ast, ast.stream, ast.table);
                leftscope.$has_event = true;
                for (let inParam of ast.in_params)
                    rightscope.removeInReq(inParam.name, leftscope.get(inParam.value.name));
                return typeCheckJoinInput(ast, schemas, leftscope, classes, useMeta);
            }).then(() => {
                scope.merge(leftscope);
                scope.merge(rightscope);
            });
    }
    throw new Error('Not Implemented');
}

function typeCheckDeclaration(ast, schemas, scope, classes, useMeta) {
    return Promise.resolve().then(() => {
        switch (ast.type) {
            case 'stream':
                scope.initLambdaArgs(ast.args);
                return typeCheckStream(ast.value, schemas, scope, classes, useMeta, true).then(() => {
                    let schema = ast.value.schema.clone();
                    updateLambdaArgs(schema, scope, ast.args);
                    scope.clean(ast.args);
                    scope.addGlobal(ast.name, schema);
                    return Promise.resolve();
                });
            case 'table':
                scope.initLambdaArgs(ast.args);
                return typeCheckTable(ast.value, schemas, scope, classes, useMeta, true).then(() => {
                    let schema = ast.value.schema.clone();
                    updateLambdaArgs(schema, scope, ast.args);
                    scope.clean(ast.args);
                    scope.addGlobal(ast.name, schema);
                    return Promise.resolve();
                });
            case 'action':
                scope.initLambdaArgs(ast.args);
                return typeCheckOutput(ast.value, schemas, scope, classes, useMeta, true).then(() => {
                    let schema = ast.value.schema.clone();
                    updateLambdaArgs(schema, scope, ast.args);
                    scope.clean(ast.args);
                    scope.addGlobal(ast.name, schema);
                    return Promise.resolve();
                });
            default:
                throw new TypeError(`Invalid declaration type ${ast.type}`);
        }
    });
}

function addRequiredInputParams(prim, scope) {
    let present = new Set;
    for (let in_param of prim.in_params)
        present.add(in_param.name);

    for (let name in prim.schema.inReq) {
        if (!present.has(name) && name in scope._inReq)
            prim.in_params.push(Ast.InputParam(name, Ast.Value.Undefined(true)));
    }
}

function typeCheckRule(ast, schemas, scope, classes, useMeta = false) {
    log('Type check rule ...');
    return Promise.resolve().then(() => {
        if (ast.table !== undefined && ast.table !== null)
            return typeCheckTable(ast.table, schemas, scope, classes, useMeta);
        else if (ast.stream !== undefined && ast.stream !== null)
            return typeCheckStream(ast.stream, schemas, scope, classes, useMeta);
        else
            return null;
    }).then((event) => {
        if (event !== null)
            scope.$has_event = true;
        if (ast.isRule) {
            for (let [,prim] of ast.stream.iteratePrimitives())
                addRequiredInputParams(prim, scope);
        } else if (ast.table) {
            for (let [,prim] of ast.table.iteratePrimitives())
                addRequiredInputParams(prim, scope);
        }

        if (ast.actions.some((a) => a.selector.isBuiltin) && !ast.stream && !ast.table)
            throw new TypeError('Cannot return a result without a GET function');
    }).then(() => Promise.all(
        ast.actions.map((action) => typeCheckOutput(action, schemas, scope, classes, useMeta)))
    ).then(() => {
        for (let prim of ast.actions)
            addRequiredInputParams(prim, scope);
    });
}

function typeCheckProgram(ast, schemas, useMeta = false) {
    const classes = {};
    ast.classes.forEach((ast) => {
        classes[ast.name] = ast;
    });
    const scope = new Scope();
    if (ast.principal !== null)
        typecheckPrincipal(ast.principal);

    function declLoop(i) {
        if (i === ast.declarations.length)
            return Promise.resolve();
        scope.clean();
        return typeCheckDeclaration(ast.declarations[i], schemas, scope, classes, useMeta).then(() => declLoop(i+1));
    }
    function ruleLoop(i) {
        if (i === ast.rules.length)
            return Promise.resolve();
        scope.clean();
        return typeCheckRule(ast.rules[i], schemas, scope, classes, useMeta).then(() => ruleLoop(i+1));
    }

    return Promise.resolve().then(() => declLoop(0)).then(() => ruleLoop(0));
}

function getAllowedSchema(allowed, schemaType, schemas, getMeta) {
    if (!allowed.isSpecified)
        return Promise.resolve();
    if (allowed.schema) {
        return Promise.resolve(allowed.schema);
    } else {
        return Utils.getSchemaForSelector(schemas, allowed.kind, allowed.channel, schemaType, getMeta, {})
            .then((schema) => {
                allowed.schema = schema;
                return schema;
            });
    }
}

function typeCheckPermissionRule(permissionRule, schemas, getMeta = false) {
    return Promise.all([
        getAllowedSchema(permissionRule.query, 'queries', schemas, getMeta),
        getAllowedSchema(permissionRule.action, 'actions', schemas, getMeta)
    ]).then(() => {
        const scope = new Scope();
        scope.add('source', Type.Entity('tt:contact'));
        return typeCheckFilter(permissionRule.principal, null, scope, schemas, {}, getMeta);
    }).then(() => {
        const scope = new Scope();
        function typecheckPermissionFunction(fn) {
            if (!fn.isSpecified)
                return Promise.resolve();

            return typeCheckFilter(fn.filter, fn.schema, scope, schemas, {}, getMeta).then(() => {
                for (let name in fn.schema.out)
                    scope.add(name, fn.schema.out[name]);
            });
        }
        return typecheckPermissionFunction(permissionRule.query).then(() => {
            scope.$has_event = true;
            return typecheckPermissionFunction(permissionRule.action);
        });
    });
}

module.exports = {
    typeCheckInput,
    typeCheckOutput,
    typeCheckRule,
    typeCheckTable,
    typeCheckStream,
    typeCheckProgram,
    typeCheckFilter,
    typeCheckPermissionRule
};
},{"./ast":44,"./builtin":46,"./type":65,"./utils":68,"assert":8}],67:[function(require,module,exports){
// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2015-2016 The Board of Trustees of the Leland Stanford Junior University
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
//
// See COPYING for details
"use strict";

exports.UnitsToBaseUnit = {
    // time
    'ms': 'ms', // base unit for time is milliseconds, because +new Date gives milliseconds
    's': 'ms',
    'min': 'ms',
    'h': 'ms',
    'day': 'ms',
    'week': 'ms',
    'mon': 'ms', // business month, aka exactly 30 days
    'year': 'ms', // business year (365 days exactly, no leap years)
    // length
    'm': 'm',
    'km': 'm',
    'mm': 'm',
    'cm': 'm',
    'mi': 'm',
    'in': 'm',
    'ft': 'm',
    // speed
    'mps': 'mps', // meters per second, usually written as m/s but m/s is not an identifier
    'kmph': 'mps',
    'mph': 'mps',
    // weight
    'kg': 'kg',
    'g': 'kg',
    'lb': 'kg',
    'oz': 'kg',
    // pressure (for weather or blood)
    'Pa': 'Pa',
    'bar': 'Pa',
    'psi': 'Pa',
    'mmHg': 'Pa',
    'inHg': 'Pa',
    'atm': 'Pa',
    // temperature
    'C': 'C',
    'F': 'C',
    'K': 'C',
    // energy
    'kcal': 'kcal',
    'kJ': 'kcal',
    // file and memory sizes
    'byte': 'byte',
    'KB': 'byte',
    'KiB': 'byte',
    'MB': 'byte',
    'MiB': 'byte',
    'GB': 'byte',
    'GiB': 'byte',
    'TB': 'byte',
    'TiB': 'byte'
};

exports.UnitsTransformToBaseUnit = {
    'ms': 1,
    's': 1000,
    'min': 60 * 1000,
    'h': 3600 * 1000,
    'day': 86400 * 1000,
    'week': 86400 * 7 * 1000,
    'mon': 86400 * 30 * 1000,
    'year': 86400 * 365 * 1000,
    'm': 1,
    'km': 1000,
    'mm': 1/1000,
    'cm': 1/100,
    'mi': 1609.344,
    'in': 0.0254,
    'ft': 0.3048,
    'mps': 1,
    'kmph': 0.27777778,
    'mph': 0.44704,
    'kg': 1,
    'g': 1/1000,
    'lb': 0.45359237,
    'oz': 0.028349523,
    'Pa': 1,
    'bar': 100000,
    'psi': 6894.7573,
    'mmHg': 133.32239,
    'inHg': 3386.3886,
    'atm': 101325,
    'C': 1,
    'F': function(x) { return (x - 32)/1.8; },
    'K': function(x) { return x - 273.15; },
    'kcal': 1,
    'kJ': 0.239006,
    'byte': 1,
    'KB': 1000,
    'KiB': 1024,
    'MB': 1000*1000,
    'MiB': 1024*1024,
    'GB': 1000*1000*1000,
    'GiB': 1024*1024*1024,
    'TB': 1000*1000*1000*1000,
    'TiB': 1024*1024*1024*1024
};

exports.UnitsInverseTransformFromBaseUnit = {
    'F': function(x) { return x*1.8 + 32; },
    'K': function(x) { return x + 273.15; }
};

exports.transformToBaseUnit = function(value, unit) {
    var transform = exports.UnitsTransformToBaseUnit[unit];
    if (typeof transform === 'function')
        return transform(value);
    else
        return value * transform;
};

exports.normalizeUnit = function(unit) {
    if (unit === '')
        return '';
    var baseunit = exports.UnitsToBaseUnit[unit];
    if (baseunit === undefined)
        throw new TypeError('Invalid unit ' + unit);
    return baseunit;
};
},{}],68:[function(require,module,exports){
// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2015-2016 The Board of Trustees of the Leland Stanford Junior University
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
//
// See COPYING for details
"use strict";

const Ast = require('./ast');

function makeIndex(args) {
    var index = {};
    var i = 0;
    for (var a of args)
        index[a] = i++;
    return index;
}

function clean(name) {
    if (/^[vwg]_/.test(name))
        name = name.substr(2);
    return name.replace(/_/g, ' ').replace(/([^A-Z])([A-Z])/g, '$1 $2').toLowerCase();
}

module.exports = {
    makeIndex,
    clean,

    generatorToAsync(fn) {
        return function () {
            var gen = fn.apply(this, arguments);
            return new Promise((resolve, reject) => {
                function step(key, arg) {
                    try {
                        var info = gen[key](arg);
                        var value = info.value;
                    } catch (error) {
                        reject(error);
                        return;
                    }
                    if (info.done)
                        resolve(value);
                    else
                        Promise.resolve(value).then((value) => { step("next", value); }, (err) => { step("throw", err); });
                }
                step("next");
            });
        };
    },

    splitArgsForSchema(schema, schemaType, isMeta) {
        var inReqParams = {};
        var inOptParams = {};
        var outParams = {};
        var argIndex = {};

        var types;
        if (isMeta)
            types = schema.schema;
        else
            types = schema.types;
        types.forEach((t, i) => {
            var argname = schema.args[i];
            argIndex[argname] = i;

            var argrequired = !!schema.required[i];
            var arginput = !!schema.is_input[i];
            if (argrequired)
                inReqParams[argname] = t;
            else if (arginput)
                inOptParams[argname] = t;
            else
                outParams[argname] = t;
        });

        return new Ast.FunctionDef(schema.kind_type || 'other',
                               schema.args,
                               types,
                               argIndex,
                               inReqParams,
                               inOptParams,
                               outParams,
                               schema.is_list,
                               schema.is_monitorable,
                               schema.canonical || '',
                               schema.confirmation || '',
                               schema.confirmation_remote || '',
                               schema.argcanonicals || schema.args,
                               schema.questions || []);
    },

    getSchemaForSelector(schemaRetriever, type, name, schemaType, getMeta = false, classes = {}) {
        if (type in classes) {
            let classdef = classes[type];
            if (classdef.extends === 'remote')
                classdef.extends = 'org.thingpedia.builtin.thingengine.remote';
            if (classdef.extends !== 'org.thingpedia.builtin.thingengine.remote')
                throw new TypeError('Inline class definitions that extend other than @org.thingpedia.builtin.thingengine.remote are not supported');
            let where = schemaRetriever._where(schemaType);
            return Promise.resolve(classes[type][where][name]);
        }
        if (getMeta)
            return schemaRetriever.getMeta(type, schemaType, name).then((meta) => module.exports.splitArgsForSchema(meta, schemaType, true));
        else
            return schemaRetriever.getSchemaAndNames(type, schemaType, name).then((schema) => module.exports.splitArgsForSchema(schema, schemaType, false));
    },

    getMemorySchema(schemaRetriever, table, getMeta = false) {
        return schemaRetriever.getMemorySchema(table, getMeta).then((schema) => {
            if (!schema)
                return null;

            let args = schema.args;
            let types = schema.types;
            let inReq = {};
            let inOpt = {};
            let out = {};
            schema.args.forEach((arg, i) => {
                out[arg] = schema.types[i];
            });
            let index = makeIndex(args);

            return new Ast.FunctionDef('builtin',
                args, // args
                types, // types
                index, // index
                inReq, // inReq
                inOpt, // inOpt
                out, // out
                true, // is_list
                true, // is_monitorable
                '', // canonical
                '', // confirmation
                '', // confirmation_remote,
                [], // argcanonicals,
                [] // questions
            );
        });
    },

    isUnaryTableToTableOp(table) {
        return table.isFilter ||
            table.isProjection ||
            table.isCompute ||
            table.isAlias ||
            table.isAggregation ||
            table.isArgMinMax ||
            table.isSequence ||
            table.isHistory;
    },
    isUnaryStreamToTableOp(table) {
        return table.isWindow || table.isTimeSeries;
    },
    isUnaryStreamToStreamOp(stream) {
        return stream.isEdgeNew ||
            stream.isEdgeFilter ||
            stream.isFilter ||
            stream.isProjection ||
            stream.isCompute ||
            stream.isAlias;
    },
    isUnaryTableToStreamOp(stream) {
        return stream.isMonitor;
    }
};

},{"./ast":44}],69:[function(require,module,exports){
(function (setImmediate,clearImmediate){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this,require("timers").setImmediate,require("timers").clearImmediate)
},{"process/browser.js":21,"timers":69}],70:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],71:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],72:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],73:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":72,"_process":21,"inherits":71}],74:[function(require,module,exports){
var indexOf = function (xs, item) {
    if (xs.indexOf) return xs.indexOf(item);
    else for (var i = 0; i < xs.length; i++) {
        if (xs[i] === item) return i;
    }
    return -1;
};
var Object_keys = function (obj) {
    if (Object.keys) return Object.keys(obj)
    else {
        var res = [];
        for (var key in obj) res.push(key)
        return res;
    }
};

var forEach = function (xs, fn) {
    if (xs.forEach) return xs.forEach(fn)
    else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
    }
};

var defineProp = (function() {
    try {
        Object.defineProperty({}, '_', {});
        return function(obj, name, value) {
            Object.defineProperty(obj, name, {
                writable: true,
                enumerable: false,
                configurable: true,
                value: value
            })
        };
    } catch(e) {
        return function(obj, name, value) {
            obj[name] = value;
        };
    }
}());

var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];

function Context() {}
Context.prototype = {};

var Script = exports.Script = function NodeScript (code) {
    if (!(this instanceof Script)) return new Script(code);
    this.code = code;
};

Script.prototype.runInContext = function (context) {
    if (!(context instanceof Context)) {
        throw new TypeError("needs a 'context' argument.");
    }
    
    var iframe = document.createElement('iframe');
    if (!iframe.style) iframe.style = {};
    iframe.style.display = 'none';
    
    document.body.appendChild(iframe);
    
    var win = iframe.contentWindow;
    var wEval = win.eval, wExecScript = win.execScript;

    if (!wEval && wExecScript) {
        // win.eval() magically appears when this is called in IE:
        wExecScript.call(win, 'null');
        wEval = win.eval;
    }
    
    forEach(Object_keys(context), function (key) {
        win[key] = context[key];
    });
    forEach(globals, function (key) {
        if (context[key]) {
            win[key] = context[key];
        }
    });
    
    var winKeys = Object_keys(win);

    var res = wEval.call(win, this.code);
    
    forEach(Object_keys(win), function (key) {
        // Avoid copying circular objects like `top` and `window` by only
        // updating existing context properties or new properties in the `win`
        // that was only introduced after the eval.
        if (key in context || indexOf(winKeys, key) === -1) {
            context[key] = win[key];
        }
    });

    forEach(globals, function (key) {
        if (!(key in context)) {
            defineProp(context, key, win[key]);
        }
    });
    
    document.body.removeChild(iframe);
    
    return res;
};

Script.prototype.runInThisContext = function () {
    return eval(this.code); // maybe...
};

Script.prototype.runInNewContext = function (context) {
    var ctx = Script.createContext(context);
    var res = this.runInContext(ctx);

    if (context) {
        forEach(Object_keys(ctx), function (key) {
            context[key] = ctx[key];
        });
    }

    return res;
};

forEach(Object_keys(Script.prototype), function (name) {
    exports[name] = Script[name] = function (code) {
        var s = Script(code);
        return s[name].apply(s, [].slice.call(arguments, 1));
    };
});

exports.createScript = function (code) {
    return exports.Script(code);
};

exports.createContext = Script.createContext = function (context) {
    var copy = new Context();
    if(typeof context === 'object') {
        forEach(Object_keys(context), function (key) {
            copy[key] = context[key];
        });
    }
    return copy;
};

},{}]},{},[6]);
